# Cognito User Pools

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}

## Grundinformationen

Ein Benutzerpool ist ein Benutzerverzeichnis in Amazon Cognito. Mit einem Benutzerpool k√∂nnen sich Ihre Benutzer **in Ihre Web- oder mobile App** √ºber Amazon Cognito **einloggen** oder sich √ºber einen **drittanbieter** Identit√§tsanbieter (IdP) **f√∂derieren**. Egal, ob sich Ihre Benutzer direkt oder √ºber einen Drittanbieter anmelden, alle Mitglieder des Benutzerpools haben ein Verzeichnisprofil, auf das Sie √ºber ein SDK zugreifen k√∂nnen.

Benutzerpools bieten:

* Anmelde- und Registrierungsdienste.
* Eine integrierte, anpassbare Web-Benutzeroberfl√§che, um Benutzer anzumelden.
* Soziale Anmeldungen mit Facebook, Google, Login mit Amazon und Anmelden mit Apple sowie √ºber SAML- und OIDC-Identit√§tsanbieter aus Ihrem Benutzerpool.
* Benutzerverzeichnisverwaltung und Benutzerprofile.
* Sicherheitsfunktionen wie Multi-Faktor-Authentifizierung (MFA), √úberpr√ºfungen auf kompromittierte Anmeldeinformationen, Schutz vor Konto√ºbernahme sowie Telefon- und E-Mail-Verifizierung.
* Angepasste Workflows und Benutzermigration durch AWS Lambda-Trigger.

**Quellcode** von Anwendungen enth√§lt normalerweise auch die **Benutzerpool-ID** und die **Client-Anwendungs-ID** (und manchmal das **Anwendungsgeheimnis**?), die ben√∂tigt werden, damit sich ein **Benutzer** in einen Cognito-Benutzerpool **einloggen** kann.

### Potenzielle Angriffe

* **Registrierung**: Standardm√§√üig kann sich ein Benutzer selbst registrieren, sodass er einen Benutzer f√ºr sich selbst erstellen k√∂nnte.
* **Benutzerenumeration**: Die Registrierungsfunktion kann verwendet werden, um Benutzernamen zu finden, die bereits existieren. Diese Informationen k√∂nnen f√ºr den Brute-Force-Angriff n√ºtzlich sein.
* **Login-Brute-Force**: Im Abschnitt [**Authentifizierung**](cognito-user-pools.md#authentication) finden Sie alle **Methoden**, die ein Benutzer hat, um sich **einzuloggen**. Sie k√∂nnten versuchen, diese **g√ºltigen Anmeldeinformationen** durch Brute-Force zu finden.

### Tools f√ºr pentesting

* [Pacu](https://github.com/RhinoSecurityLabs/pacu) enth√§lt jetzt die Module `cognito__enum` und `cognito__attack`, die die Enumeration aller Cognito-Ressourcen in einem Konto automatisieren und schwache Konfigurationen, Benutzerattribute, die f√ºr die Zugriffskontrolle verwendet werden, usw. kennzeichnen sowie die Benutzererstellung (einschlie√ülich MFA-Unterst√ºtzung) und die Privilegieneskalation basierend auf modifizierbaren benutzerdefinierten Attributen, verwendbaren Identit√§tspool-Anmeldeinformationen, √ºbernehmbaren Rollen in ID-Token usw. automatisieren.\
F√ºr eine Beschreibung der Funktionen der Module siehe Teil 2 des [Blogbeitrags](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2). F√ºr Installationsanweisungen siehe die Hauptseite [Pacu](https://github.com/RhinoSecurityLabs/pacu).
```bash
# Run cognito__enum usage to gather all user pools, user pool clients, identity pools, users, etc. visible in the current AWS account
Pacu (new:test) > run cognito__enum

# cognito__attack usage to attempt user creation and all privesc vectors against a given identity pool and user pool client:
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
* [Cognito Scanner](https://github.com/padok-team/cognito-scanner) ist ein CLI-Tool in Python, das verschiedene Angriffe auf Cognito implementiert, einschlie√ülich unerw√ºnschter Kontoerstellung und Konto-Orakel. Weitere Informationen finden Sie unter [diesem Link](https://github.com/padok-team/cognito-scanner).
```bash
# Install
pip install cognito-scanner
# Run
cognito-scanner --help
```
* [CognitoAttributeEnum](https://github.com/punishell/CognitoAttributeEnum): Dieses Skript erm√∂glicht es, g√ºltige Attribute f√ºr Benutzer aufzulisten.
```bash
python cognito-attribute-enu.py -client_id 16f1g98bfuj9i0g3f8be36kkrl
```
## Registrierung

User Pools erlaubt standardm√§√üig die **Registrierung neuer Benutzer**.
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### Wenn sich jeder registrieren kann

M√∂glicherweise finden Sie einen Fehler, der Ihnen anzeigt, dass Sie **mehr Details** √ºber den Benutzer bereitstellen m√ºssen:
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
Sie k√∂nnen die ben√∂tigten Details mit einem JSON wie folgt bereitstellen:
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
Sie k√∂nnten diese Funktionalit√§t auch verwenden, um **bestehende Benutzer aufzulisten.** Dies ist die Fehlermeldung, wenn ein Benutzer mit diesem Namen bereits existiert:
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
Beachten Sie im vorherigen Befehl, wie die **benutzerdefinierten Attribute mit "custom:" beginnen**.\
Wissen Sie auch, dass Sie bei der Registrierung **keine neuen benutzerdefinierten Attribute f√ºr den Benutzer erstellen k√∂nnen**. Sie k√∂nnen nur Werte f√ºr **Standardattribute** (auch wenn sie nicht erforderlich sind) und **angegebene benutzerdefinierte Attribute** angeben.
{% endhint %}

Oder um einfach zu testen, ob eine Client-ID existiert. Dies ist der Fehler, wenn die Client-ID nicht existiert:
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### Wenn nur der Administrator Benutzer registrieren kann

Sie werden diesen Fehler finden und Sie werden nicht in der Lage sein, Benutzer zu registrieren oder aufzulisten:
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### Verifying Registration

Cognito erm√∂glicht es, **einen neuen Benutzer zu verifizieren, indem seine E-Mail oder Telefonnummer verifiziert wird**. Daher werden Sie beim Erstellen eines Benutzers normalerweise mindestens den Benutzernamen und das Passwort sowie die **E-Mail und/oder Telefonnummer** ben√∂tigen. Setzen Sie einfach eine **die Sie kontrollieren**, damit Sie den Code erhalten, um Ihr neu erstelltes Benutzer **konto** wie folgt zu **verifizieren**:
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
Selbst wenn **es so aussieht, als k√∂nnte man dieselbe E-Mail** und Telefonnummer verwenden, wird Cognito bei der Verifizierung des erstellten Benutzers sich dar√ºber beschweren, dass dieselben Informationen verwendet werden, und **wird die Verifizierung des Kontos nicht zulassen**.
{% endhint %}

### Privilegieneskalation / Aktualisierung von Attributen

Standardm√§√üig kann ein Benutzer **den Wert seiner Attribute √§ndern** mit etwas wie:
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### Benutzerdefinierte Attribut-Privesc

{% hint style="danger" %}
Sie k√∂nnten **benutzerdefinierte Attribute** finden (wie `isAdmin`), da Sie standardm√§√üig **die Werte Ihrer eigenen Attribute √§ndern** k√∂nnen, k√∂nnten Sie in der Lage sein, **Privilegien zu eskalieren**, indem Sie den Wert selbst √§ndern!
{% endhint %}

#### E-Mail/Benutzername-Modifikation Privesc

Sie k√∂nnen dies verwenden, um die **E-Mail und Telefonnummer** eines Benutzers zu **√§ndern**, aber selbst wenn das Konto als verifiziert bleibt, sind diese Attribute **im Status "nicht verifiziert" gesetzt** (Sie m√ºssen sie erneut verifizieren).

{% hint style="warning" %}
Sie **werden sich nicht mit E-Mail oder Telefonnummer anmelden k√∂nnen**, bis Sie sie verifizieren, aber Sie werden sich **mit dem Benutzernamen anmelden k√∂nnen**.\
Beachten Sie, dass selbst wenn die E-Mail ge√§ndert und nicht verifiziert wurde, sie im ID-Token im **`email`** **Feld** erscheinen wird und das Feld **`email_verified`** **falsch** sein wird, aber wenn die App **nicht √ºberpr√ºft, k√∂nnten Sie andere Benutzer impersonieren**.

Dar√ºber hinaus beachten Sie, dass Sie alles in das **`name`** Feld einf√ºgen k√∂nnen, indem Sie das **name-Attribut** √§ndern. Wenn eine App aus irgendeinem Grund **dieses** Feld **anstatt des `email`** (oder eines anderen Attributs) √ºberpr√ºft, k√∂nnten Sie in der Lage sein, **andere Benutzer zu impersonieren**.
{% endhint %}

Wenn Sie aus irgendeinem Grund Ihre E-Mail beispielsweise auf eine neue, auf die Sie zugreifen k√∂nnen, ge√§ndert haben, k√∂nnen Sie **die E-Mail mit dem Code best√§tigen, den Sie an diese E-Mail-Adresse erhalten haben**:
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
Verwenden Sie **`phone_number`** anstelle von **`email`**, um eine **neue Telefonnummer** zu √§ndern/zu verifizieren.

{% hint style="info" %}
Der Administrator k√∂nnte auch die Option aktivieren, sich mit einem vom Benutzer bevorzugten Benutzernamen anzumelden. Beachten Sie, dass Sie diesen Wert nicht auf **irgendeinen Benutzernamen oder bevorzugten\_Benutzernamen, der bereits verwendet wird**, √§ndern k√∂nnen, um einen anderen Benutzer zu impersonieren.
{% endhint %}

### Passwort wiederherstellen/√§ndern

Es ist m√∂glich, ein Passwort nur **mit dem Benutzernamen** (oder E-Mail oder Telefon wird akzeptiert) wiederherzustellen, und der Zugriff darauf ist erforderlich, da ein Code dorthin gesendet wird:
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
Die Antwort des Servers wird immer positiv sein, als ob der Benutzername existiert. Sie k√∂nnen diese Methode nicht verwenden, um Benutzer zu enumerieren.
{% endhint %}

Mit dem Code k√∂nnen Sie das Passwort √§ndern mit:
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
Um das Passwort zu √§ndern, m√ºssen Sie **das vorherige Passwort kennen**:
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Authentifizierung

Ein Benutzerpool unterst√ºtzt **verschiedene M√∂glichkeiten zur Authentifizierung**. Wenn Sie einen **Benutzernamen und ein Passwort** haben, werden auch **verschiedene Methoden** zum Anmelden unterst√ºtzt.\
Dar√ºber hinaus werden, wenn ein Benutzer im Pool **3 Arten von Tokens vergeben**: Das **ID-Token**, das **Access-Token** und das **Refresh-Token**.

* [**ID-Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html): Es enth√§lt Anspr√ºche √ºber die **Identit√§t des authentifizierten Benutzers**, wie `name`, `email` und `phone_number`. Das ID-Token kann auch verwendet werden, um **Benutzer zu Ihren Ressourcenservern oder Serveranwendungen zu authentifizieren**. Sie m√ºssen die **Signatur** des ID-Tokens **√ºberpr√ºfen**, bevor Sie irgendwelche Anspr√ºche im ID-Token vertrauen k√∂nnen, wenn Sie es in externen Anwendungen verwenden.
* Das ID-Token ist das Token, das **die Attributwerte des Benutzers enth√§lt**, sogar die benutzerdefinierten.
* [**Access-Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html): Es enth√§lt Anspr√ºche √ºber den authentifizierten Benutzer, eine Liste der **Benutzergruppen und eine Liste der Scopes**. Der Zweck des Access-Tokens besteht darin, **API-Operationen** im Kontext des Benutzers im Benutzerpool zu **autorisieren**. Zum Beispiel k√∂nnen Sie das Access-Token verwenden, um **Ihrem Benutzer Zugriff** zu gew√§hren, um Benutzerattribute hinzuzuf√ºgen, zu √§ndern oder zu l√∂schen.
* [**Refresh-Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html): Mit Refresh-Tokens k√∂nnen Sie **neue ID-Tokens und Access-Tokens** f√ºr den Benutzer erhalten, bis das **Refresh-Token ung√ºltig** ist. Standardm√§√üig **l√§uft das Refresh-Token 30 Tage nach** der Anmeldung Ihres Anwendungsbenutzers in Ihrem Benutzerpool ab. Wenn Sie eine Anwendung f√ºr Ihren Benutzerpool erstellen, k√∂nnen Sie die Ablaufzeit des Refresh-Tokens der Anwendung auf **einen Wert zwischen 60 Minuten und 10 Jahren** festlegen.

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

Dies ist der Authentifizierungsfluss auf der Serverseite:

* Die serverseitige Anwendung ruft die **`AdminInitiateAuth` API-Operation** auf (anstatt `InitiateAuth`). Diese Operation erfordert AWS-Anmeldeinformationen mit Berechtigungen, die **`cognito-idp:AdminInitiateAuth`** und **`cognito-idp:AdminRespondToAuthChallenge`** umfassen. Die Operation gibt die erforderlichen Authentifizierungsparameter zur√ºck.
* Nachdem die serverseitige Anwendung die **Authentifizierungsparameter** hat, ruft sie die **`AdminRespondToAuthChallenge` API-Operation** auf. Die `AdminRespondToAuthChallenge` API-Operation ist nur erfolgreich, wenn Sie AWS-Anmeldeinformationen bereitstellen.

Diese **Methode ist standardm√§√üig NICHT aktiviert**.

Um sich **anzumelden**, m√ºssen Sie Folgendes wissen:

* Benutzerpool-ID
* Client-ID
* Benutzername
* Passwort
* Client-Geheimnis (nur wenn die Anwendung so konfiguriert ist, dass ein Geheimnis verwendet wird)

{% hint style="info" %}
Um mit dieser Methode **einloggen zu k√∂nnen**, muss die Anwendung die Anmeldung mit `ALLOW_ADMIN_USER_PASSWORD_AUTH` erlauben.\
Dar√ºber hinaus ben√∂tigen Sie zur Durchf√ºhrung dieser Aktion Anmeldeinformationen mit den Berechtigungen **`cognito-idp:AdminInitiateAuth`** und **`cognito-idp:AdminRespondToAuthChallenge`**.
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>Code zum Einloggen</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

Diese Methode ist ein weiterer einfacher und **traditioneller Benutzer- und Passwort-Authentifizierungs**-Flow. Es wird empfohlen, eine **traditionelle** Authentifizierungsmethode **zu Cognito** zu **migrieren** und sie dann **deaktivieren** und stattdessen die Methode **ALLOW\_USER\_SRP\_AUTH** zu **verwenden** (da diese das Passwort niemals √ºber das Netzwerk sendet).\
Diese **Methode ist standardm√§√üig NICHT aktiviert**.

Der Hauptunterschied zur **vorherigen Authentifizierungsmethode** im Code ist, dass Sie **die Benutzerpool-ID nicht kennen m√ºssen** und dass Sie **keine zus√§tzlichen Berechtigungen** im Cognito-Benutzerpool ben√∂tigen.

Um sich **anzumelden**, m√ºssen Sie wissen:

* client id
* benutzername
* passwort
* client secret (nur wenn die App so konfiguriert ist, dass sie ein Secret verwendet)

{% hint style="info" %}
Um mit dieser Methode **einloggen zu k√∂nnen**, muss die Anwendung das Einloggen mit ALLOW\_USER\_PASSWORD\_AUTH erlauben.
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Python-Code zum Anmelden</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

Dieses Szenario ist √§hnlich wie das vorherige, aber **anstatt das Passwort** √ºber das Netzwerk zu senden, wird eine **Herausforderungsauthentifizierung durchgef√ºhrt** (also kein Passwort, das selbst verschl√ºsselt durch das Netz navigiert).\
Diese **Methode ist standardm√§√üig aktiviert**.

Um sich **einzuloggen**, m√ºssen Sie wissen:

* Benutzerpool-ID
* Client-ID
* Benutzername
* Passwort
* Client-Geheimnis (nur wenn die App so konfiguriert ist, dass sie ein Geheimnis verwendet)

<details>

<summary>Code zum Einloggen</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

Diese **Methode wird immer g√ºltig sein** (sie kann nicht deaktiviert werden), aber Sie m√ºssen ein g√ºltiges Refresh-Token haben.
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>Code zum Aktualisieren</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

In diesem Fall wird die **Authentifizierung** durch die **Ausf√ºhrung einer Lambda-Funktion** durchgef√ºhrt.

## Zus√§tzliche Sicherheit

### Erweiterte Sicherheit

Standardm√§√üig ist es deaktiviert, aber wenn es aktiviert ist, k√∂nnte Cognito in der Lage sein, **Konten√ºbernahmen zu erkennen**. Um die Wahrscheinlichkeit zu minimieren, sollten Sie sich von einem **Netzwerk innerhalb derselben Stadt anmelden, unter Verwendung desselben User Agents** (und IP, wenn m√∂glich)**.**

### **MFA Ger√§t merken**

Wenn sich der Benutzer von demselben Ger√§t anmeldet, k√∂nnte die MFA umgangen werden. Versuchen Sie daher, sich von demselben Browser mit denselben Metadaten (IP?) anzumelden, um den MFA-Schutz zu umgehen.

## Benutzerpool-Gruppen IAM-Rollen

Es ist m√∂glich, **Benutzer zu Benutzerpool**-Gruppen hinzuzuf√ºgen, die mit einer **IAM-Rolle** verbunden sind.\
Dar√ºber hinaus k√∂nnen **Benutzer** **mehr als 1 Gruppe mit unterschiedlichen IAM-Rollen** zugewiesen werden.

Beachten Sie, dass selbst wenn eine Gruppe innerhalb einer Gruppe mit einer angeh√§ngten IAM-Rolle ist, es erforderlich ist, dass der **Benutzerpool von einem Identit√§tspool** vertraut ist (und die Details dieses Identit√§tspools bekannt sind), um auf die IAM-Anmeldeinformationen dieser Gruppe zugreifen zu k√∂nnen.

Ein weiteres Erfordernis, um die **IAM-Rolle, die im IdToken angegeben ist**, zu erhalten, wenn ein Benutzer im Benutzerpool authentifiziert wird (`aws cognito-idp initiate-auth...`), ist, dass der **Identit√§tsanbieter** angeben muss, dass die **Rolle aus dem Token ausgew√§hlt werden muss.**

<figure><img src="../../../../.gitbook/assets/image (250).png" alt=""><figcaption></figcaption></figure>

Die **Rollen**, auf die ein Benutzer Zugriff hat, sind **im `IdToken`** enthalten, und ein Benutzer kann **ausw√§hlen, f√ºr welche Rolle er Anmeldeinformationen haben m√∂chte** mit dem **`--custom-role-arn`** von `aws cognito-identity get-credentials-for-identity`.\
Wenn jedoch die **Standardoption** die **konfigurierte** ist (`Standardrolle verwenden`), und Sie versuchen, auf eine Rolle aus dem IdToken zuzugreifen, erhalten Sie einen **Fehler** (deshalb ist die vorherige Konfiguration erforderlich):

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
Beachten Sie, dass die Rolle, die einer **User Pool Group** zugewiesen ist, **vom Identit√§tsanbieter zug√§nglich sein muss**, der **dem User Pool vertraut** (da die IAM-Rolle **Sitzungscodes von ihm abgerufen werden**).
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
