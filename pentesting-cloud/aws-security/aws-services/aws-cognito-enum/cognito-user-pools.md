# Cognito User Pools

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

Un pool d'utilisateurs est un annuaire d'utilisateurs dans Amazon Cognito. Avec un pool d'utilisateurs, vos utilisateurs peuvent **se connecter √† votre application web ou mobile** via Amazon Cognito, **ou se f√©d√©rer** via un **fournisseur d'identit√©** tiers (IdP). Que vos utilisateurs se connectent directement ou via un tiers, tous les membres du pool d'utilisateurs ont un profil d'annuaire auquel vous pouvez acc√©der via un SDK.

Les pools d'utilisateurs fournissent :

* Des services d'inscription et de connexion.
* Une interface utilisateur web int√©gr√©e et personnalisable pour connecter les utilisateurs.
* Connexion sociale avec Facebook, Google, Login with Amazon, et Sign in with Apple, ainsi que via des fournisseurs d'identit√© SAML et OIDC de votre pool d'utilisateurs.
* Gestion de l'annuaire des utilisateurs et des profils d'utilisateurs.
* Fonctionnalit√©s de s√©curit√© telles que l'authentification multi-facteurs (MFA), des v√©rifications pour des identifiants compromis, la protection contre la prise de contr√¥le de compte, et la v√©rification par t√©l√©phone et par email.
* Flux de travail personnalis√©s et migration des utilisateurs via des d√©clencheurs AWS Lambda.

Le **code source** des applications contiendra g√©n√©ralement √©galement l'**ID du pool d'utilisateurs** et l'**ID de l'application cliente**, (et parfois le **secret de l'application** ?) qui sont n√©cessaires pour qu'un **utilisateur se connecte** √† un pool d'utilisateurs Cognito.

### Potential attacks

* **Inscription** : Par d√©faut, un utilisateur peut s'inscrire lui-m√™me, il pourrait donc cr√©er un utilisateur pour lui-m√™me.
* **√ânum√©ration des utilisateurs** : La fonctionnalit√© d'inscription peut √™tre utilis√©e pour trouver des noms d'utilisateur qui existent d√©j√†. Cette information peut √™tre utile pour l'attaque par force brute.
* **Force brute de connexion** : Dans la section [**Authentication**](cognito-user-pools.md#authentication), vous avez toutes les **m√©thodes** qu'un utilisateur doit utiliser pour **se connecter**, vous pourriez essayer de les forcer pour **trouver des identifiants valides**.

### Tools for pentesting

* [Pacu](https://github.com/RhinoSecurityLabs/pacu), inclut maintenant les modules `cognito__enum` et `cognito__attack` qui automatisent l'√©num√©ration de tous les actifs Cognito dans un compte et signalent les configurations faibles, les attributs d'utilisateur utilis√©s pour le contr√¥le d'acc√®s, etc., et automatisent √©galement la cr√©ation d'utilisateurs (y compris le support MFA) et l'escalade de privil√®ges bas√©e sur des attributs personnalisables modifiables, des identifiants de pool d'identit√© utilisables, des r√¥les assumables dans des jetons d'identit√©, etc.\
Pour une description des fonctions des modules, voir la partie 2 du [blog post](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2). Pour des instructions d'installation, voir la page principale de [Pacu](https://github.com/RhinoSecurityLabs/pacu).
```bash
# Run cognito__enum usage to gather all user pools, user pool clients, identity pools, users, etc. visible in the current AWS account
Pacu (new:test) > run cognito__enum

# cognito__attack usage to attempt user creation and all privesc vectors against a given identity pool and user pool client:
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
* [Cognito Scanner](https://github.com/padok-team/cognito-scanner) est un outil CLI en python qui impl√©mente diff√©rentes attaques sur Cognito, y compris la cr√©ation de comptes non d√©sir√©s et l'oracle de compte. Consultez [ce lien](https://github.com/padok-team/cognito-scanner) pour plus d'infos.
```bash
# Install
pip install cognito-scanner
# Run
cognito-scanner --help
```
* [CognitoAttributeEnum](https://github.com/punishell/CognitoAttributeEnum) : Ce script permet d'√©num√©rer les attributs valides pour les utilisateurs.
```bash
python cognito-attribute-enu.py -client_id 16f1g98bfuj9i0g3f8be36kkrl
```
## Inscription

User Pools permet par **d√©faut** de **s'inscrire de nouveaux utilisateurs**.
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### Si quelqu'un peut s'inscrire

Vous pourriez trouver une erreur indiquant que vous devez **fournir plus de d√©tails** sur l'utilisateur :
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
Vous pouvez fournir les d√©tails n√©cessaires avec un JSON tel que :
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
Vous pouvez √©galement utiliser cette fonctionnalit√© pour **√©num√©rer les utilisateurs existants.** Voici le message d'erreur lorsqu'un utilisateur existe d√©j√† avec ce nom :
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
Notez dans la commande pr√©c√©dente comment les **attributs personnalis√©s commencent par "custom:"**.\
Sachez √©galement que lors de l'enregistrement, vous **ne pouvez pas cr√©er de nouveaux attributs personnalis√©s pour l'utilisateur**. Vous ne pouvez donner de valeur qu'aux **attributs par d√©faut** (m√™me s'ils ne sont pas requis) et aux **attributs personnalis√©s sp√©cifi√©s**.
{% endhint %}

Ou juste pour tester si un identifiant client existe. Voici l'erreur si l'identifiant client n'existe pas :
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### Si seul l'administrateur peut enregistrer des utilisateurs

Vous rencontrerez cette erreur et vous ne pourrez pas enregistrer ou √©num√©rer des utilisateurs :
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### V√©rification de l'inscription

Cognito permet de **v√©rifier un nouvel utilisateur en v√©rifiant son e-mail ou son num√©ro de t√©l√©phone**. Par cons√©quent, lors de la cr√©ation d'un utilisateur, vous devrez g√©n√©ralement fournir au moins le nom d'utilisateur et le mot de passe ainsi que l'**e-mail et/ou le num√©ro de t√©l√©phone**. Il suffit de d√©finir un **que vous contr√¥lez** afin de recevoir le code pour **v√©rifier votre** compte **d'utilisateur** nouvellement cr√©√© comme ceci :
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
M√™me si **il semble que vous pouvez utiliser le m√™me email** et num√©ro de t√©l√©phone, lorsque vous devez v√©rifier l'utilisateur cr√©√©, Cognito se plaindra d'utiliser les m√™mes informations et **ne vous permettra pas de v√©rifier le compte**.
{% endhint %}

### Escalade de privil√®ges / Mise √† jour des attributs

Par d√©faut, un utilisateur peut **modifier la valeur de ses attributs** avec quelque chose comme :
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### Privesc d'attributs personnalis√©s

{% hint style="danger" %}
Vous pourriez trouver des **attributs personnalis√©s** utilis√©s (comme `isAdmin`), car par d√©faut vous pouvez **changer les valeurs de vos propres attributs**, vous pourriez √™tre en mesure d'**escalader les privil√®ges** en changeant la valeur vous-m√™me !
{% endhint %}

#### Privesc de modification d'email/nom d'utilisateur

Vous pouvez utiliser cela pour **modifier l'email et le num√©ro de t√©l√©phone** d'un utilisateur, mais ensuite, m√™me si le compte reste v√©rifi√©, ces attributs sont **d√©finis en statut non v√©rifi√©** (vous devez les v√©rifier √† nouveau).

{% hint style="warning" %}
Vous **ne pourrez pas vous connecter avec l'email ou le num√©ro de t√©l√©phone** tant que vous ne les avez pas v√©rifi√©s, mais vous pourrez **vous connecter avec le nom d'utilisateur**.\
Notez que m√™me si l'email a √©t√© modifi√© et non v√©rifi√©, il appara√Ætra dans le jeton d'identit√© √† l'int√©rieur du **champ** **`email`** et le champ **`email_verified`** sera **faux**, mais si l'application **ne v√©rifie pas cela, vous pourriez usurper l'identit√© d'autres utilisateurs**.

De plus, notez que vous pouvez mettre n'importe quoi dans le champ **`name`** en modifiant simplement l'**attribut name**. Si une application **v√©rifie** ce champ pour une raison quelconque **au lieu de l'`email`** (ou tout autre attribut), vous pourriez √™tre en mesure d'**usurper l'identit√© d'autres utilisateurs**.
{% endhint %}

Quoi qu'il en soit, si pour une raison quelconque vous avez chang√© votre email par exemple pour un nouveau auquel vous pouvez acc√©der, vous pouvez **confirmer l'email avec le code que vous avez re√ßu √† cette adresse email** :
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
Utilisez **`phone_number`** au lieu de **`email`** pour changer/v√©rifier un **nouveau num√©ro de t√©l√©phone**.

{% hint style="info" %}
L'administrateur peut √©galement activer l'option de **connexion avec un nom d'utilisateur pr√©f√©r√© par l'utilisateur**. Notez que vous ne pourrez pas changer cette valeur pour **un nom d'utilisateur ou un preferred_username d√©j√† utilis√©** pour usurper un autre utilisateur.
{% endhint %}

### R√©cup√©rer/Changer le mot de passe

Il est possible de r√©cup√©rer un mot de passe en **connaissant le nom d'utilisateur** (ou l'email ou le t√©l√©phone est accept√©) et en y ayant acc√®s car un code y sera envoy√© :
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
La r√©ponse du serveur sera toujours positive, comme si le nom d'utilisateur existait. Vous ne pouvez pas utiliser cette m√©thode pour √©num√©rer les utilisateurs.
{% endhint %}

Avec le code, vous pouvez changer le mot de passe avec :
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
Pour changer le mot de passe, vous devez **conna√Ætre le mot de passe pr√©c√©dent** :
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Authentification

Un pool d'utilisateurs prend en charge **diff√©rentes mani√®res de s'authentifier**. Si vous avez un **nom d'utilisateur et un mot de passe**, il existe √©galement **diff√©rentes m√©thodes** prises en charge pour se connecter.\
De plus, lorsqu'un utilisateur est authentifi√© dans le Pool, **3 types de jetons sont fournis** : Le **jeton d'identit√©**, le **jeton d'acc√®s** et le **jeton d'actualisation**.

* [**Jeton d'identit√©**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html) : Il contient des revendications sur **l'identit√© de l'utilisateur authentifi√©**, telles que `name`, `email` et `phone_number`. Le jeton d'identit√© peut √©galement √™tre utilis√© pour **authentifier les utilisateurs aupr√®s de vos serveurs de ressources ou applications serveur**. Vous devez **v√©rifier** la **signature** du jeton d'identit√© avant de pouvoir faire confiance √† des revendications √† l'int√©rieur du jeton d'identit√© si vous l'utilisez dans des applications externes.
* Le jeton d'identit√© est le jeton qui **contient les valeurs des attributs de l'utilisateur**, m√™me les personnalis√©s.
* [**Jeton d'acc√®s**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html) : Il contient des revendications sur l'utilisateur authentifi√©, une liste des **groupes de l'utilisateur** et une liste de port√©es. Le but du jeton d'acc√®s est de **autoriser les op√©rations API** dans le contexte de l'utilisateur dans le pool d'utilisateurs. Par exemple, vous pouvez utiliser le jeton d'acc√®s pour **accorder √† votre utilisateur l'acc√®s** pour ajouter, modifier ou supprimer des attributs d'utilisateur.
* [**Jeton d'actualisation**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html) : Avec les jetons d'actualisation, vous pouvez **obtenir de nouveaux jetons d'identit√© et jetons d'acc√®s** pour l'utilisateur jusqu'√† ce que le **jeton d'actualisation soit invalide**. Par **d√©faut**, le jeton d'actualisation **expire 30 jours apr√®s** que l'utilisateur de votre application se connecte √† votre pool d'utilisateurs. Lorsque vous cr√©ez une application pour votre pool d'utilisateurs, vous pouvez d√©finir l'expiration du jeton d'actualisation de l'application √† **n'importe quelle valeur entre 60 minutes et 10 ans**.

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

Voici le flux d'authentification c√¥t√© serveur :

* L'application c√¥t√© serveur appelle l'**op√©ration API `AdminInitiateAuth`** (au lieu de `InitiateAuth`). Cette op√©ration n√©cessite des identifiants AWS avec des autorisations qui incluent **`cognito-idp:AdminInitiateAuth`** et **`cognito-idp:AdminRespondToAuthChallenge`**. L'op√©ration renvoie les param√®tres d'authentification requis.
* Apr√®s que l'application c√¥t√© serveur a les **param√®tres d'authentification**, elle appelle l'**op√©ration API `AdminRespondToAuthChallenge`**. L'op√©ration API `AdminRespondToAuthChallenge` ne r√©ussit que si vous fournissez des identifiants AWS.

Cette **m√©thode n'est PAS activ√©e** par d√©faut.

Pour **se connecter**, vous **devez** conna√Ætre :

* l'identifiant du pool d'utilisateurs
* l'identifiant du client
* le nom d'utilisateur
* le mot de passe
* le secret du client (uniquement si l'application est configur√©e pour utiliser un secret)

{% hint style="info" %}
Pour **pouvoir se connecter avec cette m√©thode**, cette application doit autoriser la connexion avec `ALLOW_ADMIN_USER_PASSWORD_AUTH`.\
De plus, pour effectuer cette action, vous avez besoin d'identifiants avec les autorisations **`cognito-idp:AdminInitiateAuth`** et **`cognito-idp:AdminRespondToAuthChallenge`**
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>Code de connexion</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

Cette m√©thode est un autre flux simple et **traditionnel d'authentification utilisateur & mot de passe**. Il est recommand√© de **migrer une m√©thode d'authentification traditionnelle** **vers Cognito** et **recommand√©** de **la d√©sactiver** ensuite et **d'utiliser** la m√©thode **ALLOW\_USER\_SRP\_AUTH** √† la place (car celle-ci n'envoie jamais le mot de passe sur le r√©seau).\
Cette **m√©thode n'est PAS activ√©e** par d√©faut.

La principale **diff√©rence** avec la **m√©thode d'authentification pr√©c√©dente** dans le code est que vous **n'avez pas besoin de conna√Ætre l'ID du pool d'utilisateurs** et que vous **n'avez pas besoin de permissions suppl√©mentaires** dans le pool d'utilisateurs Cognito.

Pour **se connecter**, vous **devez** conna√Ætre :

* identifiant client
* nom d'utilisateur
* mot de passe
* secret client (uniquement si l'application est configur√©e pour utiliser un secret)

{% hint style="info" %}
Pour pouvoir **se connecter avec cette m√©thode**, cette application doit permettre de se connecter avec ALLOW\_USER\_PASSWORD\_AUTH.
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Code Python pour se connecter</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

Ce sc√©nario est similaire au pr√©c√©dent mais **au lieu d'envoyer le mot de passe** √† travers le r√©seau pour se connecter, une **authentification par d√©fi est effectu√©e** (donc aucun mot de passe ne circule m√™me crypt√© √† travers le net).\
Cette **m√©thode est activ√©e** par d√©faut.

Pour **se connecter**, vous **devez** conna√Ætre :

* l'identifiant du pool d'utilisateurs
* l'identifiant du client
* le nom d'utilisateur
* le mot de passe
* le secret du client (uniquement si l'application est configur√©e pour utiliser un secret)

<details>

<summary>Code to login</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

Cette **m√©thode sera toujours valide** (elle ne peut pas √™tre d√©sactiv√©e) mais vous devez avoir un jeton de rafra√Æchissement valide.
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>Code pour rafra√Æchir</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

Dans ce cas, l'**authentification** va √™tre effectu√©e par l'**ex√©cution d'une fonction lambda**.

## S√©curit√© suppl√©mentaire

### S√©curit√© avanc√©e

Par d√©faut, c'est d√©sactiv√©, mais si activ√©, Cognito pourrait √™tre capable de **d√©tecter les prises de contr√¥le de compte**. Pour minimiser la probabilit√©, vous devriez vous connecter depuis un **r√©seau √† l'int√©rieur de la m√™me ville, en utilisant le m√™me agent utilisateur** (et l'IP si possible)**.**

### **MFA Rappeler l'appareil**

Si l'utilisateur se connecte depuis le m√™me appareil, la MFA peut √™tre contourn√©e, essayez donc de vous connecter depuis le m√™me navigateur avec les m√™mes m√©tadonn√©es (IP ?) pour essayer de contourner la protection MFA.

## R√¥les IAM des groupes de User Pool

Il est possible d'ajouter des **utilisateurs aux groupes de User Pool** qui sont li√©s √† un **r√¥le IAM**.\
De plus, des **utilisateurs** peuvent √™tre assign√©s √† **plus d'un groupe avec diff√©rents r√¥les IAM** attach√©s.

Notez que m√™me si un groupe est √† l'int√©rieur d'un groupe avec un r√¥le IAM attach√©, pour pouvoir acc√©der aux identifiants IAM de ce groupe, il est n√©cessaire que le **User Pool soit approuv√© par un Identity Pool** (et conna√Ætre les d√©tails de cet Identity Pool).

Un autre requis pour obtenir le **r√¥le IAM indiqu√© dans l'IdToken** lorsqu'un utilisateur est authentifi√© dans le User Pool (`aws cognito-idp initiate-auth...`) est que le **fournisseur d'authentification de l'Identity Provider** doit indiquer que le **r√¥le doit √™tre s√©lectionn√© √† partir du token.**

<figure><img src="../../../../.gitbook/assets/image (250).png" alt=""><figcaption></figcaption></figure>

Les **r√¥les** auxquels un utilisateur a acc√®s sont **dans le `IdToken`**, et un utilisateur peut **s√©lectionner pour quel r√¥le il aimerait des identifiants** avec le **`--custom-role-arn`** de `aws cognito-identity get-credentials-for-identity`.\
Cependant, si l'**option par d√©faut** est celle **configur√©e** (`utiliser le r√¥le par d√©faut`), et que vous essayez d'acc√©der √† un r√¥le √† partir de l'IdToken, vous obtiendrez une **erreur** (c'est pourquoi la configuration pr√©c√©dente est n√©cessaire) :

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
Notez que le r√¥le attribu√© √† un **User Pool Group** doit √™tre **accessible par le fournisseur d'identit√©** qui **fait confiance au User Pool** (car les **informations d'identification de session IAM vont √™tre obtenues √† partir de celui-ci**).
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="../../../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">[**HackTricks Formation Expert Red Team AWS (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="../../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Formation Expert Red Team GCP (GRTE)**<img src="../../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
