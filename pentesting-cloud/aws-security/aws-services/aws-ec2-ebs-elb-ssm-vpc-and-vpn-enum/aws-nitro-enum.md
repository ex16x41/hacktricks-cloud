# AWS - Nitro Enum

{% hint style="success" %}
Aprende y practica AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Aprende y practica GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informaci칩n B치sica

AWS Nitro es un conjunto de **tecnolog칤as innovadoras** que forman la plataforma subyacente para las instancias de AWS EC2. Introducido por Amazon para **mejorar la seguridad, el rendimiento y la fiabilidad**, Nitro utiliza **componentes de hardware personalizados y un hipervisor ligero**. Abstrae gran parte de la funcionalidad de virtualizaci칩n tradicional a hardware y software dedicados, **minimizando la superficie de ataque** y mejorando la eficiencia de los recursos. Al descargar las funciones de virtualizaci칩n, Nitro permite que las instancias EC2 ofrezcan un **rendimiento casi de metal desnudo**, lo que es particularmente beneficioso para aplicaciones que requieren muchos recursos. Adem치s, el Nitro Security Chip asegura espec칤ficamente la **seguridad del hardware y el firmware**, consolidando a칰n m치s su arquitectura robusta.

### Nitro Enclaves

**AWS Nitro Enclaves** proporciona un entorno de c칩mputo seguro y **aislado dentro de las instancias de Amazon EC2**, dise침ado espec칤ficamente para procesar datos altamente sensibles. Aprovechando el AWS Nitro System, estos enclaves aseguran un **aislamiento y seguridad robustos**, ideales para **manejar informaci칩n confidencial** como PII o registros financieros. Presentan un entorno minimalista, reduciendo significativamente el riesgo de exposici칩n de datos. Adem치s, Nitro Enclaves soporta la atestaci칩n criptogr치fica, permitiendo a los usuarios verificar que solo el c칩digo autorizado se est치 ejecutando, crucial para mantener estrictos est치ndares de cumplimiento y protecci칩n de datos.

{% hint style="danger" %}
Las im치genes de Nitro Enclave se **ejecutan desde dentro de las instancias EC2** y no puedes ver desde la consola web de AWS si una instancia EC2 est치 ejecutando im치genes en Nitro Enclave o no.
{% endhint %}

## Instalaci칩n de Nitro Enclave CLI

Sigue todas las instrucciones [**de la documentaci칩n**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave). Sin embargo, estas son las m치s importantes:
```bash
# Install tools
sudo amazon-linux-extras install aws-nitro-enclaves-cli -y
sudo yum install aws-nitro-enclaves-cli-devel -y

# Config perms
sudo usermod -aG ne $USER
sudo usermod -aG docker $USER

# Check installation
nitro-cli --version

# Start and enable the Nitro Enclaves allocator service.
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service
```
## Im치genes de Nitro Enclave

Las im치genes que puedes ejecutar en Nitro Enclave est치n basadas en im치genes de docker, por lo que puedes crear tus im치genes de Nitro Enclave a partir de im치genes de docker como:
```bash
# You need to have the docker image accesible in your running local registry
# Or indicate the full docker image URL to access the image
nitro-cli build-enclave --docker-uri <docker-img>:<tag> --output-file nitro-img.eif
```
Como puedes ver, las im치genes de Nitro Enclave usan la extensi칩n **`eif`** (Enclave Image File).

La salida se ver치 similar a:
```
Using the locally available Docker image...
Enclave Image successfully created.
{
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
```
### Ejecutar una Imagen

Seg칰n [**la documentaci칩n**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave), para ejecutar una imagen de enclave necesitas asignarle una memoria de **al menos 4 veces el tama침o del archivo `eif`**. Es posible configurar los recursos predeterminados para darle en el archivo&#x20;
```shell
/etc/nitro_enclaves/allocator.yaml
```
{% hint style="danger" %}
춰Recuerda siempre que necesitas **reservar algunos recursos para la instancia principal de EC2** tambi칠n!
{% endhint %}

Despu칠s de conocer los recursos a asignar a una imagen e incluso haber modificado el archivo de configuraci칩n, es posible ejecutar una imagen de enclave con:

{% code overflow="wrap" %}
```shell
# Restart the service so the new default values apply
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service

# Indicate the CPUs and memory to give
nitro-cli run-enclave --cpu-count 2 --memory 3072 --eif-path hello.eif --debug-mode --enclave-cid 16
```
{% endcode %}

### Enumerar Enclaves

Si comprometes un host EC2, es posible obtener una lista de im치genes de enclave en ejecuci칩n con:
```bash
nitro-cli describe-enclaves
```
Es **imposible obtener un shell** dentro de una imagen de enclave en ejecuci칩n porque ese es el prop칩sito principal del enclave, sin embargo, si usaste el par치metro **`--debug-mode`**, es posible obtener el **stdout** con:
```shell
ENCLAVE_ID=$(nitro-cli describe-enclaves | jq -r ".[0].EnclaveID")
nitro-cli console --enclave-id ${ENCLAVE_ID}
```
### Terminate Enclaves

Si un atacante compromete una instancia EC2, por defecto no podr치 obtener un shell dentro de ellas, pero podr치 **terminarlas** con:
```shell
nitro-cli terminate-enclave --enclave-id ${ENCLAVE_ID}
```
## Vsocks

La 칰nica forma de comunicarse con una **enclave** ejecutando una imagen es usando **vsocks**.

**Virtual Socket (vsock)** es una familia de sockets en Linux dise침ada espec칤ficamente para facilitar la **comunicaci칩n** entre m치quinas virtuales (**VMs**) y sus **hipervisores**, o entre las propias VMs. Vsock permite una comunicaci칩n eficiente y **bidireccional** sin depender de la pila de red del host. Esto hace posible que las VMs se comuniquen incluso sin configuraciones de red, **usando un ID de Contexto (CID) de 32 bits y n칰meros de puerto** para identificar y gestionar conexiones. La API de vsock soporta tanto tipos de socket de flujo como de datagrama, similar a TCP y UDP, proporcionando una herramienta vers치til para aplicaciones a nivel de usuario en entornos virtuales.

{% hint style="success" %}
Por lo tanto, una direcci칩n vsock se ve as칤: `<CID>:<Port>`
{% endhint %}

Para encontrar los **CIDs** de las im치genes en ejecuci칩n en el enclave, puedes ejecutar el siguiente comando y obtener el **`EnclaveCID`**:

<pre class="language-bash"><code class="lang-bash">nitro-cli describe-enclaves

[
{
"EnclaveName": "secure-channel-example",
"EnclaveID": "i-0bc274f83ade02a62-enc18ef3d09c886748",
"ProcessID": 10131,
<strong>    "EnclaveCID": 16,
</strong>    "NumberOfCPUs": 2,
"CPUIDs": [
1,
3
],
"MemoryMiB": 1024,
"State": "RUNNING",
"Flags": "DEBUG_MODE",
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
]
</code></pre>

{% hint style="warning" %}
춰Ten en cuenta que desde el host no hay forma de saber si un CID est치 exponiendo alg칰n puerto! A menos que uses alg칰n **esc치ner de puertos vsock como** [**https://github.com/carlospolop/Vsock-scanner**](https://github.com/carlospolop/Vsock-scanner).
{% endhint %}

### Vsock Server/Listener

Encuentra aqu칤 un par de ejemplos:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py)

<details>

<summary>Simple Python Listener</summary>
```python
#!/usr/bin/env python3

# From
https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.bind((CID, PORT))
s.listen()
(conn, (remote_cid, remote_port)) = s.accept()

print(f"Connection opened by cid={remote_cid} port={remote_port}")

while True:
buf = conn.recv(64)
if not buf:
break

print(f"Received bytes: {buf}")
```
</details>
```bash
# Using socat
socat VSOCK-LISTEN:<port>,fork EXEC:"echo Hello from server!"
```
### Vsock Client

Ejemplos:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py)

<details>

<summary>Cliente Python Simple</summary>
```python
#!/usr/bin/env python3

#From https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.connect((CID, PORT))
s.sendall(b"Hello, world!")
s.close()
```
</details>
```bash
# Using socat
echo "Hello, vsock!" | socat - VSOCK-CONNECT:3:5000
```
### Vsock Proxy

La herramienta vsock-proxy permite hacer proxy de un vsock proxy con otra direcci칩n, por ejemplo:
```bash
vsock-proxy 8001 ip-ranges.amazonaws.com 443 --config your-vsock-proxy.yaml
```
Esto reenviar치 el **puerto local 8001 en vsock** a `ip-ranges.amazonaws.com:443` y el archivo **`your-vsock-proxy.yaml`** podr칤a tener este contenido permitiendo acceder a `ip-ranges.amazonaws.com:443`:
```yaml
allowlist:
- {address: ip-ranges.amazonaws.com, port: 443}
```
Es posible ver las direcciones vsock (**`<CID>:<Port>`**) utilizadas por el host de EC2 con (note el `3:8001`, 3 es el CID y 8001 el puerto):

{% code overflow="wrap" %}
```bash
sudo ss -l -p -n | grep v_str
v_str LISTEN 0      0                                                                              3:8001                   *:*     users:(("vsock-proxy",pid=9458,fd=3))
```
{% endcode %}

## Nitro Enclave Atestaci칩n y KMS

El SDK de Nitro Enclaves permite a un enclave solicitar un **documento de atestaci칩n firmado criptogr치ficamente** del **Hypervisor** de Nitro, que incluye **mediciones 칰nicas** espec칤ficas de ese enclave. Estas mediciones, que incluyen **hashes y registros de configuraci칩n de la plataforma (PCRs)**, se utilizan durante el proceso de atestaci칩n para **probar la identidad del enclave** y **construir confianza con servicios externos**. El documento de atestaci칩n t칤picamente contiene valores como PCR0, PCR1 y PCR2, que has encontrado antes al construir y guardar un EIF de enclave.

De los [**docs**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-3-cryptographic-attestation#a-unique-feature-on-nitro-enclaves), estos son los valores de PCR:

<table><thead><tr><th width="97">PCR</th><th width="221">Hash de ...</th><th>Descripci칩n</th></tr></thead><tbody><tr><td>PCR0</td><td>Enclave image file</td><td>Una medida continua del contenido del archivo de imagen, sin los datos de la secci칩n.</td></tr><tr><td>PCR1</td><td>Linux kernel and bootstrap</td><td>Una medida continua del kernel y los datos de boot ramfs.</td></tr><tr><td>PCR2</td><td>Application</td><td>Una medida continua y en orden de las aplicaciones de usuario, sin el boot ramfs.</td></tr><tr><td>PCR3</td><td>IAM role assigned to the parent instance</td><td>Una medida continua del rol IAM asignado a la instancia principal. Asegura que el proceso de atestaci칩n tenga 칠xito solo cuando la instancia principal tenga el rol IAM correcto.</td></tr><tr><td>PCR4</td><td>Instance ID of the parent instance</td><td>Una medida continua del ID de la instancia principal. Asegura que el proceso de atestaci칩n tenga 칠xito solo cuando la instancia principal tenga un ID de instancia espec칤fico.</td></tr><tr><td>PCR8</td><td>Enclave image file signing certificate</td><td>Una medida del certificado de firma especificado para el archivo de imagen del enclave. Asegura que el proceso de atestaci칩n tenga 칠xito solo cuando el enclave se haya iniciado desde un archivo de imagen de enclave firmado por un certificado espec칤fico.</td></tr></tbody></table>

Puedes integrar la **atestaci칩n criptogr치fica** en tus aplicaciones y aprovechar las integraciones preconstruidas con servicios como **AWS KMS**. AWS KMS puede **validar atestaciones de enclave** y ofrece claves de condici칩n basadas en atestaci칩n (`kms:RecipientAttestation:ImageSha384` y `kms:RecipientAttestation:PCR`) en sus pol칤ticas de claves. Estas pol칤ticas aseguran que AWS KMS permita operaciones usando la clave KMS **solo si el documento de atestaci칩n del enclave es v치lido** y cumple con las **condiciones especificadas**.

{% hint style="success" %}
Ten en cuenta que los Enclaves en modo debug (--debug) generan documentos de atestaci칩n con PCRs que est치n compuestos de ceros (`000000000000000000000000000000000000000000000000`). Por lo tanto, las pol칤ticas de KMS que verifican estos valores fallar치n.
{% endhint %}

### Bypass de PCR

Desde la perspectiva de un atacante, nota que algunos PCRs permitir칤an modificar algunas partes o toda la imagen del enclave y a칰n ser칤an v치lidos (por ejemplo, PCR4 solo verifica el ID de la instancia principal, por lo que ejecutar cualquier imagen de enclave en ese EC2 permitir치 cumplir con este posible requisito de PCR).

Por lo tanto, un atacante que comprometa la instancia EC2 podr칤a ser capaz de ejecutar otras im치genes de enclave para eludir estas protecciones.

La investigaci칩n sobre c칩mo modificar/crear nuevas im치genes para eludir cada protecci칩n (especialmente las no tan obvias) a칰n est치 PENDIENTE.

## Referencias

* [https://medium.com/@F.DL/understanding-vsock-684016cf0eb0](https://medium.com/@F.DL/understanding-vsock-684016cf0eb0)
* Todas las partes del tutorial de Nitro de AWS: [https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli)

{% hint style="success" %}
Aprende y practica AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Aprende y practica GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya HackTricks</summary>

* Revisa los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
