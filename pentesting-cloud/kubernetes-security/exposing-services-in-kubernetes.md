# Exposing Services in Kubernetes

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

Es gibt **verschiedene M√∂glichkeiten, Dienste** in Kubernetes **exponiert** zu machen, sodass sowohl **interne** als auch **externe** Endpunkte darauf zugreifen k√∂nnen. Diese Kubernetes-Konfiguration ist ziemlich kritisch, da der Administrator **Angreifern Zugriff auf Dienste gew√§hren k√∂nnte, auf die sie keinen Zugriff haben sollten**.

### Automatische Enumeration

Bevor Sie mit der Enumeration der M√∂glichkeiten beginnen, die K8s bietet, um Dienste √∂ffentlich zug√§nglich zu machen, wissen Sie, dass Sie, wenn Sie Namespaces, Dienste und Ingresses auflisten k√∂nnen, alles finden k√∂nnen, was √∂ffentlich exponiert ist mit:
```bash
kubectl get namespace -o custom-columns='NAME:.metadata.name' | grep -v NAME | while IFS='' read -r ns; do
echo "Namespace: $ns"
kubectl get service -n "$ns"
kubectl get ingress -n "$ns"
echo "=============================================="
echo ""
echo ""
done | grep -v "ClusterIP"
# Remove the last '| grep -v "ClusterIP"' to see also type ClusterIP
```
### ClusterIP

Ein **ClusterIP**-Dienst ist der **Standard**-Kubernetes-**Dienst**. Er bietet Ihnen einen **Dienst innerhalb** Ihres Clusters, auf den andere Apps innerhalb Ihres Clusters zugreifen k√∂nnen. Es gibt **keinen externen Zugriff**.

Dieser kann jedoch √ºber den Kubernetes Proxy zugegriffen werden:
```bash
kubectl proxy --port=8080
```
Jetzt k√∂nnen Sie √ºber die Kubernetes-API auf Dienste zugreifen, indem Sie dieses Schema verwenden:

`http://localhost:8080/api/v1/proxy/namespaces/<NAMESPACE>/services/<SERVICE-NAME>:<PORT-NAME>/`

Zum Beispiel k√∂nnten Sie die folgende URL verwenden:

`http://localhost:8080/api/v1/proxy/namespaces/default/services/my-internal-service:http/`

um auf diesen Dienst zuzugreifen:
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-internal-service
spec:
selector:
app: my-app
type: ClusterIP
ports:
- name: http
port: 80
targetPort: 80
protocol: TCP
```
_Diese Methode erfordert, dass Sie `kubectl` als **authentifizierter Benutzer** ausf√ºhren._

Liste alle ClusterIPs auf:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,PORT(S):.spec.ports[*].port,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep ClusterIP
```
{% endcode %}

### NodePort

Wenn **NodePort** verwendet wird, wird ein bestimmter Port auf allen Knoten (die die virtuellen Maschinen darstellen) verf√ºgbar gemacht. **Traffic**, der an diesen spezifischen Port gerichtet ist, wird dann systematisch **zum Dienst geleitet**. Typischerweise wird diese Methode aufgrund ihrer Nachteile nicht empfohlen.

Liste aller NodePorts:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,PORT(S):.spec.ports[*].port,NODEPORT(S):.spec.ports[*].nodePort,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep NodePort
```
{% endcode %}

Ein Beispiel f√ºr die NodePort-Spezifikation:
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-nodeport-service
spec:
selector:
app: my-app
type: NodePort
ports:
- name: http
port: 80
targetPort: 80
nodePort: 30036
protocol: TCP
```
Wenn Sie **den nodePort nicht angeben**, wird ein Port im **Bereich 30000‚Äì32767 verwendet**.

### LoadBalancer <a href="#id-0d96" id="id-0d96"></a>

Stellt den Dienst extern **unter Verwendung des Load Balancers eines Cloud-Anbieters** bereit. In GKE wird dies einen [Network Load Balancer](https://cloud.google.com/compute/docs/load-balancing/network/) starten, der Ihnen eine einzelne IP-Adresse gibt, die den gesamten Datenverkehr an Ihren Dienst weiterleitet. In AWS wird ein Load Balancer gestartet.

Sie m√ºssen f√ºr jeden exponierten Dienst einen LoadBalancer bezahlen, was teuer sein kann.

Liste aller LoadBalancers:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,EXTERNAL-IP:.status.loadBalancer.ingress[*],PORT(S):.spec.ports[*].port,NODEPORT(S):.spec.ports[*].nodePort,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep LoadBalancer
```
{% endcode %}

### Externe IPs <a href="#external-ips" id="external-ips"></a>

{% hint style="success" %}
Externe IPs werden von Diensten des Typs Load Balancer bereitgestellt und werden normalerweise verwendet, wenn ein externer Cloud Provider Load Balancer eingesetzt wird.

Um sie zu finden, √ºberpr√ºfen Sie die Load Balancer mit Werten im Feld `EXTERNAL-IP`.
{% endhint %}

Der Datenverkehr, der mit der **externen IP** (als **Ziel-IP**) in den Cluster gelangt, wird am Service-Port **an einen der Service-Endpunkte weitergeleitet**. `externalIPs` werden nicht von Kubernetes verwaltet und liegen in der Verantwortung des Cluster-Administrators.

Im Service-Spezifikationsdokument k√∂nnen `externalIPs` zusammen mit einem der `ServiceTypes` angegeben werden. Im folgenden Beispiel kann "`my-service`" von Clients unter "`80.11.12.10:80`" (`externalIP:port`) erreicht werden.
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-service
spec:
selector:
app: MyApp
ports:
- name: http
protocol: TCP
port: 80
targetPort: 9376
externalIPs:
- 80.11.12.10
```
### ExternalName

[**Aus den Dokumenten:**](https://kubernetes.io/docs/concepts/services-networking/service/#externalname) Dienste vom Typ ExternalName **verkn√ºpfen einen Dienst mit einem DNS-Namen**, nicht mit einem typischen Selektor wie `my-service` oder `cassandra`. Diese Dienste geben Sie mit dem Parameter `spec.externalName` an.

Diese Dienstdefinition verkn√ºpft beispielsweise den `my-service` Dienst im `prod` Namespace mit `my.database.example.com`:
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-service
namespace: prod
spec:
type: ExternalName
externalName: my.database.example.com
```
Beim Nachschlagen des Hosts `my-service.prod.svc.cluster.local` gibt der Cluster-DNS-Dienst einen `CNAME`-Eintrag mit dem Wert `my.database.example.com` zur√ºck. Der Zugriff auf `my-service` funktioniert auf die gleiche Weise wie bei anderen Diensten, jedoch mit dem entscheidenden Unterschied, dass **die Umleitung auf DNS-Ebene** und nicht √ºber Proxy oder Weiterleitung erfolgt.

Liste aller ExternalNames:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces | grep ExternalName
```
{% endcode %}

### Ingress

Im Gegensatz zu all den oben genannten Beispielen ist **Ingress KEIN Typ von Dienst**. Stattdessen sitzt es **vor mehreren Diensten und fungiert als ‚Äûintelligenter Router‚Äú** oder Einstiegspunkt in Ihren Cluster.

Sie k√∂nnen mit einem Ingress viele verschiedene Dinge tun, und es gibt **viele Arten von Ingress-Controllern, die unterschiedliche F√§higkeiten haben**.

Der standardm√§√üige GKE Ingress-Controller wird f√ºr Sie einen [HTTP(S) Load Balancer](https://cloud.google.com/compute/docs/load-balancing/http/) erstellen. Dies erm√∂glicht Ihnen sowohl pfadbasiertes als auch subdomainbasiertes Routing zu Backend-Diensten. Zum Beispiel k√∂nnen Sie alles auf foo.yourdomain.com an den foo-Dienst senden und alles unter dem Pfad yourdomain.com/bar/ an den bar-Dienst.

Die YAML f√ºr ein Ingress-Objekt auf GKE mit einem [L7 HTTP Load Balancer](https://cloud.google.com/compute/docs/load-balancing/http/) k√∂nnte so aussehen:
```yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
name: my-ingress
spec:
backend:
serviceName: other
servicePort: 8080
rules:
- host: foo.mydomain.com
http:
paths:
- backend:
serviceName: foo
servicePort: 8080
- host: mydomain.com
http:
paths:
- path: /bar/*
backend:
serviceName: bar
servicePort: 8080
```
Liste alle Ingresses:

{% code overflow="wrap" %}
```bash
kubectl get ingresses --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,RULES:spec.rules[*],STATUS:status'
```
{% endcode %}

Obwohl es in diesem Fall besser ist, die Informationen einzeln abzurufen, um sie besser lesen zu k√∂nnen:
```bash
kubectl get ingresses --all-namespaces -o=yaml
```
### References

* [https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0](https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0)
* [https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
