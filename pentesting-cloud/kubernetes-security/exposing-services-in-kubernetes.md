# Exposing Services in Kubernetes

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

Il existe **diff√©rentes mani√®res d'exposer des services** dans Kubernetes afin que les points de terminaison **internes** et **externes** puissent y acc√©der. Cette configuration Kubernetes est assez critique car l'administrateur pourrait donner acc√®s √† **des attaquants √† des services auxquels ils ne devraient pas avoir acc√®s**.

### Automatic Enumeration

Avant de commencer √† √©num√©rer les fa√ßons dont K8s offre d'exposer des services au public, sachez que si vous pouvez lister les espaces de noms, les services et les ingresses, vous pouvez trouver tout ce qui est expos√© au public avec :
```bash
kubectl get namespace -o custom-columns='NAME:.metadata.name' | grep -v NAME | while IFS='' read -r ns; do
echo "Namespace: $ns"
kubectl get service -n "$ns"
kubectl get ingress -n "$ns"
echo "=============================================="
echo ""
echo ""
done | grep -v "ClusterIP"
# Remove the last '| grep -v "ClusterIP"' to see also type ClusterIP
```
### ClusterIP

Un **service ClusterIP** est le **service par d√©faut** de Kubernetes. Il vous fournit un **service √† l'int√©rieur** de votre cluster auquel d'autres applications √† l'int√©rieur de votre cluster peuvent acc√©der. Il n'y a **pas d'acc√®s externe**.

Cependant, cela peut √™tre accessible en utilisant le Proxy Kubernetes :
```bash
kubectl proxy --port=8080
```
Maintenant, vous pouvez naviguer √† travers l'API Kubernetes pour acc√©der aux services en utilisant ce sch√©ma :

`http://localhost:8080/api/v1/proxy/namespaces/<NAMESPACE>/services/<SERVICE-NAME>:<PORT-NAME>/`

Par exemple, vous pourriez utiliser l'URL suivante :

`http://localhost:8080/api/v1/proxy/namespaces/default/services/my-internal-service:http/`

pour acc√©der √† ce service :
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-internal-service
spec:
selector:
app: my-app
type: ClusterIP
ports:
- name: http
port: 80
targetPort: 80
protocol: TCP
```
_Cette m√©thode n√©cessite que vous ex√©cutiez `kubectl` en tant qu'**utilisateur authentifi√©**._

Listez tous les ClusterIPs :

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,PORT(S):.spec.ports[*].port,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep ClusterIP
```
{% endcode %}

### NodePort

Lorsque **NodePort** est utilis√©, un port d√©sign√© est rendu disponible sur tous les n≈ìuds (repr√©sentant les machines virtuelles). **Le trafic** dirig√© vers ce port sp√©cifique est ensuite syst√©matiquement **achemin√© vers le service**. En g√©n√©ral, cette m√©thode n'est pas recommand√©e en raison de ses inconv√©nients.

Liste de tous les NodePorts :

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,PORT(S):.spec.ports[*].port,NODEPORT(S):.spec.ports[*].nodePort,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep NodePort
```
{% endcode %}

Un exemple de sp√©cification NodePort :
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-nodeport-service
spec:
selector:
app: my-app
type: NodePort
ports:
- name: http
port: 80
targetPort: 80
nodePort: 30036
protocol: TCP
```
Si vous **ne sp√©cifiez pas** le **nodePort** dans le yaml (c'est le port qui sera ouvert), un port dans la **plage 30000‚Äì32767 sera utilis√©**.

### LoadBalancer <a href="#id-0d96" id="id-0d96"></a>

Expose le Service √† l'ext√©rieur **en utilisant le load balancer d'un fournisseur de cloud**. Sur GKE, cela lancera un [Network Load Balancer](https://cloud.google.com/compute/docs/load-balancing/network/) qui vous donnera une seule adresse IP qui redirigera tout le trafic vers votre service. Sur AWS, cela lancera un Load Balancer.

Vous devez payer pour un LoadBalancer par service expos√©, ce qui peut √™tre co√ªteux.

Listez tous les LoadBalancers :

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,EXTERNAL-IP:.status.loadBalancer.ingress[*],PORT(S):.spec.ports[*].port,NODEPORT(S):.spec.ports[*].nodePort,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep LoadBalancer
```
{% endcode %}

### IPs externes <a href="#external-ips" id="external-ips"></a>

{% hint style="success" %}
Les IPs externes sont expos√©es par des services de type Load Balancers et elles sont g√©n√©ralement utilis√©es lorsqu'un Load Balancer de fournisseur de cloud externe est utilis√©.

Pour les trouver, v√©rifiez les load balancers avec des valeurs dans le champ `EXTERNAL-IP`.
{% endhint %}

Le trafic qui entre dans le cluster avec l'**IP externe** (comme **IP de destination**), sur le port du Service, sera **achemin√© vers l'un des points de terminaison du Service**. `externalIPs` ne sont pas g√©r√©s par Kubernetes et rel√®vent de la responsabilit√© de l'administrateur du cluster.

Dans la sp√©cification du Service, `externalIPs` peuvent √™tre sp√©cifi√©s avec n'importe lequel des `ServiceTypes`. Dans l'exemple ci-dessous, "`my-service`" peut √™tre accessible par des clients sur "`80.11.12.10:80`" (`externalIP:port`)
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-service
spec:
selector:
app: MyApp
ports:
- name: http
protocol: TCP
port: 80
targetPort: 9376
externalIPs:
- 80.11.12.10
```
### ExternalName

[**D'apr√®s la documentation :**](https://kubernetes.io/docs/concepts/services-networking/service/#externalname) Les Services de type ExternalName **associent un Service √† un nom DNS**, et non √† un s√©lecteur typique tel que `my-service` ou `cassandra`. Vous sp√©cifiez ces Services avec le param√®tre `spec.externalName`.

Cette d√©finition de Service, par exemple, associe le Service `my-service` dans l'espace de noms `prod` √† `my.database.example.com` :
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-service
namespace: prod
spec:
type: ExternalName
externalName: my.database.example.com
```
Lors de la recherche de l'h√¥te `my-service.prod.svc.cluster.local`, le Service DNS du cluster renvoie un enregistrement `CNAME` avec la valeur `my.database.example.com`. L'acc√®s √† `my-service` fonctionne de la m√™me mani√®re que d'autres Services, mais avec la diff√©rence cruciale que **la redirection se produit au niveau DNS** plut√¥t que par le biais de proxy ou de transfert.

Listez tous les ExternalNames :

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces | grep ExternalName
```
{% endcode %}

### Ingress

Contrairement √† tous les exemples ci-dessus, **Ingress n'est PAS un type de service**. Au lieu de cela, il se trouve **devant plusieurs services et agit comme un "routeur intelligent"** ou point d'entr√©e dans votre cluster.

Vous pouvez faire beaucoup de choses diff√©rentes avec un Ingress, et il existe **de nombreux types de contr√¥leurs Ingress qui ont des capacit√©s diff√©rentes**.

Le contr√¥leur d'ingress GKE par d√©faut mettra en place un [√©quilibreur de charge HTTP(S)](https://cloud.google.com/compute/docs/load-balancing/http/) pour vous. Cela vous permettra de faire √† la fois un routage bas√© sur le chemin et un routage bas√© sur le sous-domaine vers des services backend. Par exemple, vous pouvez envoyer tout sur foo.yourdomain.com au service foo, et tout sous le chemin yourdomain.com/bar/ au service bar.

Le YAML pour un objet Ingress sur GKE avec un [√©quilibreur de charge HTTP L7](https://cloud.google.com/compute/docs/load-balancing/http/) pourrait ressembler √† ceci :
```yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
name: my-ingress
spec:
backend:
serviceName: other
servicePort: 8080
rules:
- host: foo.mydomain.com
http:
paths:
- backend:
serviceName: foo
servicePort: 8080
- host: mydomain.com
http:
paths:
- path: /bar/*
backend:
serviceName: bar
servicePort: 8080
```
Listez tous les ingresses :

{% code overflow="wrap" %}
```bash
kubectl get ingresses --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,RULES:spec.rules[*],STATUS:status'
```
{% endcode %}

Bien qu'il soit pr√©f√©rable dans ce cas d'obtenir les informations de chacun un par un pour mieux les lire :
```bash
kubectl get ingresses --all-namespaces -o=yaml
```
### R√©f√©rences

* [https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0](https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0)
* [https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/)

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
