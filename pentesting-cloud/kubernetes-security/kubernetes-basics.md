# Bases de Kubernetes

## Bases de Kubernetes

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

**L'auteur original de cette page est** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(lisez son post original** [**ici**](https://sickrov.github.io)**)**

## Architecture et bases

### Que fait Kubernetes ?

* Permet d'ex√©cuter un ou des conteneurs dans un moteur de conteneurs.
* La planification permet d'optimiser les missions des conteneurs.
* Garde les conteneurs en vie.
* Permet les communications entre les conteneurs.
* Permet les techniques de d√©ploiement.
* G√®re des volumes d'informations.

### Architecture

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Node** : syst√®me d'exploitation avec un pod ou des pods.
* **Pod** : Enveloppe autour d'un conteneur ou de plusieurs conteneurs. Un pod ne devrait contenir qu'une seule application (donc g√©n√©ralement, un pod ex√©cute juste 1 conteneur). Le pod est la fa√ßon dont Kubernetes abstrait la technologie des conteneurs en cours d'ex√©cution.
* **Service** : Chaque pod a une **adresse IP interne** de la plage interne du n≈ìud. Cependant, il peut √©galement √™tre expos√© via un service. Le **service a √©galement une adresse IP** et son objectif est de maintenir la communication entre les pods, donc si l'un meurt, le **nouveau remplacement** (avec une adresse IP interne diff√©rente) **sera accessible** expos√© dans la **m√™me IP du service**. Il peut √™tre configur√© comme interne ou externe. Le service agit √©galement comme un **√©quilibreur de charge lorsque 2 pods sont connect√©s** au m√™me service.\
Lorsqu'un **service** est **cr√©√©**, vous pouvez trouver les points de terminaison de chaque service en ex√©cutant `kubectl get endpoints`
* **Kubelet** : Agent principal du n≈ìud. Le composant qui √©tablit la communication entre le n≈ìud et kubectl, et ne peut ex√©cuter que des pods (via le serveur API). Le kubelet ne g√®re pas les conteneurs qui n'ont pas √©t√© cr√©√©s par Kubernetes.
* **Kube-proxy** : est le service charg√© des communications (services) entre l'apiserver et le n≈ìud. La base est un IPtables pour les n≈ìuds. Les utilisateurs les plus exp√©riment√©s pourraient installer d'autres kube-proxies provenant d'autres fournisseurs.
* **Conteneur Sidecar** : Les conteneurs Sidecar sont les conteneurs qui doivent s'ex√©cuter aux c√¥t√©s du conteneur principal dans le pod. Ce mod√®le Sidecar √©tend et am√©liore la fonctionnalit√© des conteneurs actuels sans les modifier. De nos jours, nous savons que nous utilisons la technologie des conteneurs pour encapsuler toutes les d√©pendances n√©cessaires √† l'ex√©cution de l'application n'importe o√π. Un conteneur ne fait qu'une seule chose et le fait tr√®s bien.
* **Processus ma√Ætre :**
* **Serveur API** : C'est la fa√ßon dont les utilisateurs et les pods communiquent avec le processus ma√Ætre. Seules les demandes authentifi√©es doivent √™tre autoris√©es.
* **Ordonnanceur** : L'ordonnancement consiste √† s'assurer que les Pods sont associ√©s √† des n≈ìuds pour que Kubelet puisse les ex√©cuter. Il a suffisamment d'intelligence pour d√©cider quel n≈ìud a plus de ressources disponibles et attribuer le nouveau pod √† celui-ci. Notez que l'ordonnanceur ne d√©marre pas de nouveaux pods, il communique simplement avec le processus Kubelet s'ex√©cutant √† l'int√©rieur du n≈ìud, qui lancera le nouveau pod.
* **Gestionnaire de contr√¥leur Kube** : Il v√©rifie les ressources comme les ensembles de r√©plicas ou les d√©ploiements pour v√©rifier si, par exemple, le bon nombre de pods ou de n≈ìuds est en cours d'ex√©cution. En cas de pod manquant, il communiquera avec l'ordonnanceur pour en d√©marrer un nouveau. Il contr√¥le la r√©plication, les jetons et les services de compte vers l'API.
* **etcd** : Stockage de donn√©es, persistant, coh√©rent et distribu√©. C'est la base de donn√©es de Kubernetes et le stockage cl√©-valeur o√π il conserve l'√©tat complet des clusters (chaque changement est consign√© ici). Des composants comme l'Ordonnanceur ou le Gestionnaire de contr√¥le d√©pendent de ces donn√©es pour savoir quels changements se sont produits (ressources disponibles des n≈ìuds, nombre de pods en cours d'ex√©cution...)
* **Gestionnaire de contr√¥leur Cloud** : C'est le contr√¥leur sp√©cifique pour les contr√¥les de flux et les applications, par exemple : si vous avez des clusters sur AWS ou OpenStack.

Notez qu'il peut y avoir plusieurs n≈ìuds (ex√©cutant plusieurs pods), il peut √©galement y avoir plusieurs processus ma√Ætres dont l'acc√®s √† l'apiserver est √©quilibr√© et leur etcd synchronis√©.

**Volumes :**

Lorsqu'un pod cr√©e des donn√©es qui ne doivent pas √™tre perdues lorsque le pod dispara√Æt, elles doivent √™tre stock√©es dans un volume physique. **Kubernetes permet de joindre un volume √† un pod pour persister les donn√©es**. Le volume peut √™tre sur la machine locale ou dans un **stockage distant**. Si vous ex√©cutez des pods sur diff√©rents n≈ìuds physiques, vous devriez utiliser un stockage distant pour que tous les pods puissent y acc√©der.

**Autres configurations :**

* **ConfigMap** : Vous pouvez configurer des **URL** pour acc√©der aux services. Le pod obtiendra des donn√©es d'ici pour savoir comment communiquer avec le reste des services (pods). Notez que ce n'est pas l'endroit recommand√© pour enregistrer des informations d'identification !
* **Secret** : C'est l'endroit pour **stocker des donn√©es secr√®tes** comme des mots de passe, des cl√©s API... encod√©s en B64. Le pod pourra acc√©der √† ces donn√©es pour utiliser les informations d'identification requises.
* **D√©ploiements** : C'est l√† que les composants √† ex√©cuter par Kubernetes sont indiqu√©s. Un utilisateur ne travaillera g√©n√©ralement pas directement avec des pods, les pods sont abstraits dans des **R√©pliques** (nombre de m√™mes pods r√©pliqu√©s), qui sont ex√©cut√©s via des d√©ploiements. Notez que les d√©ploiements sont pour des applications **sans √©tat**. La configuration minimale pour un d√©ploiement est le nom et l'image √† ex√©cuter.
* **StatefulSet** : Ce composant est sp√©cifiquement destin√© aux applications comme les **bases de donn√©es** qui ont besoin d'**acc√©der au m√™me stockage**.
* **Ingress** : C'est la configuration qui est utilis√©e pour **exposer l'application publiquement avec une URL**. Notez que cela peut √©galement √™tre fait en utilisant des services externes, mais c'est la bonne fa√ßon d'exposer l'application.
* Si vous impl√©mentez un Ingress, vous devrez cr√©er des **Contr√¥leurs Ingress**. Le Contr√¥leur Ingress est un **pod** qui sera le point de terminaison qui recevra les demandes, les v√©rifiera et les √©quilibrera vers les services. le contr√¥leur Ingress **enverra la demande en fonction des r√®gles Ingress configur√©es**. Notez que les r√®gles Ingress peuvent pointer vers diff√©rents chemins ou m√™me sous-domaines vers diff√©rents services internes de Kubernetes.
* Une meilleure pratique de s√©curit√© serait d'utiliser un √©quilibreur de charge cloud ou un serveur proxy comme point d'entr√©e pour ne pas exposer une partie du cluster Kubernetes.
* Lorsqu'une demande qui ne correspond √† aucune r√®gle Ingress est re√ßue, le contr√¥leur Ingress la dirigera vers le "**Backend par d√©faut**". Vous pouvez `d√©crire` le contr√¥leur Ingress pour obtenir l'adresse de ce param√®tre.
* `minikube addons enable ingress`
### Infrastructure PKI - Autorit√© de certification CA :

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA est la racine de confiance pour tous les certificats √† l'int√©rieur du cluster.
* Permet aux composants de se valider mutuellement.
* Tous les certificats du cluster sont sign√©s par la CA.
* ETCd a son propre certificat.
* types :
  * certificat apiserver.
  * certificat kubelet.
  * certificat scheduler.

## Actions de base

### Minikube

**Minikube** peut √™tre utilis√© pour effectuer certains **tests rapides** sur Kubernetes sans avoir besoin de d√©ployer tout un environnement Kubernetes. Il ex√©cutera les **processus ma√Ætre et n≈ìud sur une seule machine**. Minikube utilisera virtualbox pour ex√©cuter le n≈ìud. Voir [**ici comment l'installer**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
üòÑ  minikube v1.19.0 on Ubuntu 20.04
‚ú®  Automatically selected the virtualbox driver. Other choices: none, ssh
üíø  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Starting control plane node minikube in cluster minikube
üíæ  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
üê≥  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
‚ñ™ Generating certificates and keys ...
‚ñ™ Booting up control plane ...
‚ñ™ Configuring RBAC rules ...
üîé  Verifying Kubernetes components...
‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
üî•  Deleting "minikube" in virtualbox ...
üíÄ  Removed all traces of the "minikube" cluster
```
### Bases de Kubectl

**`Kubectl`** est l'outil en ligne de commande pour les clusters Kubernetes. Il communique avec le serveur Api du processus ma√Ætre pour effectuer des actions dans Kubernetes ou demander des donn√©es.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Tableau de bord Minikube

Le tableau de bord vous permet de voir plus facilement ce que minikube ex√©cute, vous pouvez trouver l'URL pour y acc√©der dans :
```
minikube dashboard --url


üîå  Enabling dashboard ...
‚ñ™ Using image kubernetesui/dashboard:v2.3.1
‚ñ™ Using image kubernetesui/metrics-scraper:v1.0.7
ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Exemples de fichiers de configuration YAML

Chaque fichier de configuration a 3 parties : **m√©tadonn√©es**, **sp√©cification** (ce qui doit √™tre lanc√©), **√©tat** (√©tat souhait√©).\
√Ä l'int√©rieur de la sp√©cification du fichier de configuration de d√©ploiement, vous pouvez trouver le mod√®le d√©fini avec une nouvelle structure de configuration d√©finissant l'image √† ex√©cuter :

**Exemple de d√©ploiement + service d√©clar√© dans le m√™me fichier de configuration (√† partir de** [**ici**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Comme un service est g√©n√©ralement li√© √† un d√©ploiement, il est possible de d√©clarer les deux dans le m√™me fichier de configuration (le service d√©clar√© dans cette configuration n'est accessible qu'en interne) :
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Exemple de configuration de service externe**

Ce service sera accessible de l'ext√©rieur (v√©rifiez les attributs `nodePort` et `type: LoadBalancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Ceci est utile pour les tests mais pour la production, vous devriez avoir uniquement des services internes et un Ingress pour exposer l'application.
{% endhint %}

**Exemple de fichier de configuration Ingress**

Cela exposera l'application sur `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Exemple de fichier de configuration des secrets**

Notez comment les mots de passe sont encod√©s en B64 (ce qui n'est pas s√©curis√© !)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Exemple de ConfigMap**

Un **ConfigMap** est la configuration qui est donn√©e aux pods afin qu'ils sachent comment localiser et acc√©der √† d'autres services. Dans ce cas, chaque pod saura que le nom `mongodb-service` est l'adresse d'un pod avec lequel ils peuvent communiquer (ce pod ex√©cutera un mongodb) :
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Ensuite, √† l'int√©rieur d'une **configuration de d√©ploiement**, cette adresse peut √™tre sp√©cifi√©e de la mani√®re suivante pour √™tre charg√©e √† l'int√©rieur de l'environnement de la capsule :
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Exemple de configuration de volume**

Vous pouvez trouver diff√©rents exemples de fichiers de configuration yaml de stockage sur [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Notez que les volumes ne sont pas √† l'int√©rieur des espaces de noms**

### Espaces de noms

Kubernetes prend en charge **plusieurs clusters virtuels** pris en charge par le m√™me cluster physique. Ces clusters virtuels sont appel√©s **espaces de noms**. Ils sont destin√©s √† √™tre utilis√©s dans des environnements avec de nombreux utilisateurs r√©partis sur plusieurs √©quipes ou projets. Pour les clusters avec quelques dizaines d'utilisateurs, vous ne devriez pas avoir besoin de cr√©er ou de penser aux espaces de noms du tout. Vous devriez commencer √† utiliser les espaces de noms pour avoir un meilleur contr√¥le et une meilleure organisation de chaque partie de l'application d√©ploy√©e dans Kubernetes.

Les espaces de noms fournissent une port√©e pour les noms. Les noms des ressources doivent √™tre uniques dans un espace de noms, mais pas √† travers les espaces de noms. Les espaces de noms ne peuvent pas √™tre imbriqu√©s les uns dans les autres et **chaque** **ressource** Kubernetes ne peut √™tre **que dans** **un** **espace de noms**.

Il y a 4 espaces de noms par d√©faut si vous utilisez minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: Ce n'est pas destin√© √† √™tre utilis√© par les utilisateurs et vous ne devriez pas y toucher. C'est pour les processus master et kubectl.
* **kube-public**: Donn√©es accessibles publiquement. Contient un configmap qui contient des informations sur le cluster.
* **kube-node-lease**: D√©termine la disponibilit√© d'un n≈ìud.
* **default**: L'espace de noms que l'utilisateur utilisera pour cr√©er des ressources.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
Notez que la plupart des ressources Kubernetes (par exemple, pods, services, contr√¥leurs de r√©plication, et autres) sont dans certains espaces de noms. Cependant, d'autres ressources comme les ressources de namespace et les ressources de bas niveau, telles que les n≈ìuds et les volumes persistants, ne sont pas dans un espace de noms. Pour voir quelles ressources Kubernetes sont et ne sont pas dans un espace de noms :
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

Vous pouvez enregistrer l'espace de noms pour toutes les commandes kubectl ult√©rieures dans ce contexte.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm est le **gestionnaire de packages** pour Kubernetes. Il permet de regrouper des fichiers YAML et de les distribuer dans des d√©p√¥ts publics et priv√©s. Ces packages sont appel√©s **Helm Charts**.
```
helm search <keyword>
```
## Secrets Kubernetes

Un **Secret** est un objet qui **contient des donn√©es sensibles** telles qu'un mot de passe, un jeton ou une cl√©. Ces informations pourraient autrement √™tre plac√©es dans une sp√©cification de Pod ou dans une image. Les utilisateurs peuvent cr√©er des Secrets et le syst√®me cr√©e √©galement des Secrets. Le nom d'un objet Secret doit √™tre un **nom de sous-domaine DNS valide**. Lisez ici [la documentation officielle](https://kubernetes.io/docs/concepts/configuration/secret/).

Les Secrets peuvent √™tre des choses comme :

- Cl√©s API, SSH.
- Jetons OAuth.
- Informations d'identification, mots de passe (en texte clair ou en base64 + chiffrement).
- Informations ou commentaires.
- Code de connexion √† une base de donn√©es, cha√Ænes‚Ä¶ .

Il existe diff√©rents types de secrets dans Kubernetes

| Type int√©gr√©                        | Utilisation                                |
| ----------------------------------- | ------------------------------------------ |
| **Opaque**                          | **donn√©es d√©finies par l'utilisateur (par d√©faut)** |
| kubernetes.io/service-account-token | jeton de compte de service                 |
| kubernetes.io/dockercfg             | fichier \~/.dockercfg s√©rialis√©            |
| kubernetes.io/dockerconfigjson      | fichier \~/.docker/config.json s√©rialis√©   |
| kubernetes.io/basic-auth            | informations d'identification pour l'authentification de base |
| kubernetes.io/ssh-auth              | informations d'identification pour l'authentification SSH |
| kubernetes.io/tls                   | donn√©es pour un client ou serveur TLS     |
| bootstrap.kubernetes.io/token       | donn√©es de jeton d'amor√ßage                |

{% hint style="info" %}
**Le type Opaque est celui par d√©faut, la paire cl√©-valeur typique d√©finie par les utilisateurs.**
{% endhint %}

**Fonctionnement des secrets :**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Le fichier de configuration suivant d√©finit un **secret** appel√© `mysecret` avec 2 paires cl√©-valeur `username: YWRtaW4=` et `password: MWYyZDFlMmU2N2Rm`. Il d√©finit √©galement un **pod** appel√© `secretpod` qui aura les `username` et `password` d√©finis dans `mysecret` expos√©s dans les **variables d'environnement** `SECRET_USERNAME` et `SECRET_PASSWOR`. Il **montera** √©galement le secret `username` √† l'int√©rieur de `mysecret` dans le chemin `/etc/foo/my-group/my-username` avec des permissions `0640`.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Secrets in etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** est un magasin de cl√©s-valeurs coh√©rent et hautement disponible utilis√© comme support de stockage Kubernetes pour toutes les donn√©es du cluster. Acc√©dons aux secrets stock√©s dans etcd :
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Vous verrez que les certificats, cl√©s et URL sont situ√©s dans le syst√®me de fichiers. Une fois que vous les aurez obtenus, vous pourrez vous connecter √† etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Une fois que vous avez √©tabli la communication, vous pourriez obtenir les secrets :
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Ajout de chiffrement √† l'ETCD**

Par d√©faut, tous les secrets sont **stock√©s en clair** √† l'int√©rieur de etcd √† moins que vous n'appliquiez une couche de chiffrement. L'exemple suivant est bas√© sur [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Apr√®s cela, vous devez d√©finir le drapeau `--encryption-provider-config` sur le `kube-apiserver` pour pointer vers l'emplacement du fichier de configuration cr√©√©. Vous pouvez modifier `/etc/kubernetes/manifest/kube-apiserver.yaml` et ajouter les lignes suivantes:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Faites d√©filer vers le bas dans les volumeMounts :
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Faites d√©filer vers le bas dans les volumeMounts vers hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**V√©rification de l'encryption des donn√©es**

Les donn√©es sont chiffr√©es lorsqu'elles sont √©crites dans etcd. Apr√®s avoir red√©marr√© votre `kube-apiserver`, tout secret nouvellement cr√©√© ou mis √† jour devrait √™tre chiffr√© lorsqu'il est stock√©. Pour v√©rifier, vous pouvez utiliser le programme en ligne de commande `etcdctl` pour r√©cup√©rer le contenu de votre secret.

1. Cr√©ez un nouveau secret appel√© `secret1` dans l'espace de noms `default` :

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. En utilisant la ligne de commande `etcdctl`, lisez ce secret depuis etcd :

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

o√π `[...]` doivent √™tre les arguments suppl√©mentaires pour se connecter au serveur etcd.
3. V√©rifiez que le secret stock√© est pr√©fix√© par `k8s:enc:aescbc:v1:`, ce qui indique que le fournisseur `aescbc` a chiffr√© les donn√©es r√©sultantes.
4. V√©rifiez que le secret est correctement d√©chiffr√© lorsqu'il est r√©cup√©r√© via l'API :

```
kubectl describe secret secret1 -n default
```

devrait correspondre √† `mykey: bXlkYXRh`, mydata est encod√©, consultez [le d√©codage d'un secret](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) pour d√©coder compl√®tement le secret.

**√âtant donn√© que les secrets sont chiffr√©s √† l'√©criture, toute mise √† jour d'un secret chiffrera ce contenu :**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Conseils finaux :**

* Essayez de ne pas garder de secrets dans le syst√®me de fichiers, obtenez-les d'ailleurs.
* Consultez [https://www.vaultproject.io/](https://www.vaultproject.io) pour ajouter une protection suppl√©mentaire √† vos secrets.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## R√©f√©rences

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez** üí¨ le **groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
