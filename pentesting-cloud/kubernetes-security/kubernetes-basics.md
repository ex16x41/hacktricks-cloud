# Fundamentos de Kubernetes

## Fundamentos de Kubernetes

{% hint style="success" %}
Aprende y practica Hacking en AWS: <img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ayuda a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

**El autor original de esta p√°gina es** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(lee su publicaci√≥n original** [**aqu√≠**](https://sickrov.github.io)**)**

## Arquitectura y Fundamentos

### ¬øQu√© hace Kubernetes?

* Permite ejecutar contenedor/es en un motor de contenedores.
* Programa permite que los contenedores cumplan misiones eficientemente.
* Mantiene los contenedores activos.
* Permite la comunicaci√≥n entre contenedores.
* Permite t√©cnicas de implementaci√≥n.
* Maneja vol√∫menes de informaci√≥n.

### Arquitectura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Nodo**: sistema operativo con pod o pods.
* **Pod**: Envoltorio alrededor de un contenedor o m√∫ltiples contenedores. Un pod solo debe contener una aplicaci√≥n (por lo que generalmente, un pod ejecuta solo 1 contenedor). El pod es la forma en que Kubernetes abstrae la tecnolog√≠a de contenedores en ejecuci√≥n.
* **Servicio**: Cada pod tiene 1 **direcci√≥n IP interna** de la gama interna del nodo. Sin embargo, tambi√©n puede ser expuesto a trav√©s de un servicio. El **servicio tambi√©n tiene una direcci√≥n IP** y su objetivo es mantener la comunicaci√≥n entre los pods, por lo que si uno muere, el **nuevo reemplazo** (con una IP interna diferente) **ser√° accesible** expuesto en la **misma IP del servicio**. Puede configurarse como interno o externo. El servicio tambi√©n act√∫a como un **balanceador de carga cuando 2 pods est√°n conectados** al mismo servicio.\
Cuando se **crea un servicio** puedes encontrar los endpoints de cada servicio ejecutando `kubectl get endpoints`
* **Kubelet**: Agente principal del nodo. El componente que establece la comunicaci√≥n entre el nodo y kubectl, y solo puede ejecutar pods (a trav√©s del servidor API). El kubelet no gestiona contenedores que no fueron creados por Kubernetes.
* **Kube-proxy**: es el servicio encargado de las comunicaciones (servicios) entre el servidor API y el nodo. La base es un IPtables para nodos. Los usuarios m√°s experimentados podr√≠an instalar otros kube-proxies de otros proveedores.
* **Contenedor Sidecar**: Los contenedores Sidecar son los contenedores que deben ejecutarse junto con el contenedor principal en el pod. Este patr√≥n de sidecar extiende y mejora la funcionalidad de los contenedores actuales sin cambiarlos. Hoy en d√≠a, sabemos que usamos la tecnolog√≠a de contenedores para envolver todas las dependencias para que la aplicaci√≥n se ejecute en cualquier lugar. Un contenedor hace solo una cosa y hace esa cosa muy bien.
* **Proceso maestro:**
* **Servidor API:** Es la forma en que los usuarios y los pods utilizan para comunicarse con el proceso maestro. Solo se deben permitir solicitudes autenticadas.
* **Programador**: La programaci√≥n se refiere a asegurarse de que los Pods se asignen a los Nodos para que Kubelet pueda ejecutarlos. Tiene la suficiente inteligencia para decidir qu√© nodo tiene m√°s recursos disponibles y asignar el nuevo pod a √©l. Ten en cuenta que el programador no inicia nuevos pods, solo se comunica con el proceso Kubelet que se ejecuta dentro del nodo, que lanzar√° el nuevo pod.
* **Controlador de Kube**: Verifica recursos como conjuntos de r√©plicas o implementaciones para comprobar si, por ejemplo, se est√°n ejecutando el n√∫mero correcto de pods o nodos. En caso de que falte un pod, se comunicar√° con el programador para iniciar uno nuevo. Controla la replicaci√≥n, tokens y servicios de cuentas a la API.
* **etcd**: Almacenamiento de datos, persistente, consistente y distribuido. Es la base de datos de Kubernetes y el almacenamiento clave-valor donde mantiene el estado completo de los cl√∫steres (cada cambio se registra aqu√≠). Componentes como el Programador o el Controlador dependen de estos datos para saber qu√© cambios han ocurrido (recursos disponibles de los nodos, n√∫mero de pods en ejecuci√≥n...)
* **Controlador de la nube**: Es el controlador espec√≠fico para el flujo de controles y aplicaciones, es decir: si tienes cl√∫steres en AWS u OpenStack.

Ten en cuenta que dado que puede haber varios nodos (ejecutando varios pods), tambi√©n puede haber varios procesos maestros cuyo acceso al servidor API est√° balanceado y su etcd sincronizado.

**Vol√∫menes:**

Cuando un pod crea datos que no deben perderse cuando el pod desaparece, deben almacenarse en un volumen f√≠sico. **Kubernetes permite adjuntar un volumen a un pod para persistir los datos**. El volumen puede estar en la m√°quina local o en un **almacenamiento remoto**. Si est√°s ejecutando pods en diferentes nodos f√≠sicos, debes usar un almacenamiento remoto para que todos los pods puedan acceder a √©l.

**Otras configuraciones:**

* **ConfigMap**: Puedes configurar **URLs** para acceder a servicios. El pod obtendr√° datos de aqu√≠ para saber c√≥mo comunicarse con el resto de los servicios (pods). ¬°Ten en cuenta que este no es el lugar recomendado para guardar credenciales!
* **Secreto**: Este es el lugar para **almacenar datos secretos** como contrase√±as, claves API... codificados en B64. El pod podr√° acceder a estos datos para usar las credenciales requeridas.
* **Implementaciones**: Aqu√≠ se indican los componentes que se ejecutar√°n mediante Kubernetes. Un usuario generalmente no trabajar√° directamente con pods, los pods se abstraen en **Conjuntos de R√©plicas** (n√∫mero de pods id√©nticos replicados), que se ejecutan a trav√©s de implementaciones. Ten en cuenta que las implementaciones son para aplicaciones **sin estado**. La configuraci√≥n m√≠nima para una implementaci√≥n es el nombre y la imagen a ejecutar.
* **StatefulSet**: Este componente est√° destinado espec√≠ficamente para aplicaciones como **bases de datos** que necesitan **acceder al mismo almacenamiento**.
* **Ingress**: Esta es la configuraci√≥n que se utiliza para **exponer la aplicaci√≥n p√∫blicamente con una URL**. Ten en cuenta que esto tambi√©n se puede hacer utilizando servicios externos, pero esta es la forma correcta de exponer la aplicaci√≥n.
* Si implementas un Ingress, necesitar√°s crear **Controladores de Ingress**. El Controlador de Ingress es un **pod** que ser√° el punto final que recibir√° las solicitudes y las verificar√° y las balancear√° a los servicios. el controlador de Ingress **enviar√° la solicitud bas√°ndose en las reglas de Ingress configuradas**. Ten en cuenta que las reglas de Ingress pueden apuntar a diferentes rutas o incluso subdominios a diferentes servicios internos de Kubernetes.
* Una pr√°ctica de seguridad mejor ser√≠a utilizar un balanceador de carga en la nube o un servidor proxy como punto de entrada para no exponer ninguna parte del cl√∫ster de Kubernetes.
* Cuando se recibe una solicitud que no coincide con ninguna regla de Ingress, el controlador de Ingress la dirigir√° al "**Backend predeterminado**". Puedes `describir` el controlador de Ingress para obtener la direcci√≥n de este par√°metro.
* `minikube addons enable ingress`
### Infraestructura de PKI - Autoridad de Certificaci√≥n CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA es la ra√≠z de confianza para todos los certificados dentro del cl√∫ster.
* Permite a los componentes validarse entre s√≠.
* Todos los certificados del cl√∫ster son firmados por la CA.
* ETCd tiene su propio certificado.
* tipos:
  * certificado del apiserver.
  * certificado del kubelet.
  * certificado del programador.

## Acciones B√°sicas

### Minikube

**Minikube** se puede utilizar para realizar algunas **pruebas r√°pidas** en Kubernetes sin necesidad de implementar todo un entorno de Kubernetes. Ejecutar√° los **procesos maestro y de nodo en una sola m√°quina**. Minikube utilizar√° virtualbox para ejecutar el nodo. Consulta [**aqu√≠ c√≥mo instalarlo**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
üòÑ  minikube v1.19.0 on Ubuntu 20.04
‚ú®  Automatically selected the virtualbox driver. Other choices: none, ssh
üíø  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Starting control plane node minikube in cluster minikube
üíæ  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
üê≥  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
‚ñ™ Generating certificates and keys ...
‚ñ™ Booting up control plane ...
‚ñ™ Configuring RBAC rules ...
üîé  Verifying Kubernetes components...
‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
üî•  Deleting "minikube" in virtualbox ...
üíÄ  Removed all traces of the "minikube" cluster
```
### Conceptos b√°sicos de Kubectl

**`Kubectl`** es la herramienta de l√≠nea de comandos para cl√∫steres de kubernetes. Se comunica con el servidor Api del proceso principal para realizar acciones en kubernetes o solicitar datos.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Panel de Minikube

El panel te permite ver de forma m√°s sencilla lo que est√° ejecutando Minikube, puedes encontrar la URL para acceder en:
```
minikube dashboard --url


üîå  Enabling dashboard ...
‚ñ™ Using image kubernetesui/dashboard:v2.3.1
‚ñ™ Using image kubernetesui/metrics-scraper:v1.0.7
ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Ejemplos de archivos de configuraci√≥n YAML

Cada archivo de configuraci√≥n tiene 3 partes: **metadatos**, **especificaci√≥n** (lo que se necesita lanzar), **estado** (estado deseado).\
Dentro de la especificaci√≥n del archivo de configuraci√≥n de implementaci√≥n, se puede encontrar la plantilla definida con una nueva estructura de configuraci√≥n que define la imagen a ejecutar:

**Ejemplo de Implementaci√≥n + Servicio declarados en el mismo archivo de configuraci√≥n (desde** [**aqu√≠**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Como un servicio generalmente est√° relacionado con una implementaci√≥n, es posible declarar ambos en el mismo archivo de configuraci√≥n (el servicio declarado en esta configuraci√≥n solo es accesible internamente):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Ejemplo de configuraci√≥n de servicio externo**

Este servicio ser√° accesible externamente (verificar los atributos `nodePort` y `type: LoadBalancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Esto es √∫til para pruebas, pero para producci√≥n deber√≠as tener solo servicios internos y un Ingress para exponer la aplicaci√≥n.
{% endhint %}

**Ejemplo de archivo de configuraci√≥n de Ingress**

Esto expondr√° la aplicaci√≥n en `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Ejemplo de archivo de configuraci√≥n de secretos**

Observa c√≥mo las contrase√±as est√°n codificadas en B64 (¬°lo cual no es seguro!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Ejemplo de ConfigMap**

Un **ConfigMap** es la configuraci√≥n que se proporciona a los pods para que sepan c√≥mo localizar y acceder a otros servicios. En este caso, cada pod sabr√° que el nombre `mongodb-service` es la direcci√≥n de un pod con el que pueden comunicarse (este pod estar√° ejecutando un mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Entonces, dentro de un **archivo de configuraci√≥n de implementaci√≥n** esta direcci√≥n se puede especificar de la siguiente manera para que se cargue dentro del env del pod:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Ejemplo de configuraci√≥n de volumen**

Puedes encontrar diferentes ejemplos de archivos yaml de configuraci√≥n de almacenamiento en [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Ten en cuenta que los vol√∫menes no est√°n dentro de los espacios de nombres**

### Espacios de nombres

Kubernetes admite **m√∫ltiples cl√∫steres virtuales** respaldados por el mismo cl√∫ster f√≠sico. Estos cl√∫steres virtuales se llaman **espacios de nombres**. Est√°n destinados para su uso en entornos con muchos usuarios distribuidos en varios equipos o proyectos. Para cl√∫steres con unos pocos a decenas de usuarios, no deber√≠as necesitar crear o pensar en espacios de nombres en absoluto. Solo deber√≠as empezar a usar espacios de nombres para tener un mejor control y organizaci√≥n de cada parte de la aplicaci√≥n implementada en Kubernetes.

Los espacios de nombres proporcionan un alcance para los nombres. Los nombres de los recursos deben ser √∫nicos dentro de un espacio de nombres, pero no a trav√©s de espacios de nombres. Los espacios de nombres no pueden estar anidados unos dentro de otros y **cada** recurso de Kubernetes solo puede estar **en** **un** **espacio de nombres**.

Hay 4 espacios de nombres de forma predeterminada si est√°s utilizando minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: No est√° destinado para el uso de los usuarios y no se debe modificar. Es para procesos de master y kubectl.
* **kube-public**: Datos accesibles p√∫blicamente. Contiene un configmap que tiene informaci√≥n del cl√∫ster.
* **kube-node-lease**: Determina la disponibilidad de un nodo.
* **default**: El espacio de nombres que el usuario utilizar√° para crear recursos.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
Tenga en cuenta que la mayor√≠a de los recursos de Kubernetes (por ejemplo, pods, servicios, controladores de replicaci√≥n y otros) se encuentran en algunos espacios de nombres. Sin embargo, otros recursos como los recursos de espacio de nombres y los recursos de nivel bajo, como nodos y vol√∫menes persistentes, no est√°n en un espacio de nombres. Para ver qu√© recursos de Kubernetes est√°n y no est√°n en un espacio de nombres:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

Puedes guardar el espacio de nombres para todos los comandos kubectl subsiguientes en ese contexto.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm es el **gestor de paquetes** para Kubernetes. Permite empaquetar archivos YAML y distribuirlos en repositorios p√∫blicos y privados. Estos paquetes se llaman **Helm Charts**.
```
helm search <keyword>
```
## Secretos de Kubernetes

Un **Secreto** es un objeto que **contiene datos sensibles** como una contrase√±a, un token o una clave. Dicha informaci√≥n de otro modo podr√≠a ser colocada en una especificaci√≥n de Pod o en una imagen. Los usuarios pueden crear Secretos y el sistema tambi√©n crea Secretos. El nombre de un objeto Secreto debe ser un **nombre de subdominio DNS v√°lido**. Lee aqu√≠ [la documentaci√≥n oficial](https://kubernetes.io/docs/concepts/configuration/secret/).

Los Secretos pueden ser cosas como:

* API, claves SSH.
* Tokens OAuth.
* Credenciales, contrase√±as (texto plano o b64 + cifrado).
* Informaci√≥n o comentarios.
* C√≥digo de conexi√≥n a bases de datos, cadenas... .

Hay diferentes tipos de secretos en Kubernetes

| Tipo Incorporado                    | Uso                                       |
| ----------------------------------- | ----------------------------------------- |
| **Opaco**                           | **datos definidos por el usuario arbitrarios (Predeterminado)** |
| kubernetes.io/service-account-token | token de cuenta de servicio               |
| kubernetes.io/dockercfg             | archivo \~/.dockercfg serializado         |
| kubernetes.io/dockerconfigjson      | archivo \~/.docker/config.json serializado|
| kubernetes.io/basic-auth            | credenciales para autenticaci√≥n b√°sica   |
| kubernetes.io/ssh-auth              | credenciales para autenticaci√≥n SSH      |
| kubernetes.io/tls                   | datos para un cliente o servidor TLS     |
| bootstrap.kubernetes.io/token       | datos de token de arranque               |

{% hint style="info" %}
**El tipo Opaque es el predeterminado, el par clave-valor t√≠pico definido por los usuarios.**
{% endhint %}

**C√≥mo funcionan los secretos:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

El siguiente archivo de configuraci√≥n define un **secreto** llamado `mysecret` con 2 pares clave-valor `username: YWRtaW4=` y `password: MWYyZDFlMmU2N2Rm`. Tambi√©n define un **pod** llamado `secretpod` que tendr√° el `username` y `password` definidos en `mysecret` expuestos en las **variables de entorno** `SECRET_USERNAME` y `SECRET_PASSWORD`. Tambi√©n **montar√°** el secreto `username` dentro de `mysecret` en la ruta `/etc/foo/my-group/my-username` con permisos `0640`.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Secretos en etcd <a href="#descubrir-secretos-en-etcd" id="descubrir-secretos-en-etcd"></a>

**etcd** es un almac√©n de **clave-valor** consistente y altamente disponible utilizado como almacenamiento de respaldo de Kubernetes para todos los datos del cl√∫ster. Vamos a acceder a los secretos almacenados en etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Ver√°s que los certificados, claves y URL est√°n ubicados en el sistema de archivos. Una vez que los obtengas, podr√°s conectarte a etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Una vez logres establecer la comunicaci√≥n, podr√°s obtener los secretos:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**A√±adiendo cifrado al ETCD**

Por defecto, todos los secretos se almacenan en texto plano dentro de etcd a menos que apliques una capa de cifrado. El siguiente ejemplo est√° basado en [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Despu√©s de eso, necesitas establecer la bandera `--encryption-provider-config` en el `kube-apiserver` para que apunte a la ubicaci√≥n del archivo de configuraci√≥n creado. Puedes modificar `/etc/kubernetes/manifest/kube-apiserver.yaml` y agregar las siguientes l√≠neas:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Despl√°cese hacia abajo en el volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Despl√°cese hacia abajo en los volumeMounts a hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Verificando que los datos est√©n encriptados**

Los datos est√°n encriptados al ser escritos en etcd. Despu√©s de reiniciar tu `kube-apiserver`, cualquier secreto reci√©n creado o actualizado deber√≠a estar encriptado al ser almacenado. Para verificar, puedes usar el programa de l√≠nea de comandos `etcdctl` para recuperar el contenido de tu secreto.

1. Crea un nuevo secreto llamado `secret1` en el espacio de nombres `default`:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. Usando el comando etcdctl, lee ese secreto de etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

donde `[...]` deben ser los argumentos adicionales para conectarse al servidor etcd.
3. Verifica que el secreto almacenado est√© precedido por `k8s:enc:aescbc:v1:`, lo que indica que el proveedor `aescbc` ha encriptado los datos resultantes.
4. Verifica que el secreto se descifre correctamente al ser recuperado a trav√©s de la API:

```
kubectl describe secret secret1 -n default
```

deber√≠a coincidir con `mykey: bXlkYXRh`, mydata est√° codificado, consulta [decodificar un secreto](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) para decodificar completamente el secreto.

**Dado que los secretos est√°n encriptados al escribir, realizar una actualizaci√≥n en un secreto encriptar√° ese contenido:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Consejos finales:**

* Trata de no mantener secretos en el sistema de archivos, obt√©nlos de otros lugares.
* Consulta [https://www.vaultproject.io/](https://www.vaultproject.io) para agregar m√°s protecci√≥n a tus secretos.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## Referencias

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
