# Concetti di base di Kubernetes

## Concetti di base di Kubernetes

{% hint style="success" %}
Impara e pratica l'Hacking su AWS:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

**L'autore originale di questa pagina √®** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(leggi il suo post originale** [**qui**](https://sickrov.github.io)**)**

## Architettura e Concetti di base

### Cosa fa Kubernetes?

* Consente di eseguire container in un motore di container.
* Lo scheduling consente di eseguire i container in modo efficiente.
* Mantiene i container attivi.
* Consente le comunicazioni tra i container.
* Consente tecniche di distribuzione.
* Gestisce volumi di informazioni.

### Architettura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Nodo**: sistema operativo con pod o pod.
* **Pod**: Wrapper attorno a un container o a pi√π container. Un pod dovrebbe contenere solo un'applicazione (quindi di solito, un pod esegue solo 1 container). Il pod √® il modo in cui Kubernetes astrae la tecnologia dei container in esecuzione.
* **Servizio**: Ogni pod ha 1 **indirizzo IP interno** dall'intervallo interno del nodo. Tuttavia, pu√≤ essere esposto anche tramite un servizio. Il **servizio ha anche un indirizzo IP** e il suo obiettivo √® mantenere la comunicazione tra i pod in modo che se uno muore il **nuovo sostituto** (con un diverso IP interno) **sar√† accessibile** esposto nello **stesso IP del servizio**. Pu√≤ essere configurato come interno o esterno. Il servizio agisce anche come **bilanciatore di carico quando 2 pod sono collegati** allo stesso servizio.\
Quando viene **creato un servizio** √® possibile trovare gli endpoint di ciascun servizio eseguendo `kubectl get endpoints`
* **Kubelet**: Agente principale del nodo. Il componente che stabilisce la comunicazione tra il nodo e kubectl e pu√≤ eseguire solo pod (tramite il server API). Il kubelet non gestisce i container che non sono stati creati da Kubernetes.
* **Kube-proxy**: √® il servizio responsabile delle comunicazioni (servizi) tra l'apiserver e il nodo. La base √® un IPtables per i nodi. Gli utenti pi√π esperti potrebbero installare altri kube-proxy da altri fornitori.
* **Container sidecar**: I container sidecar sono i container che dovrebbero essere eseguiti insieme al container principale nel pod. Questo modello sidecar estende e migliora la funzionalit√† dei container attuali senza modificarli. Oggi sappiamo che utilizziamo la tecnologia dei container per incapsulare tutte le dipendenze necessarie affinch√© l'applicazione possa essere eseguita ovunque. Un container fa una sola cosa e la fa molto bene.
* **Processo master:**
* **Server API**: √à il modo in cui gli utenti e i pod comunicano con il processo master. Dovrebbero essere consentite solo richieste autenticate.
* **Scheduler**: Lo scheduling si riferisce a garantire che i Pod siano abbinati ai Nodi in modo che Kubelet possa eseguirli. Ha l'intelligenza sufficiente per decidere quale nodo ha pi√π risorse disponibili per assegnare il nuovo pod. Nota che lo scheduler non avvia nuovi pod, comunica solo con il processo Kubelet in esecuzione all'interno del nodo, che avvier√† il nuovo pod.
* **Kube Controller Manager**: Controlla le risorse come i set di repliche o i deployment per verificare se, ad esempio, il numero corretto di pod o nodi √® in esecuzione. In caso di mancanza di un pod, comunicher√† con lo scheduler per avviarne uno nuovo. Controlla la replica, i token e i servizi account per l'API.
* **etcd**: Archiviazione dati, persistente, coerente e distribuita. √à il database di Kubernetes e lo storage chiave-valore dove conserva lo stato completo dei cluster (ogni modifica viene registrata qui). Componenti come lo Scheduler o il Controller Manager dipendono da questi dati per sapere quali modifiche sono state apportate (risorse disponibili dei nodi, numero di pod in esecuzione...)
* **Cloud controller manager**: √à il controller specifico per il controllo dei flussi e delle applicazioni, ad esempio: se si hanno cluster in AWS o OpenStack.

Si noti che poich√© potrebbero esserci diversi nodi (che eseguono diversi pod), potrebbero anche esserci diversi processi master con accesso all'Api server bilanciato e il loro etcd sincronizzato.

**Volumi:**

Quando un pod crea dati che non devono essere persi quando il pod scompare, dovrebbero essere archiviati in un volume fisico. **Kubernetes consente di collegare un volume a un pod per persistere i dati**. Il volume pu√≤ trovarsi nella macchina locale o in un **archivio remoto**. Se si eseguono pod in nodi fisici diversi, √® necessario utilizzare un archivio remoto in modo che tutti i pod possano accedervi.

**Altre configurazioni:**

* **ConfigMap**: √à possibile configurare **URL** per accedere ai servizi. Il pod otterr√† i dati da qui per sapere come comunicare con il resto dei servizi (pod). Si noti che questo non √® il posto consigliato per salvare le credenziali!
* **Secret**: Questo √® il luogo in cui **memorizzare dati segreti** come password, chiavi API... codificati in B64. Il pod potr√† accedere a questi dati per utilizzare le credenziali richieste.
* **Deployments**: Qui vengono indicati i componenti da eseguire da Kubernetes. Di solito un utente non lavorer√† direttamente con i pod, i pod sono astratti in **ReplicaSets** (numero di pod replicati), che vengono eseguiti tramite i deployments. Si noti che i deployments sono per applicazioni **senza stato**. La configurazione minima per un deployment √® il nome e l'immagine da eseguire.
* **StatefulSet**: Questo componente √® specificamente pensato per applicazioni come **database** che devono **accedere allo stesso archivio**.
* **Ingress**: Questa √® la configurazione che viene utilizzata per **esporre l'applicazione pubblicamente con un URL**. Si noti che questo pu√≤ essere fatto anche utilizzando servizi esterni, ma questo √® il modo corretto per esporre l'applicazione.
* Se si implementa un Ingress sar√† necessario creare **Ingress Controllers**. L'Ingress Controller √® un **pod** che sar√† il punto finale che ricever√† le richieste e le controller√† e le bilancer√† ai servizi. l'Ingress controller **inoltrer√† la richiesta in base alle regole di Ingress configurate**. Si noti che le regole di Ingress possono puntare a percorsi diversi o addirittura a sottodomini a diversi servizi interni di Kubernetes.
* Una pratica di sicurezza migliore sarebbe utilizzare un bilanciatore di carico cloud o un server proxy come punto di ingresso per non avere alcuna parte del cluster Kubernetes esposta.
* Quando viene ricevuta una richiesta che non corrisponde a nessuna regola di Ingress, l'Ingress controller la indirizzer√† al "**Backend predefinito**". √à possibile `descrivere` l'Ingress controller per ottenere l'indirizzo di questo parametro.
* `minikube addons enable ingress`
### Infrastruttura PKI - Autorit√† di Certificazione CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA √® la radice fidata per tutti i certificati all'interno del cluster.
* Consente ai componenti di convalidarsi reciprocamente.
* Tutti i certificati del cluster sono firmati dalla CA.
* ETCd ha il suo certificato.
* tipi:
  * certificato apiserver.
  * certificato kubelet.
  * certificato scheduler.

## Azioni di Base

### Minikube

**Minikube** pu√≤ essere utilizzato per eseguire alcuni **test rapidi** su Kubernetes senza la necessit√† di distribuire un intero ambiente Kubernetes. Eseguir√† i **processi master e node in una sola macchina**. Minikube utilizzer√† virtualbox per eseguire il nodo. Vedi [**qui come installarlo**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
üòÑ  minikube v1.19.0 on Ubuntu 20.04
‚ú®  Automatically selected the virtualbox driver. Other choices: none, ssh
üíø  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Starting control plane node minikube in cluster minikube
üíæ  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
üê≥  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
‚ñ™ Generating certificates and keys ...
‚ñ™ Booting up control plane ...
‚ñ™ Configuring RBAC rules ...
üîé  Verifying Kubernetes components...
‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
üî•  Deleting "minikube" in virtualbox ...
üíÄ  Removed all traces of the "minikube" cluster
```
### Concetti di base di Kubectl

**`Kubectl`** √® lo strumento a riga di comando per i cluster Kubernetes. Comunica con il server Api del processo principale per eseguire azioni in Kubernetes o per richiedere dati.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Dashboard di Minikube

Il dashboard ti permette di vedere pi√π facilmente cosa sta eseguendo minikube, puoi trovare l'URL per accedervi in:
```
minikube dashboard --url


üîå  Enabling dashboard ...
‚ñ™ Using image kubernetesui/dashboard:v2.3.1
‚ñ™ Using image kubernetesui/metrics-scraper:v1.0.7
ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Esempi di file di configurazione YAML

Ogni file di configurazione ha 3 parti: **metadata**, **specification** (cosa deve essere avviato), **status** (stato desiderato).\
All'interno della specifica del file di configurazione del deployment puoi trovare il modello definito con una nuova struttura di configurazione che definisce l'immagine da eseguire:

**Esempio di Deployment + Service dichiarati nello stesso file di configurazione (da** [**qui**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Poich√© un servizio √® di solito correlato a un deployment, √® possibile dichiarare entrambi nello stesso file di configurazione (il servizio dichiarato in questa configurazione √® accessibile solo internamente):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Esempio di configurazione del servizio esterno**

Questo servizio sar√† accessibile esternamente (controlla gli attributi `nodePort` e `type: LoadBalancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Questo √® utile per i test, ma per la produzione dovresti avere solo servizi interni e un Ingress per esporre l'applicazione.
{% endhint %}

**Esempio di file di configurazione di Ingress**

Questo esporr√† l'applicazione su `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Esempio di file di configurazione dei segreti**

Nota come le password siano codificate in B64 (che non √® sicuro!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Esempio di ConfigMap**

Un **ConfigMap** √® la configurazione che viene fornita ai pod in modo che sappiano come individuare e accedere ad altri servizi. In questo caso, ogni pod sapr√† che il nome `mongodb-service` √® l'indirizzo di un pod con cui possono comunicare (questo pod eseguir√† un mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Quindi, all'interno di una **configurazione di distribuzione** questo indirizzo pu√≤ essere specificato nel seguente modo in modo che sia caricato all'interno dell'ambiente del pod:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Esempio di configurazione del volume**

√à possibile trovare diversi esempi di file yaml di configurazione dello storage in [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Nota che i volumi non sono all'interno dei namespace**

### Namespace

Kubernetes supporta **cluster virtuali multipli** supportati dallo stesso cluster fisico. Questi cluster virtuali sono chiamati **namespace**. Sono destinati all'uso in ambienti con molti utenti distribuiti su pi√π team o progetti. Per cluster con pochi o decine di utenti, non dovresti avere bisogno di creare o pensare ai namespace affatto. Dovresti iniziare ad utilizzare i namespace solo per avere un migliore controllo e organizzazione di ogni parte dell'applicazione distribuita in Kubernetes.

I namespace forniscono uno scope per i nomi. I nomi delle risorse devono essere univoci all'interno di un namespace, ma non tra namespace. I namespace non possono essere nidificati l'uno dentro l'altro e **ogni** risorsa di Kubernetes pu√≤ essere **in** **un** **solo** **namespace**.

Ci sono 4 namespace di default se stai utilizzando minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: Non √® destinato all'uso degli utenti e non dovresti toccarlo. √à per i processi master e kubectl.
* **kube-public**: Dati accessibili pubblicamente. Contiene un configmap che contiene informazioni sul cluster.
* **kube-node-lease**: Determina la disponibilit√† di un nodo.
* **default**: Lo spazio dei nomi che l'utente utilizzer√† per creare risorse.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
Si noti che la maggior parte delle risorse di Kubernetes (ad esempio pod, servizi, controller di replica e altri) si trovano in alcuni namespace. Tuttavia, altre risorse come le risorse di namespace e le risorse di basso livello, come i nodi e i volumi persistenti, non si trovano in un namespace. Per vedere quali risorse di Kubernetes sono e non sono in un namespace:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

Puoi salvare lo spazio dei nomi per tutti i comandi kubectl successivi in quel contesto.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm √® il **gestore dei pacchetti** per Kubernetes. Consente di impacchettare file YAML e distribuirli in repository pubblici e privati. Questi pacchetti sono chiamati **Helm Charts**.
```
helm search <keyword>
```
## Segreti di Kubernetes

Un **Segreto** √® un oggetto che **contiene dati sensibili** come una password, un token o una chiave. Tali informazioni potrebbero altrimenti essere inserite in una specifica di Pod o in un'immagine. Gli utenti possono creare Segreti e il sistema crea anche Segreti. Il nome di un oggetto Segreto deve essere un **nome di sottodominio DNS valido**. Leggi qui [la documentazione ufficiale](https://kubernetes.io/docs/concepts/configuration/secret/).

I segreti potrebbero essere cose come:

- API, chiavi SSH.
- Token OAuth.
- Credenziali, Password (testo normale o b64 + crittografia).
- Informazioni o commenti.
- Codice di connessione al database, stringhe... .

Ci sono diversi tipi di segreti in Kubernetes

| Tipo Incorporato                    | Utilizzo                                   |
| ----------------------------------- | ----------------------------------------- |
| **Opaco**                           | **dati definiti dall'utente arbitrari (Predefinito)** |
| kubernetes.io/service-account-token | token dell'account di servizio             |
| kubernetes.io/dockercfg             | file \~/.dockercfg serializzato            |
| kubernetes.io/dockerconfigjson      | file \~/.docker/config.json serializzato   |
| kubernetes.io/basic-auth            | credenziali per l'autenticazione di base   |
| kubernetes.io/ssh-auth              | credenziali per l'autenticazione SSH       |
| kubernetes.io/tls                   | dati per un client o server TLS            |
| bootstrap.kubernetes.io/token       | dati del token di bootstrap                |

{% hint style="info" %}
**Il tipo Opaque √® quello predefinito, il tipico coppia chiave-valore definito dagli utenti.**
{% endhint %}

**Come funzionano i segreti:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Il seguente file di configurazione definisce un **segreto** chiamato `mysecret` con 2 coppie chiave-valore `username: YWRtaW4=` e `password: MWYyZDFlMmU2N2Rm`. Definisce anche un **pod** chiamato `secretpod` che avr√† `username` e `password` definiti in `mysecret` esposti nelle **variabili d'ambiente** `SECRET_USERNAME` e `SECRET_PASSWOR`. Monta anche il segreto `username` all'interno di `mysecret` nel percorso `/etc/foo/my-group/my-username` con permessi `0640`.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Segreti in etcd <a href="#scoprire-segreti-in-etcd" id="scoprire-segreti-in-etcd"></a>

**etcd** √® un **archivio chiave-valore** coerente e altamente disponibile utilizzato come archivio di supporto di Kubernetes per tutti i dati del cluster. Accediamo ai segreti memorizzati in etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Vedrai che i certificati, le chiavi e gli URL sono situati nel FS. Una volta ottenuti, sarai in grado di connetterti a etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Una volta che hai stabilito la comunicazione, sarai in grado di ottenere i segreti:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Aggiunta di crittografia all'ETCD**

Di default tutti i segreti sono **memorizzati in chiaro** all'interno di etcd a meno che non si applichi uno strato di crittografia. L'esempio seguente si basa su [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Dopo di che, √® necessario impostare il flag `--encryption-provider-config` sul `kube-apiserver` per puntare alla posizione del file di configurazione creato. √à possibile modificare `/etc/kubernetes/manifest/kube-apiserver.yaml` e aggiungere le seguenti righe:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Scorri verso il basso in volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Scorri in basso nei volumeMounts fino a hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Verifica che i dati siano crittografati**

I dati sono crittografati quando vengono scritti su etcd. Dopo aver riavviato il tuo `kube-apiserver`, qualsiasi segreto appena creato o aggiornato dovrebbe essere crittografato quando memorizzato. Per verificare, puoi utilizzare il programma a riga di comando `etcdctl` per recuperare il contenuto del tuo segreto.

1. Crea un nuovo segreto chiamato `secret1` nello spazio dei nomi `default`:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. Utilizzando il comando etcdctl, leggi quel segreto da etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

dove `[...]` devono essere gli argomenti aggiuntivi per connettersi al server etcd.
3. Verifica che il segreto memorizzato sia preceduto da `k8s:enc:aescbc:v1:`, il che indica che il provider `aescbc` ha crittografato i dati risultanti.
4. Verifica che il segreto venga correttamente decrittografato quando recuperato tramite l'API:

```
kubectl describe secret secret1 -n default
```

dovrebbe corrispondere a `mykey: bXlkYXRh`, mydata √® codificato, controlla [decodifica di un segreto](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) per decodificare completamente il segreto.

**Poich√© i segreti sono crittografati in scrittura, eseguire un aggiornamento su un segreto crittografer√† quel contenuto:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Suggerimenti finali:**

* Cerca di non conservare segreti nel file system, ottienili da altri luoghi.
* Dai un'occhiata a [https://www.vaultproject.io/](https://www.vaultproject.io) per aggiungere ulteriore protezione ai tuoi segreti.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## Riferimenti

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

{% hint style="success" %}
Impara e pratica l'hacking su AWS:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Impara e pratica l'hacking su GCP: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
