# Osnovi Kubernetes-a

## Osnovi Kubernetes-a

{% hint style="success" %}
Uƒçite i ve≈æbajte AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Uƒçite i ve≈æbajte GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr≈°ka HackTricks-u</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitter-u** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakerske trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

**Originalni autor ove stranice je** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(proƒçitajte njegov originalni post** [**ovde**](https://sickrov.github.io)**)**

## Arhitektura i Osnovi

### ≈†ta radi Kubernetes?

* Omoguƒáava pokretanje kontejnera u kontejnerskom motoru.
* Rasporeƒëivanje omoguƒáava efikasnu misiju kontejnera.
* Odr≈æava kontejnere aktivnim.
* Omoguƒáava komunikaciju izmeƒëu kontejnera.
* Omoguƒáava tehnike implementacije.
* Rukuje koliƒçinama informacija.

### Arhitektura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **ƒåvor**: operativni sistem sa podom ili podovima.
* **Pod**: Omotaƒç oko kontejnera ili vi≈°e kontejnera. Pod bi trebao sadr≈æati samo jednu aplikaciju (tako da obiƒçno, pod pokreƒáe samo 1 kontejner). Pod je naƒçin na koji Kubernetes apstrahuje tehnologiju kontejnera koja se pokreƒáe.
* **Servis**: Svaki pod ima 1 internu **IP adresu** iz unutra≈°njeg opsega ƒçvora. Meƒëutim, mo≈æe biti izlo≈æen i putem servisa. **Servis takoƒëe ima IP adresu** i njegov cilj je odr≈æavanje komunikacije izmeƒëu podova, tako da ako jedan umre, **novi zamenski** (sa drugaƒçijom internom IP) **ƒáe biti dostupan** izlo≈æen u **isto IP servisa**. Mo≈æe se konfigurisati kao unutra≈°nji ili spolja≈°nji. Servis takoƒëe deluje kao **balansirnik optereƒáenja kada su 2 poda povezana** na isti servis.\
Kada se **servis** **kreira**, mo≈æete pronaƒái krajnje taƒçke svakog servisa pokretanjem `kubectl get endpoints`
* **Kubelet**: Primarni agent ƒçvora. Komponenta koja uspostavlja komunikaciju izmeƒëu ƒçvora i kubectl-a, i mo≈æe pokretati samo podove (putem API servera). Kubelet ne upravlja kontejnerima koji nisu kreirani od strane Kubernetes-a.
* **Kube-proxy**: je servis zadu≈æen za komunikaciju (servise) izmeƒëu apiservera i ƒçvora. Osnova je IPtables za ƒçvorove. Najiskusniji korisnici mogu instalirati druge kube-proxije od drugih dobavljaƒça.
* **Sidecar kontejner**: Sidecar kontejneri su kontejneri koji bi trebali raditi zajedno sa glavnim kontejnerom u podu. Ovaj sidecar obrazac pro≈°iruje i pobolj≈°ava funkcionalnost trenutnih kontejnera bez njihovog menjanja. Danas znamo da koristimo tehnologiju kontejnera da obavijemo sve zavisnosti za aplikaciju da bi radila bilo gde. Kontejner radi samo jednu stvar i radi tu stvar veoma dobro.
* **Glavni proces:**
* **Api Server:** Je naƒçin na koji korisnici i podovi komuniciraju sa glavnim procesom. Samo autentifikovani zahtevi bi trebali biti dozvoljeni.
* **Rasporeƒëivaƒç**: Rasporeƒëivanje se odnosi na osiguranje da su podovi usklaƒëeni sa ƒçvorovima kako bi Kubelet mogao da ih pokrene. Ima dovoljno inteligencije da odluƒçi koji ƒçvor ima vi≈°e dostupnih resursa i dodeli novi pod njemu. Imajte na umu da rasporeƒëivaƒç ne pokreƒáe nove podove, samo komunicira sa Kubelet procesom koji se pokreƒáe unutar ƒçvora, koji ƒáe pokrenuti novi pod.
* **Kube Controller menad≈æer**: Proverava resurse kao ≈°to su replikacijski setovi ili implementacije da proveri da li, na primer, ispravan broj podova ili ƒçvorova radi. U sluƒçaju da nedostaje pod, komuniciraƒáe sa rasporeƒëivaƒçem da pokrene novi. Kontroli≈°e replikaciju, tokene i usluge raƒçuna za API.
* **etcd**: Skladi≈°te podataka, postojano, konzistentno i distribuirano. To je baza podataka Kubernetes-a i skladi≈°te kljuƒç-vrednost gde ƒçuva potpuno stanje klastera (svaka promena se ovde bele≈æi). Komponente kao ≈°to su Rasporeƒëivaƒç ili Menad≈æer kontrolera zavise od ovih podataka da bi znale koje su promene nastale (dostupni resursi ƒçvorova, broj pokrenutih podova...)
* **Cloud controller menad≈æer**: Specifiƒçni je kontroler za tokove kontrole i aplikacije, tj: ako imate klastere u AWS-u ili OpenStack-u.

Imajte na umu da kako mo≈æe biti vi≈°e ƒçvorova (koji pokreƒáu vi≈°e podova), mo≈æe biti i vi≈°e glavnih procesa ƒçiji je pristup API serveru balansiran optereƒáenjem i njihov etcd sinhronizovan.

**Volumeni:**

Kada pod kreira podatke koji ne bi trebali biti izgubljeni kada pod nestane, trebali bi biti sme≈°teni u fiziƒçkom volumenu. **Kubernetes omoguƒáava povezivanje volumena sa podom kako bi se podaci saƒçuvali**. Volumen mo≈æe biti na lokalnoj ma≈°ini ili u **daljinskom skladi≈°tu**. Ako pokreƒáete podove na razliƒçitim fiziƒçkim ƒçvorovima, trebali biste koristiti daljinsko skladi≈°te kako bi svi podovi mogli da mu pristupe.

**Druge konfiguracije:**

* **ConfigMap**: Mo≈æete konfigurisati **URL-ove** za pristup servisima. Pod ƒáe dobiti podatke odavde da zna kako da komunicira sa ostalim servisima (podovima). Imajte na umu da ovo nije preporuƒçeno mesto za ƒçuvanje kredencijala!
* **Secret**: Ovo je mesto za **ƒçuvanje tajnih podataka** kao ≈°to su lozinke, API kljuƒçevi... kodirani u B64. Pod ƒáe moƒái da pristupi ovim podacima da koristi potrebne kredencijale.
* **Implementacije**: Ovo je mesto gde su oznaƒçene komponente koje ƒáe se pokretati od strane Kubernetes-a. Korisnik obiƒçno ne radi direktno sa podovima, podovi su apstrahovani u **ReplicaSets** (broj istih podova replikovanih), koji se pokreƒáu putem implementacija. Imajte na umu da su implementacije za **stateless** aplikacije. Minimalna konfiguracija za implementaciju je ime i slika koja se pokreƒáe.
* **StatefulSet**: Ova komponenta je namenjena posebno za aplikacije kao ≈°to su **baze podataka** koje trebaju **pristup istom skladi≈°tu**.
* **Ingress**: Ovo je konfiguracija koja se koristi za **izlaganje aplikacije javno putem URL-a**. Imajte na umu da se ovo mo≈æe uraditi i kori≈°ƒáenjem spolja≈°njih servisa, ali ovo je ispravan naƒçin za izlaganje aplikacije.
* Ako implementirate Ingress, biƒáe potrebno da kreirate **Ingress kontrolere**. Ingress kontroler je **pod** koji ƒáe biti krajnja taƒçka koja ƒáe primati zahteve, proveravati ih i balansirati ih na servise. Ingress kontroler ƒáe **slati zahtev na osnovu konfigurisanih ingress pravila**. Imajte na umu da ingress pravila mogu ukazivati na razliƒçite putanje ili ƒçak poddomene razliƒçitim internim Kubernetes servisima.
* Bolja praksa bezbednosti bi bila kori≈°ƒáenje cloud balansirnika optereƒáenja ili proxy servera kao ulazne taƒçke kako ne bi bilo koje delove Kubernetes klastera izlo≈æene.
* Kada se primi zahtev koji se ne poklapa ni sa jednim ingress pravilom, ingress kontroler ƒáe ga usmeriti na "**Default backend**". Mo≈æete `describe` ingress kontroler da dobijete adresu ovog parametra.
* `minikube addons enable ingress`

### PKI infrastruktura - Sertifikaciona vlast CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA je povereni koren za sve sertifikate unutar klastera.
* Omoguƒáava komponentama da se meƒëusobno validiraju.
* Svi sertifikati klastera su potpisani od strane CA.
* ETCd ima svoj sertifikat.
* tipovi:
* apiserver sertifikat.
* kubelet sertifikat.
* rasporeƒëivaƒç sertifikat.

## Osnovne Akcije

### Minikube

**Minikube** se mo≈æe koristiti za izvoƒëenje nekih **brzih testova** na Kubernetes-u bez potrebe za implementacijom celog Kubernetes okru≈æenja. Pokrenuƒáe **glavne i ƒçvorne procese na jednoj ma≈°ini**. Minikube ƒáe koristiti virtualbox za pokretanje ƒçvora. Pogledajte [**ovde kako da ga instalirate**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
üòÑ  minikube v1.19.0 on Ubuntu 20.04
‚ú®  Automatically selected the virtualbox driver. Other choices: none, ssh
üíø  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Starting control plane node minikube in cluster minikube
üíæ  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
üê≥  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
‚ñ™ Generating certificates and keys ...
‚ñ™ Booting up control plane ...
‚ñ™ Configuring RBAC rules ...
üîé  Verifying Kubernetes components...
‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
üî•  Deleting "minikube" in virtualbox ...
üíÄ  Removed all traces of the "minikube" cluster
```
### Kubectl Osnovi

**`Kubectl`** je alat za komandnu liniju za kubernetes klastere. Komunicira sa Api serverom glavnog procesa kako bi izvr≈°io akcije u kubernetesu ili zatra≈æio podatke.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Dashboard

Kontrolna tabla vam omoguƒáava da lak≈°e vidite ≈°ta minikube pokreƒáe, mo≈æete pronaƒái URL za pristup u:
```
minikube dashboard --url


üîå  Enabling dashboard ...
‚ñ™ Using image kubernetesui/dashboard:v2.3.1
‚ñ™ Using image kubernetesui/metrics-scraper:v1.0.7
ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### YAML –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–µ –¥–∞—Ç–æ—Ç–µ–∫–µ –ø—Ä–∏–º–µ—Ä–∏

–°–≤–∞–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–∞ –¥–∞—Ç–æ—Ç–µ–∫–∞ –∏–º–∞ 3 –¥–µ–ª–∞: **–º–µ—Ç–∞–ø–æ–¥–∞—Ü–∏**, **—Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—ò–∞** (—à—Ç–∞ —Ç—Ä–µ–±–∞ –¥–∞ —Å–µ –ø–æ–∫—Ä–µ–Ω–µ), **—Å—Ç–∞—Ç—É—Å** (–∂–µ—ô–µ–Ω–æ —Å—Ç–∞—ö–µ).\
–£–Ω—É—Ç–∞—Ä —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—ò–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–µ –¥–∞—Ç–æ—Ç–µ–∫–µ –∑–∞ —Ä–∞—Å–ø–æ—Ä–µ—í–∏–≤–∞—ö–µ –º–æ–∂–µ—Ç–µ –ø—Ä–æ–Ω–∞—õ–∏ —à–∞–±–ª–æ–Ω –¥–µ—Ñ–∏–Ω–∏—Å–∞–Ω –Ω–æ–≤–æ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–æ–º —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–º –∫–æ—ò–∞ –¥–µ—Ñ–∏–Ω–∏—à–µ —Å–ª–∏–∫—É –∑–∞ –ø–æ–∫—Ä–µ—Ç–∞—ö–µ:

**–ü—Ä–∏–º–µ—Ä —Ä–∞—Å–ø–æ—Ä–µ—í–∏–≤–∞—ö–∞ + —É—Å–ª—É–≥–µ –¥–µ–∫–ª–∞—Ä–∏—Å–∞–Ω–µ —É –∏—Å—Ç–æ—ò –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–æ—ò –¥–∞—Ç–æ—Ç–µ—Ü–∏ (–∏–∑** [**–æ–≤–¥–µ**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

–ö–∞–∫–æ —ò–µ —É—Å–ª—É–≥–∞ –æ–±–∏—á–Ω–æ –ø–æ–≤–µ–∑–∞–Ω–∞ —Å–∞ —ò–µ–¥–Ω–∏–º —Ä–∞—Å–ø–æ—Ä–µ—í–∏–≤–∞—ö–µ–º, –º–æ–≥—É—õ–µ —ò–µ –¥–µ–∫–ª–∞—Ä–∏—Å–∞—Ç–∏ –æ–±–µ —É –∏—Å—Ç–æ—ò –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–æ—ò –¥–∞—Ç–æ—Ç–µ—Ü–∏ (—É—Å–ª—É–≥–∞ –¥–µ–∫–ª–∞—Ä–∏—Å–∞–Ω–∞ —É –æ–≤–æ—ò –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—ò–∏ —ò–µ –¥–æ—Å—Ç—É–ø–Ω–∞ —Å–∞–º–æ –∏–Ω—Ç–µ—Ä–Ω–æ):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Primer konfiguracije spoljne usluge**

Ova usluga ƒáe biti dostupna spolja (proverite atribute `nodePort` i `type: LoadBlancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Ovo je korisno za testiranje, ali za produkciju trebate imati samo interne usluge i Ingress za izlaganje aplikacije.
{% endhint %}

**Primer Ingress konfiguracione datoteke**

Ovo ƒáe izlo≈æiti aplikaciju na `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Primer konfiguracione datoteke za tajne**

Obratite pa≈ænju na to kako su lozinke kodirane u B64 (≈°to nije sigurno!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Primer ConfigMap-a**

A **ConfigMap** je konfiguracija koja se daje podovima kako bi znali kako da lociraju i pristupaju drugim servisima. U ovom sluƒçaju, svaki pod ƒáe znati da je ime `mongodb-service` adresa poda sa kojim mogu da komuniciraju (ovaj pod ƒáe izvr≈°avati mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Zatim, unutar **deployment config** ova adresa mo≈æe biti specificirana na sledeƒái naƒçin kako bi se uƒçitala unutar env pod-a:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Primer konfiguracije volumena**

Mo≈æete pronaƒái razliƒçite primere yaml datoteka za konfiguraciju skladi≈°ta na [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Napomena: volumeni nisu unutar imenskih prostora**

### Imenski prostori

Kubernetes podr≈æava **vi≈°e virtuelnih klastera** koji se oslanjaju na isti fiziƒçki klaster. Ovi virtuelni klasteri se nazivaju **imenski prostori**. Namenjeni su za kori≈°ƒáenje u okru≈æenjima sa mnogo korisnika rasporeƒëenih u vi≈°e timova ili projekata. Za klastere sa nekoliko do desetina korisnika, ne bi trebalo da kreirate ili razmi≈°ljate o imenskim prostorima. Trebalo bi da poƒçnete da koristite imenske prostore kako biste imali bolju kontrolu i organizaciju svake komponente aplikacije koja je implementirana u kubernetesu.

Imenski prostori pru≈æaju opseg za imena. Imena resursa moraju biti jedinstvena unutar imenskog prostora, ali ne i meƒëu imenskim prostorima. Imenski prostori ne mogu biti ugnje≈ædeni jedni unutar drugih i **svaki** Kubernetes **resurs** mo≈æe biti **samo** **u** **jednom** **imenskom prostoru**.

Postoje 4 imenska prostora po defaultu ako koristite minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: Nije namenjen za kori≈°ƒáenje od strane korisnika i ne biste trebali da ga dirate. Namenjen je za master i kubectl procese.
* **kube-public**: Javna dostupna podataka. Sadr≈æi configmap koji sadr≈æi informacije o klasteru.
* **kube-node-lease**: Odreƒëuje dostupnost ƒçvora.
* **default**: Namespace koji korisnik koristi za kreiranje resursa.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
Napomena da su veƒáina Kubernetes resursa (npr. pods, services, replication controllers i drugi) u nekim namespaces. Meƒëutim, drugi resursi kao ≈°to su namespace resursi i niskonivo resursi, kao ≈°to su nodes i persistenVolumes, nisu u namespace-u. Da biste videli koji Kubernetes resursi su i nisu u namespace-u:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

Mo≈æete saƒçuvati namespace za sve naredne kubectl komande u tom kontekstu.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm je **menad≈æer paketa** za Kubernetes. Omoguƒáava pakovanje YAML datoteka i distribuciju u javnim i privatnim repozitorijumima. Ovi paketi se nazivaju **Helm Charts**.
```
helm search <keyword>
```
Helm je takoƒëe engine za ≈°ablone koji omoguƒáava generisanje konfiguracionih fajlova sa promenljivim vrednostima:

## Kubernetes tajne

**Tajna** je objekat koji **sadr≈æi osetljive podatke** kao ≈°to su lozinka, token ili kljuƒç. Takve informacije bi inaƒçe mogle biti sme≈°tene u specifikaciji Pod-a ili u slici. Korisnici mogu kreirati Tajne, a sistem takoƒëe kreira Tajne. Ime objekta Tajne mora biti va≈æeƒáe **DNS poddomen ime**. Proƒçitajte ovde [slu≈æbenu dokumentaciju](https://kubernetes.io/docs/concepts/configuration/secret/).

Tajne mogu biti stvari poput:

* API, SSH kljuƒçevi.
* OAuth tokeni.
* Akreditivi, Lozinke (obiƒçan tekst ili b64 + enkripcija).
* Informacije ili komentari.
* Kod za povezivanje sa bazom podataka, stringovi‚Ä¶ .

Postoje razliƒçite vrste tajni u Kubernetes-u

| Ugraƒëena vrsta                     | Upotreba                                   |
| ----------------------------------- | ------------------------------------------ |
| **Opaque**                          | **arbitrarni podaci koje defini≈°e korisnik (Podrazumevano)** |
| kubernetes.io/service-account-token | token za servisni nalog                   |
| kubernetes.io/dockercfg             | serijalizovana \~/.dockercfg datoteka     |
| kubernetes.io/dockerconfigjson      | serijalizovana \~/.docker/config.json datoteka |
| kubernetes.io/basic-auth            | akreditivi za osnovnu autentifikaciju      |
| kubernetes.io/ssh-auth              | akreditivi za SSH autentifikaciju          |
| kubernetes.io/tls                   | podaci za TLS klijent ili server           |
| bootstrap.kubernetes.io/token       | podaci o bootstrap tokenu                  |

{% hint style="info" %}
**Opaque tip je podrazumevani, tipiƒçni par kljuƒç-vrednost koji defini≈°u korisnici.**
{% endhint %}

**Kako tajne funkcioni≈°u:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Sledeƒái konfiguracioni fajl defini≈°e **tajnu** pod nazivom `mysecret` sa 2 para kljuƒç-vrednost `username: YWRtaW4=` i `password: MWYyZDFlMmU2N2Rm`. Takoƒëe defini≈°e **pod** pod nazivom `secretpod` koji ƒáe imati `username` i `password` definisane u `mysecret` izlo≈æene u **promenljivim okru≈æenja** `SECRET_USERNAME` \_\_ i \_\_ `SECRET_PASSWOR`. Takoƒëe ƒáe **montirati** `username` tajnu unutar `mysecret` na putanji `/etc/foo/my-group/my-username` sa `0640` dozvolama.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Secrets in etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** je konzistentna i visoko dostupna **key-value baza podataka** koja se koristi kao pozadinska baza za sve podatke klastera u Kubernetes-u. Hajde da pristupimo tajnama koje su pohranjene u etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Videƒáete certifikate, kljuƒçeve i URL-ove gde se nalaze u FS-u. Kada ih dobijete, moƒái ƒáete da se pove≈æete na etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Kada uspostavite komunikaciju, moƒái ƒáete da dobijete tajne:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Dodavanje enkripcije u ETCD**

Po defaultu, sve tajne su **sme≈°tene u obiƒçnom** tekstu unutar etcd-a, osim ako ne primenite sloj enkripcije. Sledeƒái primer se zasniva na [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Nakon toga, potrebno je postaviti `--encryption-provider-config` zastavicu na `kube-apiserver` da ukazuje na lokaciju kreirane konfiguracione datoteke. Mo≈æete izmeniti `/etc/kubernetes/manifest/kube-apiserver.yaml` i dodati sledeƒáe linije:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Scroll down in the volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Scroll down in the volumeMounts to hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Proveravanje da li su podaci enkriptovani**

Podaci su enkriptovani kada se zapisuju u etcd. Nakon ponovnog pokretanja va≈°eg `kube-apiserver`, svaka nova ili a≈æurirana tajna treba da bude enkriptovana kada se skladi≈°ti. Da biste proverili, mo≈æete koristiti `etcdctl` komandnu liniju da preuzmete sadr≈æaj va≈°e tajne.

1.  Kreirajte novu tajnu pod nazivom `secret1` u `default` imenskom prostoru:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2.  Koristeƒái etcdctl komandnu liniju, proƒçitajte tu tajnu iz etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

gde `[...]` moraju biti dodatni argumenti za povezivanje sa etcd serverom.
3. Proverite da li je saƒçuvana tajna prefiksovana sa `k8s:enc:aescbc:v1:` ≈°to ukazuje da je `aescbc` provajder enkriptovao dobijene podatke.
4.  Proverite da li je tajna ispravno dekriptovana kada se preuzme putem API-ja:

```
kubectl describe secret secret1 -n default
```

trebalo bi da odgovara `mykey: bXlkYXRh`, mydata je kodirana, proverite [dekodiranje tajne](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) da biste potpuno dekodirali tajnu.

**Po≈°to su tajne enkriptovane prilikom pisanja, izvr≈°avanje a≈æuriranja na tajni ƒáe enkriptovati taj sadr≈æaj:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Final tips:**

* Poku≈°ajte da ne ƒçuvate tajne u FS, uzmite ih iz drugih izvora.
* Pogledajte [https://www.vaultproject.io/](https://www.vaultproject.io) za dodatnu za≈°titu va≈°ih tajni.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## References

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
