# Osnove Kubernetes-a

## Osnove Kubernetes-a

{% hint style="success" %}
NauÄite i veÅ¾bajte hakovanje AWS-a:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
NauÄite i veÅ¾bajte hakovanje GCP-a: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

**Originalni autor ove stranice je** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(proÄitajte njegov originalni post** [**ovde**](https://sickrov.github.io)**)**

## Arhitektura i Osnove

### Å ta radi Kubernetes?

* OmoguÄ‡ava pokretanje kontejnera u kontejner maÅ¡ini.
* Planira kontejnere kako bi bili efikasni.
* OdrÅ¾ava kontejnere aktivnim.
* OmoguÄ‡ava komunikaciju kontejnera.
* OmoguÄ‡ava tehnike implementacije.
* Upravlja obimom informacija.

### Arhitektura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Node**: operativni sistem sa podom ili podovima.
* **Pod**: OmotaÄ oko kontejnera ili viÅ¡e kontejnera. Jedan pod treba da sadrÅ¾i samo jednu aplikaciju (tako da obiÄno, jedan pod pokreÄ‡e samo 1 kontejner). Pod je naÄin na koji Kubernetes apstrahuje tehnologiju kontejnera koja se izvrÅ¡ava.
* **Servis**: Svaki pod ima 1 internu **IP adresu** iz interne opsega Ävora. MeÄ‘utim, moÅ¾e biti izloÅ¾en i putem servisa. **Servis takoÄ‘e ima IP adresu** i njegov cilj je odrÅ¾avanje komunikacije izmeÄ‘u podova, tako da ako jedan umre, **novi zamena** (sa razliÄitom internom IP adresom) **Ä‡e biti dostupan** izloÅ¾en na **isto IP adrese servisa**. MoÅ¾e biti konfigurisan kao interni ili eksterni. Servis takoÄ‘e deluje kao **balanser optereÄ‡enja kada su 2 poda povezana** na isti servis.\
Kada se **servis** **kreira** moÅ¾ete pronaÄ‡i krajnje taÄke svakog servisa pokretanjem `kubectl get endpoints`
* **Kubelet**: Primarni Ävorski agent. Komponenta koja uspostavlja komunikaciju izmeÄ‘u Ävora i kubectl-a, i moÅ¾e pokrenuti samo podove (putem API servera). Kubelet ne upravlja kontejnerima koji nisu kreirani od strane Kubernetes-a.
* **Kube-proxy**: je servis zaduÅ¾en za komunikaciju (servisi) izmeÄ‘u api servera i Ävora. Osnova je IPtables za Ävorove. Iskusniji korisnici mogu instalirati druge kube-proksi od drugih dobavljaÄa.
* **Sidecar kontejner**: Sidecar kontejneri su kontejneri koji treba da se pokreÄ‡u zajedno sa glavnim kontejnerom u podu. Ovaj sidecar obrazac proÅ¡iruje i poboljÅ¡ava funkcionalnost trenutnih kontejnera bez njihove promene. Danas znamo da koristimo tehnologiju kontejnera da bismo omotali sve zavisnosti kako bi aplikacija mogla da se izvrÅ¡ava bilo gde. Kontejner radi samo jednu stvar i to radi veoma dobro.
* **Master proces:**
* **API Server:** NaÄin na koji korisnici i podovi komuniciraju sa master procesom. Dozvoljene su samo autentifikovane zahteve.
* **Scheduler**: Planiranje se odnosi na osiguravanje da se Podovi upare sa ÄŒvorovima kako bi Kubelet mogao da ih pokrene. Ima dovoljno inteligencije da odluÄi koji Ävor ima viÅ¡e dostupnih resursa i dodeli novi pod njemu. Napomena da scheduler ne pokreÄ‡e nove podove, veÄ‡ komunicira sa Kubelet procesom koji se izvrÅ¡ava unutar Ävora, koji Ä‡e pokrenuti novi pod.
* **Kube Controller manager**: Proverava resurse poput replika setova ili implementacija kako bi proverio da li, na primer, taÄan broj podova ili Ävorova radi. U sluÄaju nedostatka poda, komuniciraÄ‡e sa planerom da pokrene novi. KontroliÅ¡e replikaciju, tokene i naloge servise API-ju.
* **etcd**: SkladiÅ¡te podataka, trajno, dosledno i distribuirano. To je baza podataka Kubernetes-a i skladiÅ¡te kljuÄ-vrednost gde Äuva kompletan stanje klastera (svaka promena je zabeleÅ¾ena ovde). Komponente poput Planera ili Kontrolera zavise od ovih podataka da bi znale koje promene su se desile (dostupni resursi Ävorova, broj pokrenutih podova...)
* **Cloud controller manager**: SpecifiÄan kontroler za kontrolu toka i aplikacija, npr: ako imate klaster u AWS-u ili OpenStack-u.

Imajte na umu da moÅ¾e biti viÅ¡e Ävorova (koji pokreÄ‡u viÅ¡e podova), takoÄ‘e moÅ¾e biti viÅ¡e master procesa Äiji pristup Api serveru je balansiran optereÄ‡enjem i njihov etcd je sinhronizovan.

**Volumeni:**

Kada pod kreira podatke koji ne smeju biti izgubljeni kada pod nestane, treba ih Äuvati u fiziÄkom volumenu. **Kubernetes omoguÄ‡ava povezivanje volumena sa podom kako bi se podaci saÄuvali**. Volumen moÅ¾e biti na lokalnom raÄunaru ili na **udaljenom skladiÅ¡tu**. Ako pokreÄ‡ete podove na razliÄitim fiziÄkim Ävorovima, trebalo bi koristiti udaljeno skladiÅ¡te kako bi svi podovi mogli da mu pristupe.

**Druge konfiguracije:**

* **ConfigMap**: MoÅ¾ete konfigurisati **URL-ove** za pristup servisima. Pod Ä‡e dobiti podatke odavde kako bi znao kako da komunicira sa ostalim servisima (podovima). Imajte na umu da ovo nije preporuÄeno mesto za Äuvanje kredencijala!
* **Tajna**: Ovo je mesto za **Äuvanje tajnih podataka** poput lozinki, API kljuÄeva... kodiranih u B64. Pod Ä‡e moÄ‡i da pristupi ovim podacima kako bi koristio potrebne akreditive.
* **Implementacije**: Ovde se naznaÄavaju komponente koje Ä‡e pokrenuti Kubernetes. Korisnik obiÄno neÄ‡e direktno raditi sa podovima, podovi su apstrahovani u **ReplicaSet-ove** (broj istih replika podova), koji se pokreÄ‡u putem implementacija. Imajte na umu da su implementacije za **bezstanovne** aplikacije. Minimalna konfiguracija za implementaciju je ime i slika koja Ä‡e se pokrenuti.
* **StatefulSet**: Ova komponenta je namenjena posebno za aplikacije poput **baza podataka** koje moraju da **pristupe istom skladiÅ¡tu**.
* **Ingress**: Ovo je konfiguracija koja se koristi za **izlaganje aplikacije javno sa URL-om**. Imajte na umu da se to takoÄ‘e moÅ¾e uraditi koriÅ¡Ä‡enjem spoljnih servisa, ali ovo je ispravan naÄin za izlaganje aplikacije.
* Ako implementirate Ingress, moraÄ‡ete da kreirate **Ingress kontrolere**. Ingress kontroler je **pod** koji Ä‡e biti krajnja taÄka koja Ä‡e primati zahteve i proveravati ih i usmeravati ih ka servisima. Ingress kontroler Ä‡e **slati zahtev na osnovu konfigurisanih pravila Ingress-a**. Imajte na umu da pravila Ingress-a mogu pokazivati na razliÄite putanje ili Äak poddomene ka razliÄitim internim kubernetes servisima.
* Bolja praksa za bezbednost bila bi koriÅ¡Ä‡enje cloud balansera optereÄ‡enja ili servera posrednika kao ulazne taÄke kako ne bi bilo nijednog dela Kubernetes klastera izloÅ¾enog.
* Kada se primi zahtev koji se ne podudara ni sa jednim pravilom Ingress-a, Ingress kontroler Ä‡e ga usmeriti ka "**Podrazumevanom pozadini**". MoÅ¾ete `opisati` Ingress kontroler da biste dobili adresu ovog parametra.
* `minikube addons enable ingress`
### PKI infrastruktura - Sertifikacioni autoritet CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA je pouzdan koren za sve sertifikate unutar klastera.
* OmoguÄ‡ava komponentama da se meÄ‘usobno validiraju.
* Svi sertifikati klastera su potpisani od strane CA.
* ETCd ima svoj sertifikat.
* Tipovi:
  * Sertifikat apiservera.
  * Sertifikat kubeleta.
  * Sertifikat planera.

## Osnovne radnje

### Minikube

**Minikube** se moÅ¾e koristiti za obavljanje **brzih testova** na Kubernetesu bez potrebe da se implementira ceo kubernetes okruÅ¾enje. PokrenuÄ‡e **master i node procese na jednom raÄunaru**. Minikube Ä‡e koristiti virtualbox za pokretanje noda. Pogledajte [**ovde kako ga instalirati**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
ğŸ˜„  minikube v1.19.0 on Ubuntu 20.04
âœ¨  Automatically selected the virtualbox driver. Other choices: none, ssh
ğŸ’¿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
ğŸ‘  Starting control plane node minikube in cluster minikube
ğŸ’¾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
ğŸ”¥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
ğŸ³  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
â–ª Generating certificates and keys ...
â–ª Booting up control plane ...
â–ª Configuring RBAC rules ...
ğŸ”  Verifying Kubernetes components...
â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
ğŸŒŸ  Enabled addons: storage-provisioner, default-storageclass
ğŸ„  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
ğŸ”¥  Deleting "minikube" in virtualbox ...
ğŸ’€  Removed all traces of the "minikube" cluster
```
### Osnove Kubectl-a

**`Kubectl`** je alat za komandnu liniju za kubernetes klaster. Komunicira sa Api serverom glavnog procesa kako bi obavio radnje u kubernetesu ili zatraÅ¾io podatke.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube kontrolna tabla

Kontrolna tabla vam omoguÄ‡ava da lakÅ¡e vidite Å¡ta minikube pokreÄ‡e, moÅ¾ete pronaÄ‡i URL za pristup u:
```
minikube dashboard --url


ğŸ”Œ  Enabling dashboard ...
â–ª Using image kubernetesui/dashboard:v2.3.1
â–ª Using image kubernetesui/metrics-scraper:v1.0.7
ğŸ¤”  Verifying dashboard health ...
ğŸš€  Launching proxy ...
ğŸ¤”  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Primeri YAML konfiguracionih fajlova

Svaki konfiguracioni fajl ima 3 dela: **metadata**, **specifikaciju** (Å¡ta treba pokrenuti), **status** (Å¾eljeno stanje).\
Unutar specifikacije konfiguracionog fajla za implementaciju, moÅ¾ete pronaÄ‡i Å¡ablon definisan novom konfiguracionom strukturom koja definiÅ¡e sliku za pokretanje:

**Primer implementacije + servisa deklarisanih u istom konfiguracionom fajlu (sa** [**ovde**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

PoÅ¡to je servis obiÄno povezan sa jednom implementacijom, moguÄ‡e je deklarisati oba u istom konfiguracionom fajlu (servis deklarisan u ovom konfigu je dostupan samo interno):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Primer konfiguracije spoljnog servisa**

Ovaj servis Ä‡e biti dostupan spolja (proverite atribute `nodePort` i `type: LoadBalancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Ovo je korisno za testiranje, ali za proizvodnju biste trebali imati samo interne usluge i Ingress za izlaganje aplikacije.
{% endhint %}

**Primer konfiguracionog fajla za Ingress**

Ovo Ä‡e izloÅ¾iti aplikaciju na `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Primer fajla sa tajnim podacima**

Obratite paÅ¾nju kako su lozinke enkodirane u B64 (Å¡to nije bezbedno!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Primer ConfigMape**

**ConfigMap** je konfiguracija koja se daje **pod**-ovima kako bi znali kako da pronaÄ‘u i pristupe drugim uslugama. U ovom sluÄaju, svaki **pod** Ä‡e znati da je ime `mongodb-service` adresa **poda** sa kojim mogu komunicirati (ovaj **pod** Ä‡e izvrÅ¡avati mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Zatim, unutar **konfiguracije implementacije** ovu adresu moÅ¾ete navesti na sledeÄ‡i naÄin kako bi bila uÄitana unutar okruÅ¾enja Äaure:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Primer konfiguracije zapremine**

MoÅ¾ete pronaÄ‡i razliÄite primere konfiguracije skladiÅ¡ta u yaml datotekama na [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Imajte na umu da zapremine nisu unutar imenskih prostora**

### Imenski prostori

Kubernetes podrÅ¾ava **viÅ¡estruke virtuelne klaster** podrÅ¾ane istim fiziÄkim klasterom. Ovi virtuelni klasteri nazivaju se **imenski prostori**. Namijenjeni su za upotrebu u okruÅ¾enjima sa mnogo korisnika rasporeÄ‘enih po viÅ¡e timova ili projekata. Za klaster sa nekoliko desetina korisnika, ne biste trebali morati da kreirate ili razmiÅ¡ljate o imenskim prostorima. Trebali biste poÄeti koristiti imenske prostore kako biste imali bolju kontrolu i organizaciju svakog dela aplikacije implementirane u Kubernetesu.

Imenski prostori pruÅ¾aju opseg za imena. Imena resursa moraju biti jedinstvena unutar imenskog prostora, ali ne preko imenskih prostora. Imenski prostori ne mogu biti ugnijeÅ¾Ä‘eni jedan u drugi i **svaki** Kubernetes **resurs** moÅ¾e biti samo **u** **jednom** **imenskom** **prostoru**.

Postoje 4 imenska prostora podrazumevano ako koristite minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: Nije namenjen korisnicima i ne biste trebali da ga dirate. Namijenjen je master i kubectl procesima.
* **kube-public**: Javno dostupni podaci. SadrÅ¾i configmap koji sadrÅ¾i informacije o klasteru.
* **kube-node-lease**: OdreÄ‘uje dostupnost Ävora.
* **default**: Prostor imena koji Ä‡e korisnik koristiti za kreiranje resursa.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
Imajte na umu da su veÄ‡ina Kubernetes resursa (npr. pods, services, replication controllers i drugi) u nekim namespace-ovima. MeÄ‘utim, drugi resursi poput namespace resursa i resursa niskog nivoa, kao Å¡to su Ävorovi i persistenVolumes, nisu u namespace-u. Da biste videli koji Kubernetes resursi jesu, a koji nisu u namespace-u:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

MoÅ¾ete saÄuvati namespace za sve naredne kubectl komande u tom kontekstu.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm je **menadÅ¾er paketa** za Kubernetes. OmoguÄ‡ava pakovanje YAML datoteka i distribuciju istih u javnim i privatnim repozitorijumima. Ovi paketi se nazivaju **Helm Charts**.
```
helm search <keyword>
```
## Kubernetes tajne

**Tajna** je objekat koji **sadrÅ¾i osetljive podatke** kao Å¡to su lozinka, token ili kljuÄ. Takve informacije bi inaÄe mogle biti smeÅ¡tene u specifikaciji Pod-a ili u slici. Korisnici mogu kreirati Tajne, a sistem takoÄ‘e kreira Tajne. Ime objekta Tajne mora biti validno **DNS poddomensko ime**. ProÄitajte ovde [zvaniÄnu dokumentaciju](https://kubernetes.io/docs/concepts/configuration/secret/).

Tajne mogu biti stvari poput:

* API, SSH kljuÄevi.
* OAuth tokeni.
* Kredencijali, Lozinke (Äisti tekst ili b64 + enkripcija).
* Informacije ili komentari.
* Kod za povezivanje sa bazom podataka, stringoviâ€¦ .

Postoje razliÄite vrste tajni u Kubernetes-u

| UgraÄ‘ena Vrsta                      | Upotreba                                   |
| ----------------------------------- | ----------------------------------------- |
| **Opaq**                            | **proizvoljni podaci definisani od strane korisnika (Podrazumevano)** |
| kubernetes.io/service-account-token | token za servisni nalog                     |
| kubernetes.io/dockercfg             | serijalizovan \~/.dockercfg fajl             |
| kubernetes.io/dockerconfigjson      | serijalizovan \~/.docker/config.json fajl    |
| kubernetes.io/basic-auth            | kredencijali za osnovnu autentikaciju      |
| kubernetes.io/ssh-auth              | kredencijali za SSH autentikaciju        |
| kubernetes.io/tls                   | podaci za TLS klijenta ili server           |
| bootstrap.kubernetes.io/token       | podaci o poÄetnom tokenu                      |

{% hint style="info" %}
**Opaq tip je podrazumevani, tipiÄan par kljuÄ-vrednost definisan od strane korisnika.**
{% endhint %}

**Kako tajne funkcioniÅ¡u:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

SledeÄ‡i konfiguracioni fajl definiÅ¡e **tajnu** nazvanu `mysecret` sa 2 parova kljuÄ-vrednost `korisniÄko_ime: YWRtaW4=` i `lozinka: MWYyZDFlMmU2N2Rm`. TakoÄ‘e definiÅ¡e **pod** nazvan `secretpod` koji Ä‡e imati `korisniÄko_ime` i `lozinku` definisane u `mysecret` izloÅ¾ene u **promenljivim okruÅ¾enja** `SECRET_USERNAME` i `SECRET_PASSWOR`. TakoÄ‘e Ä‡e **montirati** tajnu `korisniÄko_ime` unutar `mysecret` na putanju `/etc/foo/my-group/my-username` sa dozvolama `0640`.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Tajne u etcd <a href="#otkrij-tajne-u-etcd" id="otkrij-tajne-u-etcd"></a>

**etcd** je dosledno i visoko dostupno **skladiÅ¡te kljuÄ-vrednost** koje se koristi kao Kubernetes podrÅ¡ka za sve podatke klastera. Hajde da pristupimo tajnama koje su smeÅ¡tene u etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
VideÄ‡ete da se sertifikati, kljuÄevi i URL-ovi nalaze na FS-u. Kada ih dobijete, biÄ‡ete u moguÄ‡nosti da se poveÅ¾ete sa etcd-om.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Kada uspostavite komunikaciju, biÄ‡ete u moguÄ‡nosti da dobijete tajne:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Dodavanje Å¡ifrovanja ETCD-u**

Podrazumevano, svi tajni podaci se **Äuvaju u obiÄnom** tekstu unutar etcd-a, osim ako ne primenite sloj Å¡ifrovanja. SledeÄ‡i primer je zasnovan na [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Nakon toga, morate postaviti `--encryption-provider-config` zastavicu na `kube-apiserver` da pokazuje na lokaciju kreiranog konfiguracionog fajla. MoÅ¾ete izmeniti `/etc/kubernetes/manifest/kube-apiserver.yaml` i dodati sledeÄ‡e linije:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Pomerite se nadole u volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Pomerite se nadole u volumeMounts do hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Provera da su podaci Å¡ifrovani**

Podaci se Å¡ifruju prilikom upisa u etcd. Nakon ponovnog pokretanja vaÅ¡eg `kube-apiserver`, svaki novo kreirani ili aÅ¾urirani tajni podatak trebao bi biti Å¡ifrovan prilikom Äuvanja. Da biste proverili, moÅ¾ete koristiti `etcdctl` komandnu liniju programa da biste dobili sadrÅ¾aj vaÅ¡e tajne.

1. Kreirajte novu tajnu nazvanu `secret1` u `default` namespace-u:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. KoristeÄ‡i etcdctl komandnu liniju, proÄitajte tu tajnu iz etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

gde `[...]` moraju biti dodatni argumenti za povezivanje sa etcd serverom.
3. Proverite da li je saÄuvana tajna prefiksirana sa `k8s:enc:aescbc:v1:` Å¡to ukazuje da je `aescbc` pruÅ¾alac Å¡ifrovao rezultirajuÄ‡e podatke.
4. Proverite da li je tajna ispravno deÅ¡ifrovana prilikom dobijanja putem API-ja:

```
kubectl describe secret secret1 -n default
```

trebalo bi da se poklopi sa `mykey: bXlkYXRh`, mydata je kodiran, proverite [dekodiranje tajne](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) da biste potpuno dekodirali tajnu.

**PoÅ¡to su tajne Å¡ifrovane prilikom upisa, izvrÅ¡avanje aÅ¾uriranja na tajni Ä‡e Å¡ifrovati taj sadrÅ¾aj:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**KonaÄni saveti:**

* PokuÅ¡ajte da ne Äuvate tajne u FS-u, preuzmite ih sa drugih mesta.
* Posetite [https://www.vaultproject.io/](https://www.vaultproject.io) kako biste dodali viÅ¡e zaÅ¡tite svojim tajnama.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## Reference

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

{% hint style="success" %}
NauÄite i veÅ¾bajte hakovanje AWS:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
NauÄite i veÅ¾bajte hakovanje GCP-a: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>PodrÅ¾ite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
