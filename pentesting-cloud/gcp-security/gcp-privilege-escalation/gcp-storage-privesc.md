# GCP - Storage Privesc

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Storage

Grundinformationen:

{% content-ref url="../gcp-services/gcp-storage-enum.md" %}
[gcp-storage-enum.md](../gcp-services/gcp-storage-enum.md)
{% endcontent-ref %}

### `storage.objects.get`

Diese Berechtigung erlaubt es Ihnen, **Dateien, die in Cloud Storage gespeichert sind, herunterzuladen**. Dies kann potenziell dazu f√ºhren, dass Sie Privilegien eskalieren, da in einigen F√§llen **sensible Informationen dort gespeichert sind**. Dar√ºber hinaus speichern einige GCP-Dienste ihre Informationen in Buckets:

* **GCP Composer**: Wenn Sie eine Composer-Umgebung erstellen, wird der **Code aller DAGs** in einem **Bucket** gespeichert. Diese Aufgaben k√∂nnten interessante Informationen in ihrem Code enthalten.
* **GCR (Container Registry)**: Das **Bild** der Container wird in **Buckets** gespeichert, was bedeutet, dass Sie, wenn Sie die Buckets lesen k√∂nnen, die Bilder herunterladen und **nach Leaks und/oder Quellcode suchen** k√∂nnen.

### `storage.objects.setIamPolicy`

Sie k√∂nnen sich die Berechtigung geben, **eine der vorherigen Szenarien in diesem Abschnitt auszunutzen**.

### **`storage.buckets.setIamPolicy`**

F√ºr ein Beispiel, wie man Berechtigungen mit dieser Berechtigung √§ndert, √ºberpr√ºfen Sie diese Seite:

{% content-ref url="../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md" %}
[gcp-public-buckets-privilege-escalation.md](../gcp-unauthenticated-enum-and-access/gcp-storage-unauthenticated-enum/gcp-public-buckets-privilege-escalation.md)
{% endcontent-ref %}

### `storage.hmacKeys.create`

Die "Interoperabilit√§ts"-Funktion von Cloud Storage, die f√ºr **Cross-Cloud-Interaktionen** wie mit AWS S3 konzipiert ist, umfasst die **Erstellung von HMAC-Schl√ºsseln f√ºr Dienstkonten und Benutzer**. Ein Angreifer kann dies ausnutzen, indem er **einen HMAC-Schl√ºssel f√ºr ein Dienstkonto mit erh√∂hten Berechtigungen generiert**, wodurch er **die Privilegien innerhalb von Cloud Storage eskaliert**. W√§hrend HMAC-Schl√ºssel, die mit Benutzern verbunden sind, nur √ºber die Webkonsole abgerufen werden k√∂nnen, bleiben sowohl die Zugriffs- als auch die geheimen Schl√ºssel **dauerhaft zug√§nglich**, was potenziellen Backup-Zugriffsspeicher erm√∂glicht. Im Gegensatz dazu sind HMAC-Schl√ºssel, die mit Dienstkonten verkn√ºpft sind, API-zug√§nglich, aber ihre Zugriffs- und geheimen Schl√ºssel sind nach der Erstellung nicht abrufbar, was eine zus√§tzliche Komplexit√§t f√ºr den kontinuierlichen Zugriff hinzuf√ºgt.

{% code overflow="wrap" %}
```bash
# Create key
gsutil hmac create <sa-email> # You might need to execute this inside a VM instance

## If you have TROUBLES creating the HMAC key this was you can also do it contacting the API directly:
PROJECT_ID = '$PROJECT_ID'
TARGET_SERVICE_ACCOUNT = f"exam-storage-sa-read-flag-3@{PROJECT_ID}.iam.gserviceaccount.com"
ACCESS_TOKEN = "$CLOUDSDK_AUTH_ACCESS_TOKEN"
import requests
import json
key = requests.post(
f'https://www.googleapis.com/storage/v1/projects/{PROJECT_ID}/hmacKeys',
params={'access_token': ACCESS_TOKEN, 'serviceAccountEmail': TARGET_SERVICE_ACCOUNT}
).json()
#print(json.dumps(key, indent=4))
print(f'ID: {key["metadata"]["accessId"]}')
print(f'Secret: {key["secret"]}')


# Configure gsutil to use the HMAC key
gcloud config set pass_credentials_to_gsutil false
gsutil config -a

# Use it
gsutil ls gs://[BUCKET_NAME]

# Restore
gcloud config set pass_credentials_to_gsutil true
```
{% endcode %}

Ein weiteres Exploit-Skript f√ºr diese Methode finden Sie [hier](https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation/blob/master/ExploitScripts/storage.hmacKeys.create.py).

## `storage.objects.create`, `storage.objects.delete` = Speicher Schreibberechtigungen

Um ein **neues Objekt** in einem Bucket zu **erstellen**, ben√∂tigen Sie `storage.objects.create` und, gem√§√ü [den Dokumenten](https://cloud.google.com/storage/docs/access-control/iam-permissions#object\_permissions), ben√∂tigen Sie auch `storage.objects.delete`, um ein bestehendes Objekt zu **√§ndern**.

Eine sehr **h√§ufige Ausnutzung** von Buckets, in die Sie in der Cloud schreiben k√∂nnen, ist der Fall, dass der **Bucket Webserver-Dateien speichert**. Sie k√∂nnten in der Lage sein, **neuen Code zu speichern**, der von der Webanwendung verwendet wird.

### Composer

**Composer** ist **Apache Airflow**, das innerhalb von GCP verwaltet wird. Es hat mehrere interessante Funktionen:

* Es l√§uft innerhalb eines **GKE-Clusters**, sodass der **SA, den der Cluster verwendet, von dem Code, der innerhalb von Composer ausgef√ºhrt wird, zug√§nglich ist.**
* Alle Komponenten einer Composer-Umgebung (**Code der DAGs**, Plugins und Daten) werden in einem GCP-Bucket gespeichert. Wenn der Angreifer Lese- und Schreibberechtigungen daf√ºr hat, k√∂nnte er den Bucket √ºberwachen und **wann immer ein DAG erstellt oder aktualisiert wird, eine mit einem Hintert√ºr versehenen Version einreichen**, sodass die Composer-Umgebung die Hintert√ºr-Version aus dem Speicher erh√§lt.

**Sie finden einen PoC dieses Angriffs im Repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs**](https://github.com/carlospolop/Monitor-Backdoor-Composer-DAGs)

### Cloud Functions

* Der Code von Cloud Functions wird im Storage gespeichert, und wann immer eine neue Version erstellt wird, wird der Code in den Bucket hochgeladen und dann wird der neue Container aus diesem Code erstellt. Daher ist es **m√∂glich, den Code zu √ºberschreiben, bevor die neue Version erstellt wird, um die Cloud-Funktion dazu zu bringen, beliebigen Code auszuf√ºhren**.

**Sie finden einen PoC dieses Angriffs im Repo:** [**https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions**](https://github.com/carlospolop/Monitor-Backdoor-Cloud-Functions)

### App Engine

AppEngine-Versionen generieren einige Daten in einem Bucket im Formatname: `staging.<project-id>.appspot.com`. In diesem Bucket ist es m√∂glich, einen Ordner namens `ae` zu finden, der einen Ordner pro Version der AppEngine-App enth√§lt, und in diesen Ordnern ist es m√∂glich, die Datei `manifest.json` zu finden. Diese Datei enth√§lt ein JSON mit allen Dateien, die verwendet werden m√ºssen, um die spezifische Version zu erstellen. Dar√ºber hinaus ist es m√∂glich, die **echten Namen der Dateien, die URL zu ihnen im GCP-Bucket (die Dateien im Bucket haben ihren Namen in ihren sha1-Hash ge√§ndert) und den sha1-Hash jeder Datei zu finden.**

_Beachten Sie, dass es nicht m√∂glich ist, diesen Bucket im Voraus zu √ºbernehmen, da GCP-Benutzer nicht autorisiert sind, Buckets mit dem Domainnamen appspot.com zu erstellen._

Mit Lese- und Schreibzugriff auf diesen Bucket ist es jedoch m√∂glich, die Berechtigungen auf den SA, der an der App Engine-Version angeh√§ngt ist, zu eskalieren, indem der Bucket √ºberwacht wird und jedes Mal, wenn eine √Ñnderung vorgenommen wird (neue Version), die neue Version so schnell wie m√∂glich ge√§ndert wird. Auf diese Weise wird der Container, der aus diesem Code erstellt wird, den Hintert√ºr-Code ausf√ºhren.

Der erw√§hnte Angriff kann auf viele verschiedene Arten durchgef√ºhrt werden, alle beginnen mit der √úberwachung des Buckets `staging.<project-id>.appspot.com`:

* Laden Sie den vollst√§ndigen neuen Code der AppEngine-Version in einen anderen und verf√ºgbaren Bucket hoch und bereiten Sie eine **`manifest.json`-Datei mit dem neuen Bucket-Namen und den sha1-Hashes davon** vor. Wenn dann eine neue Version im Bucket erstellt wird, m√ºssen Sie nur die `manifest.json`-Datei √§ndern und die b√∂sartige hochladen.
* Laden Sie eine modifizierte Version von `requirements.txt` hoch, die den **b√∂sartigen Abh√§ngigkeitscode verwendet und die `manifest.json`-Datei** mit dem neuen Dateinamen, der URL und dem Hash davon aktualisiert.
* Laden Sie eine **modifizierte `main.py`- oder `app.yaml`-Datei hoch, die den b√∂sartigen Code ausf√ºhrt** und die `manifest.json`-Datei mit dem neuen Dateinamen, der URL und dem Hash davon aktualisiert.

**Sie finden einen PoC dieses Angriffs im Repo:** [**https://github.com/carlospolop/Monitor-Backdoor-AppEngine**](https://github.com/carlospolop/Monitor-Backdoor-AppEngine)

### GCR

* **Google Container Registry** speichert die Images in Buckets. Wenn Sie **diese Buckets beschreiben k√∂nnen**, k√∂nnten Sie in der Lage sein, **seitlich zu dem Ort zu wechseln, an dem diese Buckets ausgef√ºhrt werden.**
* Der von GCR verwendete Bucket hat eine URL, die √§hnlich ist wie `gs://<eu/usa/asia/nothing>.artifacts.<project>.appspot.com` (Die obersten Subdomains sind [hier](https://cloud.google.com/container-registry/docs/pushing-and-pulling) angegeben).

{% hint style="success" %}
Dieser Dienst ist veraltet, daher ist dieser Angriff nicht mehr n√ºtzlich. Dar√ºber hinaus speichert Artifact Registry, der Dienst, der diesen ersetzt, die Images nicht in Buckets.
{% endhint %}

## **Referenzen**

* [https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/#:\~:text=apiKeys.-,create,privileges%20than%20our%20own%20user.](https://rhinosecuritylabs.com/cloud-security/privilege-escalation-google-cloud-platform-part-2/)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
