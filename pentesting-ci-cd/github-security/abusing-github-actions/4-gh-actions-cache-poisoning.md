# GH Actions - Cache Poisoning

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

For further details check the original post [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)

## Cache Poisoning

Η ενέργεια Git [**action/cache**](https://github.com/actions/cache) εισάγει έναν μηχανισμό caching στη διαδικασία Continuous Integration (CI), που περιλαμβάνει δύο κρίσιμα στάδια:

1. **Run Action**: Αυτό το στάδιο περιλαμβάνει την αναζήτηση και την ανάκτηση δεδομένων από την cache κατά τη διάρκεια της εκτέλεσης CI. Η αναζήτηση χρησιμοποιεί ένα μοναδικό κλειδί cache, παράγοντας δύο αποτελέσματα:
* **Cache-hit**: Τα ζητούμενα δεδομένα βρίσκονται στην cache και ανακτώνται άμεσα.
* **Cache-miss**: Δεν βρέθηκαν αντίστοιχα δεδομένα στην cache, οδηγώντας σε μια νέα λήψη των απαιτούμενων αρχείων και καταλόγων, παρόμοια με μια πρώτη αίτηση.
2. **Post Workflow Action**: Αυτό το στάδιο είναι αφιερωμένο στην caching δεδομένων μετά τη ροή εργασίας CI. Συγκεκριμένα, εάν συμβεί cache-miss κατά τη διάρκεια της εκτέλεσης, η τρέχουσα κατάσταση των καθορισμένων καταλόγων αποθηκεύεται στην cache χρησιμοποιώντας το παρεχόμενο κλειδί. Αυτή η διαδικασία είναι αυτοματοποιημένη και δεν απαιτεί ρητή κλήση.

#### Security Measures: Cache Isolation and Access Restrictions

Για να διατηρηθεί η ασφάλεια και να διασφαλιστεί η απομόνωση της cache, επιβάλλονται περιορισμοί πρόσβασης, δημιουργώντας μια λογική διαχωριστική γραμμή μεταξύ διαφορετικών κλάδων. Για παράδειγμα, μια cache που δημιουργήθηκε για τον κλάδο **Feature-A** (με βάση τον κύριο κλάδο) θα είναι μη προσβάσιμη σε ένα pull request για τον κλάδο **Feature-B** (που επίσης βασίζεται στον κύριο κλάδο).

Η ενέργεια cache ακολουθεί μια συγκεκριμένη σειρά αναζήτησης:

* Πρώτα αναζητά cache hits εντός του ίδιου κλάδου με την εκτέλεση της ροής εργασίας.
* Εάν δεν είναι επιτυχής, επεκτείνει την αναζήτηση στον γονικό κλάδο και σε άλλους ανώτερους κλάδους.

Σημαντικό είναι ότι η πρόσβαση στην cache είναι περιορισμένη στον κλάδο, επεκτεινόμενη σε όλες τις ροές εργασίας και εκτελέσεις ενός συγκεκριμένου κλάδου. Επιπλέον, το GitHub επιβάλλει μια πολιτική μόνο για ανάγνωση για τις καταχωρίσεις cache μόλις δημιουργηθούν, απαγορεύοντας οποιεσδήποτε τροποποιήσεις.

#### Real-World Implication: From Low to High-Permission Workflow Attack

Ένα παραδειγματικό σενάριο CI δείχνει πώς ένας επιτιθέμενος μπορεί να εκμεταλλευτεί την cache poisoning για να κλιμακώσει τα δικαιώματα από μια ροή εργασίας χαμηλών δικαιωμάτων σε μια ροή εργασίας υψηλών δικαιωμάτων:

* Η ροή εργασίας **Unit-test**, υπεύθυνη για την εκτέλεση μονάδων δοκιμών και εργαλείων κάλυψης κώδικα, υποτίθεται ότι χρησιμοποιεί ένα συμβιβασμένο ή ευάλωτο εργαλείο. Αυτή η ροή εργασίας χρησιμοποιεί την ενέργεια **action/cache**, καθιστώντας την cache προσβάσιμη σε οποιαδήποτε ροή εργασίας.
* Η ροή εργασίας **Release**, υπεύθυνη για την κατασκευή και την απελευθέρωση του αντικειμένου εφαρμογής, βελτιστοποιεί τις λειτουργίες της αποθηκεύοντας τις εξαρτήσεις Golang στην cache.

Σε αυτό το σενάριο, η ροή εργασίας unit-test εισάγει μια κακόβουλη καταχώριση cache αντικαθιστώντας μια νόμιμη βιβλιοθήκη καταγραφής Golang (\`go

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
