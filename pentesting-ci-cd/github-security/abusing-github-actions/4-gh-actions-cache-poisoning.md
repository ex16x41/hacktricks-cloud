# GH Actions - Cache Poisoning

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

Para mais detalhes, confira o post original [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)

## Cache Poisoning

A a√ß√£o do Git [**action/cache**](https://github.com/actions/cache) introduz um mecanismo de cache no processo de Integra√ß√£o Cont√≠nua (CI), abrangendo duas etapas cr√≠ticas:

1. **Executar A√ß√£o**: Esta etapa envolve a busca e recupera√ß√£o de dados em cache durante a execu√ß√£o do CI. A busca utiliza uma chave de cache √∫nica, resultando em dois desfechos:
* **Cache-hit**: Os dados solicitados s√£o encontrados no cache e, consequentemente, recuperados para uso imediato.
* **Cache-miss**: Nenhum dado correspondente √© encontrado no cache, levando a um novo download dos arquivos e diret√≥rios necess√°rios, semelhante a uma solicita√ß√£o pela primeira vez.
2. **A√ß√£o P√≥s-Workflow**: Esta etapa √© dedicada ao cache de dados ap√≥s o workflow do CI. Especificamente, se ocorrer um cache-miss durante a a√ß√£o de execu√ß√£o, o estado atual dos diret√≥rios especificados √© armazenado em cache usando a chave fornecida. Este processo √© automatizado e n√£o requer invoca√ß√£o expl√≠cita.

#### Medidas de Seguran√ßa: Isolamento de Cache e Restri√ß√µes de Acesso

Para manter a seguran√ßa e garantir o isolamento do cache, s√£o aplicadas restri√ß√µes de acesso, criando uma separa√ß√£o l√≥gica entre diferentes branches. Por exemplo, um cache criado para a branch **Feature-A** (com base na branch principal) ser√° inacess√≠vel para um pull request da branch **Feature-B** (tamb√©m baseada na branch principal).

A a√ß√£o de cache segue uma ordem de busca espec√≠fica:

* Primeiro, busca hits de cache dentro da mesma branch que a execu√ß√£o do workflow.
* Se n√£o for bem-sucedido, estende a busca para a branch pai e outras branches upstream.

Importante, o acesso ao cache √© limitado √† branch, estendendo-se por todos os workflows e execu√ß√µes de uma branch espec√≠fica. Al√©m disso, o GitHub imp√µe uma pol√≠tica de somente leitura para as entradas de cache uma vez criadas, proibindo quaisquer modifica√ß√µes.

#### Implica√ß√£o no Mundo Real: De um Ataque de Workflow de Baixa a Alta Permiss√£o

Um cen√°rio ilustrativo de CI demonstra como um atacante pode aproveitar o cache poisoning para escalar privil√©gios de um workflow de baixa permiss√£o para um de alta permiss√£o:

* O workflow **Unit-test**, respons√°vel por executar testes unit√°rios e ferramentas de cobertura de c√≥digo, presume-se que utilize uma ferramenta comprometida ou vulner√°vel. Este workflow utiliza a a√ß√£o do Git **action/cache**, tornando o cache acess√≠vel a qualquer workflow.
* O workflow **Release**, encarregado de construir e liberar o artefato da aplica√ß√£o, otimiza suas opera√ß√µes armazenando em cache as depend√™ncias do Golang.

Neste cen√°rio, o workflow de teste unit√°rio introduz uma entrada de cache maliciosa substituindo uma biblioteca de logging leg√≠tima do Golang (\`go
