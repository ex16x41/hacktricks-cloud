# GH Actions - Cache Poisoning

{% hint style="success" %}
Ucz się i ćwicz Hacking AWS:<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Ucz się i ćwicz Hacking GCP: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się sztuczkami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
{% endhint %}

Aby uzyskać więcej szczegółów, sprawdź oryginalny post [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)

## Cache Poisoning

Akcja Git [**action/cache**](https://github.com/actions/cache) wprowadza mechanizm pamięci podręcznej w procesie Continuous Integration (CI), obejmujący dwa kluczowe etapy:

1. **Run Action**: Ten etap polega na wyszukiwaniu i pobieraniu danych z pamięci podręcznej podczas uruchamiania CI. Wyszukiwanie wykorzystuje unikalny klucz pamięci podręcznej, co prowadzi do dwóch wyników:
* **Cache-hit**: Żądane dane znajdują się w pamięci podręcznej i są pobierane do natychmiastowego użycia.
* **Cache-miss**: Nie znaleziono pasujących danych w pamięci podręcznej, co skutkuje świeżym pobraniem wymaganych plików i katalogów, podobnie jak w przypadku pierwszego żądania.
2. **Post Workflow Action**: Ten etap jest poświęcony pamięci podręcznej danych po zakończeniu workflow CI. W szczególności, jeśli wystąpi cache-miss podczas akcji uruchamiania, bieżący stan określonych katalogów jest zapisywany w pamięci podręcznej przy użyciu podanego klucza. Proces ten jest zautomatyzowany i nie wymaga jawnego wywołania.

#### Środki bezpieczeństwa: Izolacja pamięci podręcznej i ograniczenia dostępu

Aby utrzymać bezpieczeństwo i zapewnić izolację pamięci podręcznej, wprowadza się ograniczenia dostępu, tworząc logiczne oddzielenie między różnymi gałęziami. Na przykład, pamięć podręczna utworzona dla gałęzi **Feature-A** (z bazą w gałęzi głównej) będzie niedostępna dla żądania pull dla gałęzi **Feature-B** (również opartej na gałęzi głównej).

Akcja pamięci podręcznej przestrzega określonego porządku wyszukiwania:

* Najpierw szuka trafień w pamięci podręcznej w tej samej gałęzi, co uruchomienie workflow.
* Jeśli to się nie powiedzie, rozszerza wyszukiwanie na gałąź nadrzędną i inne gałęzie upstream.

Co ważne, dostęp do pamięci podręcznej jest ograniczony do gałęzi, obejmując wszystkie workflow i uruchomienia danej gałęzi. Dodatkowo, GitHub wprowadza politykę tylko do odczytu dla wpisów pamięci podręcznej po ich utworzeniu, zabraniając jakichkolwiek modyfikacji.

#### Rzeczywiste implikacje: Atak na workflow z niskimi uprawnieniami do wysokich uprawnień

Ilustrujący scenariusz CI pokazuje, jak atakujący może wykorzystać zatrucie pamięci podręcznej do eskalacji uprawnień z workflow o niskich uprawnieniach do workflow o wysokich uprawnieniach:

* Workflow **Unit-test**, odpowiedzialny za uruchamianie testów jednostkowych i narzędzi do pokrycia kodu, zakłada użycie skompromitowanego lub podatnego narzędzia. Ten workflow wykorzystuje akcję Git **action/cache**, co sprawia, że pamięć podręczna jest dostępna dla każdego workflow.
* Workflow **Release**, odpowiedzialny za budowanie i wydawanie artefaktu aplikacji, optymalizuje swoje operacje, pamiętając zależności Golang.

W tym scenariuszu workflow testów jednostkowych wprowadza złośliwy wpis do pamięci podręcznej, zastępując legalną bibliotekę logowania Golang (\`go
