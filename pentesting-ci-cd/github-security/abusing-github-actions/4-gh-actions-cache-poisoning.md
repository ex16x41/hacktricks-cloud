# GH Actions - Cache Poisoning

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

For further details check the original post [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)

## Cache Poisoning

La acci√≥n de Git [**action/cache**](https://github.com/actions/cache) introduce un mecanismo de cach√© en el proceso de Integraci√≥n Continua (CI), abarcando dos etapas cr√≠ticas:

1. **Ejecutar Acci√≥n**: Esta etapa implica buscar y recuperar datos en cach√© durante la ejecuci√≥n de CI. La b√∫squeda utiliza una clave de cach√© √∫nica, dando lugar a dos resultados:
* **Cache-hit**: Los datos solicitados se encuentran en la cach√© y se recuperan para su uso inmediato.
* **Cache-miss**: No se encuentran datos coincidentes en la cach√©, lo que provoca una nueva descarga de los archivos y directorios requeridos, similar a una solicitud por primera vez.
2. **Acci√≥n Post Workflow**: Esta etapa se dedica a almacenar en cach√© los datos despu√©s del flujo de trabajo de CI. Espec√≠ficamente, si ocurre un cache-miss durante la acci√≥n de ejecuci√≥n, el estado actual de los directorios especificados se almacena en cach√© utilizando la clave proporcionada. Este proceso es automatizado y no requiere invocaci√≥n expl√≠cita.

#### Medidas de Seguridad: Aislamiento de Cach√© y Restricciones de Acceso

Para mantener la seguridad y garantizar el aislamiento de la cach√©, se aplican restricciones de acceso, creando una separaci√≥n l√≥gica entre diferentes ramas. Por ejemplo, una cach√© creada para la rama **Feature-A** (con base en la rama principal) ser√° inaccesible para una solicitud de extracci√≥n para la rama **Feature-B** (tambi√©n basada en la rama principal).

La acci√≥n de cach√© sigue un orden de b√∫squeda espec√≠fico:

* Primero busca aciertos de cach√© dentro de la misma rama que la ejecuci√≥n del flujo de trabajo.
* Si no tiene √©xito, extiende la b√∫squeda a la rama padre y otras ramas ascendentes.

Es importante destacar que el acceso a la cach√© est√° limitado a la rama, extendi√©ndose a trav√©s de todos los flujos de trabajo y ejecuciones de una rama espec√≠fica. Adem√°s, GitHub aplica una pol√≠tica de solo lectura para las entradas de cach√© una vez que se crean, prohibiendo cualquier modificaci√≥n.

#### Implicaci√≥n en el Mundo Real: De un Ataque de Flujo de Trabajo de Baja a Alta Permiso

Un escenario ilustrativo de CI demuestra c√≥mo un atacante podr√≠a aprovechar la contaminaci√≥n de cach√© para escalar privilegios de un flujo de trabajo de baja permiso a uno de alta permiso:

* Se asume que el flujo de trabajo **Unit-test**, responsable de ejecutar pruebas unitarias y herramientas de cobertura de c√≥digo, emplea una herramienta comprometida o vulnerable. Este flujo de trabajo utiliza la acci√≥n de Git **action/cache**, haciendo que la cach√© sea accesible para cualquier flujo de trabajo.
* El flujo de trabajo **Release**, encargado de construir y liberar el artefacto de la aplicaci√≥n, optimiza sus operaciones almacenando en cach√© las dependencias de Golang.

En este escenario, el flujo de trabajo de pruebas unitarias introduce una entrada de cach√© maliciosa al sustituir una biblioteca de registro de Golang leg√≠tima (\`go
