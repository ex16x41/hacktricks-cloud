# GH Actions - Cache Poisoning

{% hint style="success" %}
Ucz się i ćwicz Hacking AWS:<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1) (1).png" alt="" data-size="line">\
Ucz się i ćwicz Hacking GCP: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się sztuczkami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
{% endhint %}

Aby uzyskać więcej szczegółów, sprawdź oryginalny post [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)

## Cache Poisoning

Akcja Git [**action/cache**](https://github.com/actions/cache) wprowadza mechanizm cache'owania w procesie Continuous Integration (CI), obejmując dwa kluczowe etapy:

1. **Run Action**: Ten etap polega na wyszukiwaniu i pobieraniu danych z cache podczas uruchamiania CI. Wyszukiwanie wykorzystuje unikalny klucz cache, co prowadzi do dwóch wyników:
* **Cache-hit**: Żądane dane znajdują się w cache i są pobierane do natychmiastowego użycia.
* **Cache-miss**: Nie znaleziono pasujących danych w cache, co skutkuje pobraniem wymaganych plików i katalogów, podobnie jak w przypadku pierwszego żądania.
2. **Post Workflow Action**: Ten etap jest poświęcony cache'owaniu danych po workflow CI. W szczególności, jeśli podczas akcji uruchamiania wystąpi cache-miss, bieżący stan określonych katalogów jest cache'owany przy użyciu podanego klucza. Proces ten jest zautomatyzowany i nie wymaga jawnego wywołania.

#### Środki bezpieczeństwa: Izolacja cache i ograniczenia dostępu

Aby utrzymać bezpieczeństwo i zapewnić izolację cache, wprowadza się ograniczenia dostępu, tworząc logiczne oddzielenie między różnymi gałęziami. Na przykład, cache utworzony dla gałęzi **Feature-A** (z bazą w gałęzi głównej) będzie niedostępny dla pull requesta dla gałęzi **Feature-B** (również opartej na gałęzi głównej).

Akcja cache przestrzega określonego porządku wyszukiwania:

* Najpierw szuka trafień cache w tej samej gałęzi, co uruchomienie workflow.
* Jeśli to się nie powiedzie, rozszerza wyszukiwanie na gałąź nadrzędną i inne gałęzie upstream.

Co ważne, dostęp do cache jest ograniczony do gałęzi, obejmując wszystkie workflow i uruchomienia danej gałęzi. Dodatkowo, GitHub wprowadza politykę tylko do odczytu dla wpisów cache po ich utworzeniu, zabraniając jakichkolwiek modyfikacji.

#### Rzeczywiste implikacje: Atak na workflow z niskimi uprawnieniami do wysokich uprawnień

Ilustrujący scenariusz CI pokazuje, jak atakujący może wykorzystać cache poisoning do eskalacji uprawnień z workflow o niskich uprawnieniach do workflow o wysokich uprawnieniach:

* Workflow **Unit-test**, odpowiedzialny za uruchamianie testów jednostkowych i narzędzi do pokrycia kodu, zakłada, że korzysta z narzędzia, które zostało skompromitowane lub jest podatne. Ten workflow wykorzystuje akcję Git **action/cache**, co sprawia, że cache jest dostępny dla każdego workflow.
* Workflow **Release**, odpowiedzialny za budowanie i wydawanie artefaktu aplikacji, optymalizuje swoje operacje, cache'ując zależności Golang.

W tym scenariuszu workflow testów jednostkowych wprowadza złośliwy wpis do cache, zastępując legalną bibliotekę logowania Golang (\`go
